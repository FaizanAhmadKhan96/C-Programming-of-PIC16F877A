CCS PCM C Compiler, Version 5.015, 5967               10-Feb-19 10:32

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\MPPT2\kdg.lst

               ROM used:   1180 words (14%)
                           Largest free fragment is 2048
               RAM used:   46 (12%) at main() level
                           78 (21%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   281
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
*
0018:  MOVLW  8E
0019:  MOVWF  77
001A:  MOVF   5A,W
001B:  MOVWF  78
001C:  MOVF   59,W
001D:  MOVWF  79
001E:  CLRF   7A
001F:  MOVF   78,F
0020:  BTFSS  03.2
0021:  GOTO   02C
0022:  MOVF   79,W
0023:  MOVWF  78
0024:  CLRF   79
0025:  MOVLW  08
0026:  SUBWF  77,F
0027:  MOVF   78,F
0028:  BTFSS  03.2
0029:  GOTO   02C
002A:  CLRF   77
002B:  GOTO   034
002C:  BCF    03.0
002D:  BTFSC  78.7
002E:  GOTO   033
002F:  RLF    79,F
0030:  RLF    78,F
0031:  DECF   77,F
0032:  GOTO   02C
0033:  BCF    78.7
0034:  RETURN
0035:  MOVLW  80
0036:  BTFSC  03.1
0037:  XORWF  5E,F
0038:  CLRF   63
0039:  CLRF   64
003A:  MOVF   5A,W
003B:  MOVWF  62
003C:  MOVF   5E,W
003D:  XORWF  62,F
003E:  MOVF   59,W
003F:  BTFSC  03.2
0040:  GOTO   125
0041:  MOVWF  61
0042:  MOVWF  77
0043:  MOVF   5D,W
0044:  BTFSC  03.2
0045:  GOTO   12E
0046:  SUBWF  61,F
0047:  BTFSC  03.2
0048:  GOTO   0CA
0049:  BTFSS  03.0
004A:  GOTO   088
004B:  MOVF   5E,W
004C:  MOVWF  67
004D:  BSF    67.7
004E:  MOVF   5F,W
004F:  MOVWF  66
0050:  MOVF   60,W
0051:  MOVWF  65
0052:  CLRF   64
0053:  BCF    03.0
0054:  RRF    67,F
0055:  RRF    66,F
0056:  RRF    65,F
0057:  RRF    64,F
0058:  DECFSZ 61,F
0059:  GOTO   052
005A:  BTFSS  62.7
005B:  GOTO   05F
005C:  BSF    63.0
005D:  GOTO   142
005E:  BCF    63.0
005F:  BCF    61.0
0060:  BSF    63.4
0061:  MOVLW  5C
0062:  MOVWF  04
0063:  BCF    03.7
0064:  GOTO   157
0065:  BCF    63.4
0066:  BTFSC  62.7
0067:  GOTO   072
0068:  BTFSS  61.0
0069:  GOTO   07D
006A:  RRF    67,F
006B:  RRF    66,F
006C:  RRF    65,F
006D:  RRF    64,F
006E:  INCF   77,F
006F:  BTFSC  03.2
0070:  GOTO   13D
0071:  GOTO   07D
0072:  BTFSC  67.7
0073:  GOTO   080
0074:  BCF    03.0
0075:  RLF    64,F
0076:  RLF    65,F
0077:  RLF    66,F
0078:  RLF    67,F
0079:  DECF   77,F
007A:  BTFSC  03.2
007B:  GOTO   13D
007C:  GOTO   072
007D:  BSF    63.6
007E:  GOTO   0EA
007F:  BCF    63.6
0080:  MOVF   5A,W
0081:  MOVWF  62
0082:  BTFSS  62.7
0083:  GOTO   086
0084:  BSF    67.7
0085:  GOTO   136
0086:  BCF    67.7
0087:  GOTO   136
0088:  MOVF   5D,W
0089:  MOVWF  61
008A:  MOVWF  77
008B:  MOVF   59,W
008C:  SUBWF  61,F
008D:  MOVF   5A,W
008E:  MOVWF  67
008F:  BSF    67.7
0090:  MOVF   5B,W
0091:  MOVWF  66
0092:  MOVF   5C,W
0093:  MOVWF  65
0094:  CLRF   64
0095:  BCF    03.0
0096:  RRF    67,F
0097:  RRF    66,F
0098:  RRF    65,F
0099:  RRF    64,F
009A:  DECFSZ 61,F
009B:  GOTO   094
009C:  BTFSS  62.7
009D:  GOTO   0A1
009E:  BSF    63.1
009F:  GOTO   142
00A0:  BCF    63.1
00A1:  BCF    61.0
00A2:  BSF    63.5
00A3:  MOVLW  60
00A4:  MOVWF  04
00A5:  BCF    03.7
00A6:  GOTO   157
00A7:  BCF    63.5
00A8:  BTFSC  62.7
00A9:  GOTO   0B4
00AA:  BTFSS  61.0
00AB:  GOTO   0BF
00AC:  RRF    67,F
00AD:  RRF    66,F
00AE:  RRF    65,F
00AF:  RRF    64,F
00B0:  INCF   77,F
00B1:  BTFSC  03.2
00B2:  GOTO   13D
00B3:  GOTO   0BF
00B4:  BTFSC  67.7
00B5:  GOTO   0C2
00B6:  BCF    03.0
00B7:  RLF    64,F
00B8:  RLF    65,F
00B9:  RLF    66,F
00BA:  RLF    67,F
00BB:  DECF   77,F
00BC:  BTFSC  03.2
00BD:  GOTO   13D
00BE:  GOTO   0B4
00BF:  BSF    63.7
00C0:  GOTO   0EA
00C1:  BCF    63.7
00C2:  MOVF   5E,W
00C3:  MOVWF  62
00C4:  BTFSS  62.7
00C5:  GOTO   0C8
00C6:  BSF    67.7
00C7:  GOTO   136
00C8:  BCF    67.7
00C9:  GOTO   136
00CA:  MOVF   5E,W
00CB:  MOVWF  67
00CC:  BSF    67.7
00CD:  MOVF   5F,W
00CE:  MOVWF  66
00CF:  MOVF   60,W
00D0:  MOVWF  65
00D1:  BTFSS  62.7
00D2:  GOTO   0D7
00D3:  BCF    67.7
00D4:  BSF    63.2
00D5:  GOTO   142
00D6:  BCF    63.2
00D7:  CLRF   64
00D8:  BCF    61.0
00D9:  MOVLW  5C
00DA:  MOVWF  04
00DB:  BCF    03.7
00DC:  GOTO   157
00DD:  BTFSC  62.7
00DE:  GOTO   100
00DF:  MOVF   5A,W
00E0:  MOVWF  62
00E1:  BTFSS  61.0
00E2:  GOTO   0EA
00E3:  RRF    67,F
00E4:  RRF    66,F
00E5:  RRF    65,F
00E6:  RRF    64,F
00E7:  INCF   77,F
00E8:  BTFSC  03.2
00E9:  GOTO   13D
00EA:  BTFSS  64.7
00EB:  GOTO   0FB
00EC:  INCF   65,F
00ED:  BTFSS  03.2
00EE:  GOTO   0FB
00EF:  INCF   66,F
00F0:  BTFSS  03.2
00F1:  GOTO   0FB
00F2:  INCF   67,F
00F3:  BTFSS  03.2
00F4:  GOTO   0FB
00F5:  RRF    67,F
00F6:  RRF    66,F
00F7:  RRF    65,F
00F8:  INCF   77,F
00F9:  BTFSC  03.2
00FA:  GOTO   13D
00FB:  BTFSC  63.6
00FC:  GOTO   07F
00FD:  BTFSC  63.7
00FE:  GOTO   0C1
00FF:  GOTO   11F
0100:  MOVLW  80
0101:  XORWF  67,F
0102:  BTFSS  67.7
0103:  GOTO   108
0104:  GOTO   142
0105:  MOVF   5E,W
0106:  MOVWF  62
0107:  GOTO   115
0108:  MOVF   5A,W
0109:  MOVWF  62
010A:  MOVF   67,F
010B:  BTFSS  03.2
010C:  GOTO   115
010D:  MOVF   66,F
010E:  BTFSS  03.2
010F:  GOTO   115
0110:  MOVF   65,F
0111:  BTFSS  03.2
0112:  GOTO   115
0113:  CLRF   77
0114:  GOTO   136
0115:  BTFSC  67.7
0116:  GOTO   11F
0117:  BCF    03.0
0118:  RLF    64,F
0119:  RLF    65,F
011A:  RLF    66,F
011B:  RLF    67,F
011C:  DECFSZ 77,F
011D:  GOTO   115
011E:  GOTO   13D
011F:  BTFSS  62.7
0120:  GOTO   123
0121:  BSF    67.7
0122:  GOTO   136
0123:  BCF    67.7
0124:  GOTO   136
0125:  MOVF   5D,W
0126:  MOVWF  77
0127:  MOVF   5E,W
0128:  MOVWF  67
0129:  MOVF   5F,W
012A:  MOVWF  66
012B:  MOVF   60,W
012C:  MOVWF  65
012D:  GOTO   136
012E:  MOVF   59,W
012F:  MOVWF  77
0130:  MOVF   5A,W
0131:  MOVWF  67
0132:  MOVF   5B,W
0133:  MOVWF  66
0134:  MOVF   5C,W
0135:  MOVWF  65
0136:  MOVF   67,W
0137:  MOVWF  78
0138:  MOVF   66,W
0139:  MOVWF  79
013A:  MOVF   65,W
013B:  MOVWF  7A
013C:  GOTO   175
013D:  CLRF   77
013E:  CLRF   78
013F:  CLRF   79
0140:  CLRF   7A
0141:  GOTO   175
0142:  CLRF   64
0143:  COMF   65,F
0144:  COMF   66,F
0145:  COMF   67,F
0146:  COMF   64,F
0147:  INCF   64,F
0148:  BTFSS  03.2
0149:  GOTO   150
014A:  INCF   65,F
014B:  BTFSS  03.2
014C:  GOTO   150
014D:  INCF   66,F
014E:  BTFSC  03.2
014F:  INCF   67,F
0150:  BTFSC  63.0
0151:  GOTO   05E
0152:  BTFSC  63.1
0153:  GOTO   0A0
0154:  BTFSC  63.2
0155:  GOTO   0D6
0156:  GOTO   105
0157:  MOVF   00,W
0158:  ADDWF  65,F
0159:  BTFSS  03.0
015A:  GOTO   161
015B:  INCF   66,F
015C:  BTFSS  03.2
015D:  GOTO   161
015E:  INCF   67,F
015F:  BTFSC  03.2
0160:  BSF    61.0
0161:  DECF   04,F
0162:  MOVF   00,W
0163:  ADDWF  66,F
0164:  BTFSS  03.0
0165:  GOTO   169
0166:  INCF   67,F
0167:  BTFSC  03.2
0168:  BSF    61.0
0169:  DECF   04,F
016A:  MOVF   00,W
016B:  BTFSS  00.7
016C:  XORLW  80
016D:  ADDWF  67,F
016E:  BTFSC  03.0
016F:  BSF    61.0
0170:  BTFSC  63.4
0171:  GOTO   065
0172:  BTFSC  63.5
0173:  GOTO   0A7
0174:  GOTO   0DD
0175:  RETURN
0176:  MOVF   59,W
0177:  BTFSC  03.2
0178:  GOTO   23B
0179:  MOVWF  65
017A:  MOVF   5D,W
017B:  BTFSC  03.2
017C:  GOTO   23B
017D:  SUBWF  65,F
017E:  BTFSS  03.0
017F:  GOTO   185
0180:  MOVLW  7F
0181:  ADDWF  65,F
0182:  BTFSC  03.0
0183:  GOTO   23B
0184:  GOTO   18B
0185:  MOVLW  81
0186:  SUBWF  65,F
0187:  BTFSS  03.0
0188:  GOTO   23B
0189:  BTFSC  03.2
018A:  GOTO   23B
018B:  MOVF   65,W
018C:  MOVWF  77
018D:  CLRF   78
018E:  CLRF   79
018F:  CLRF   7A
0190:  CLRF   64
0191:  MOVF   5A,W
0192:  MOVWF  63
0193:  BSF    63.7
0194:  MOVF   5B,W
0195:  MOVWF  62
0196:  MOVF   5C,W
0197:  MOVWF  61
0198:  MOVLW  19
0199:  MOVWF  65
019A:  MOVF   60,W
019B:  SUBWF  61,F
019C:  BTFSC  03.0
019D:  GOTO   1AE
019E:  MOVLW  01
019F:  SUBWF  62,F
01A0:  BTFSC  03.0
01A1:  GOTO   1AE
01A2:  SUBWF  63,F
01A3:  BTFSC  03.0
01A4:  GOTO   1AE
01A5:  SUBWF  64,F
01A6:  BTFSC  03.0
01A7:  GOTO   1AE
01A8:  INCF   64,F
01A9:  INCF   63,F
01AA:  INCF   62,F
01AB:  MOVF   60,W
01AC:  ADDWF  61,F
01AD:  GOTO   1E0
01AE:  MOVF   5F,W
01AF:  SUBWF  62,F
01B0:  BTFSC  03.0
01B1:  GOTO   1C9
01B2:  MOVLW  01
01B3:  SUBWF  63,F
01B4:  BTFSC  03.0
01B5:  GOTO   1C9
01B6:  SUBWF  64,F
01B7:  BTFSC  03.0
01B8:  GOTO   1C9
01B9:  INCF   64,F
01BA:  INCF   63,F
01BB:  MOVF   5F,W
01BC:  ADDWF  62,F
01BD:  MOVF   60,W
01BE:  ADDWF  61,F
01BF:  BTFSS  03.0
01C0:  GOTO   1E0
01C1:  INCF   62,F
01C2:  BTFSS  03.2
01C3:  GOTO   1E0
01C4:  INCF   63,F
01C5:  BTFSS  03.2
01C6:  GOTO   1E0
01C7:  INCF   64,F
01C8:  GOTO   1E0
01C9:  MOVF   5E,W
01CA:  IORLW  80
01CB:  SUBWF  63,F
01CC:  BTFSC  03.0
01CD:  GOTO   1DF
01CE:  MOVLW  01
01CF:  SUBWF  64,F
01D0:  BTFSC  03.0
01D1:  GOTO   1DF
01D2:  INCF   64,F
01D3:  MOVF   5E,W
01D4:  IORLW  80
01D5:  ADDWF  63,F
01D6:  MOVF   5F,W
01D7:  ADDWF  62,F
01D8:  BTFSS  03.0
01D9:  GOTO   1BD
01DA:  INCF   63,F
01DB:  BTFSS  03.2
01DC:  GOTO   1BD
01DD:  INCF   64,F
01DE:  GOTO   1BD
01DF:  BSF    7A.0
01E0:  DECFSZ 65,F
01E1:  GOTO   1E3
01E2:  GOTO   1EE
01E3:  BCF    03.0
01E4:  RLF    61,F
01E5:  RLF    62,F
01E6:  RLF    63,F
01E7:  RLF    64,F
01E8:  BCF    03.0
01E9:  RLF    7A,F
01EA:  RLF    79,F
01EB:  RLF    78,F
01EC:  RLF    66,F
01ED:  GOTO   19A
01EE:  BTFSS  66.0
01EF:  GOTO   1F6
01F0:  BCF    03.0
01F1:  RRF    78,F
01F2:  RRF    79,F
01F3:  RRF    7A,F
01F4:  RRF    66,F
01F5:  GOTO   1F9
01F6:  DECF   77,F
01F7:  BTFSC  03.2
01F8:  GOTO   23B
01F9:  BTFSC  66.7
01FA:  GOTO   222
01FB:  BCF    03.0
01FC:  RLF    61,F
01FD:  RLF    62,F
01FE:  RLF    63,F
01FF:  RLF    64,F
0200:  MOVF   60,W
0201:  SUBWF  61,F
0202:  BTFSC  03.0
0203:  GOTO   20E
0204:  MOVLW  01
0205:  SUBWF  62,F
0206:  BTFSC  03.0
0207:  GOTO   20E
0208:  SUBWF  63,F
0209:  BTFSC  03.0
020A:  GOTO   20E
020B:  SUBWF  64,F
020C:  BTFSS  03.0
020D:  GOTO   231
020E:  MOVF   5F,W
020F:  SUBWF  62,F
0210:  BTFSC  03.0
0211:  GOTO   219
0212:  MOVLW  01
0213:  SUBWF  63,F
0214:  BTFSC  03.0
0215:  GOTO   219
0216:  SUBWF  64,F
0217:  BTFSS  03.0
0218:  GOTO   231
0219:  MOVF   5E,W
021A:  IORLW  80
021B:  SUBWF  63,F
021C:  BTFSC  03.0
021D:  GOTO   222
021E:  MOVLW  01
021F:  SUBWF  64,F
0220:  BTFSS  03.0
0221:  GOTO   231
0222:  INCF   7A,F
0223:  BTFSS  03.2
0224:  GOTO   231
0225:  INCF   79,F
0226:  BTFSS  03.2
0227:  GOTO   231
0228:  INCF   78,F
0229:  BTFSS  03.2
022A:  GOTO   231
022B:  INCF   77,F
022C:  BTFSC  03.2
022D:  GOTO   23B
022E:  RRF    78,F
022F:  RRF    79,F
0230:  RRF    7A,F
0231:  MOVF   5A,W
0232:  MOVWF  65
0233:  MOVF   5E,W
0234:  XORWF  65,F
0235:  BTFSS  65.7
0236:  GOTO   239
0237:  BSF    78.7
0238:  GOTO   23F
0239:  BCF    78.7
023A:  GOTO   23F
023B:  CLRF   77
023C:  CLRF   78
023D:  CLRF   79
023E:  CLRF   7A
023F:  BCF    0A.3
0240:  BCF    0A.4
0241:  GOTO   35D (RETURN)
0242:  MOVF   5A,W
0243:  MOVWF  61
0244:  MOVF   5E,W
0245:  XORWF  61,F
0246:  BTFSS  61.7
0247:  GOTO   24D
0248:  BCF    03.2
0249:  BCF    03.0
024A:  BTFSC  5A.7
024B:  BSF    03.0
024C:  GOTO   280
024D:  MOVF   5A,W
024E:  MOVWF  61
024F:  MOVF   5D,W
0250:  MOVWF  62
0251:  MOVF   59,W
0252:  SUBWF  62,F
0253:  BTFSC  03.2
0254:  GOTO   25B
0255:  BTFSS  61.7
0256:  GOTO   280
0257:  MOVF   03,W
0258:  XORLW  01
0259:  MOVWF  03
025A:  GOTO   280
025B:  MOVF   5E,W
025C:  MOVWF  62
025D:  MOVF   5A,W
025E:  SUBWF  62,F
025F:  BTFSC  03.2
0260:  GOTO   267
0261:  BTFSS  61.7
0262:  GOTO   280
0263:  MOVF   03,W
0264:  XORLW  01
0265:  MOVWF  03
0266:  GOTO   280
0267:  MOVF   5F,W
0268:  MOVWF  62
0269:  MOVF   5B,W
026A:  SUBWF  62,F
026B:  BTFSC  03.2
026C:  GOTO   273
026D:  BTFSS  61.7
026E:  GOTO   280
026F:  MOVF   03,W
0270:  XORLW  01
0271:  MOVWF  03
0272:  GOTO   280
0273:  MOVF   60,W
0274:  MOVWF  62
0275:  MOVF   5C,W
0276:  SUBWF  62,F
0277:  BTFSC  03.2
0278:  GOTO   27F
0279:  BTFSS  61.7
027A:  GOTO   280
027B:  MOVF   03,W
027C:  XORLW  01
027D:  MOVWF  03
027E:  GOTO   280
027F:  BCF    03.0
0280:  RETURN
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=20000000) 
*
0004:  MOVLW  5A
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   017
000A:  MOVLW  06
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  7B
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  DECFSZ 00,F
0016:  GOTO   00A
0017:  RETURN
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
02A0:  BCF    03.5
02A1:  CLRF   20
02A2:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... float adc_value; 
.................... float Vsolar; 
.................... float Isolar; 
.................... float Psolar; 
.................... float PrevVsolar=0; 
.................... float PrevIsolar=0; 
.................... float PrevPsolar=0; 
.................... int pwm; 
.................... int pwm_start=10; 
.................... int pwm_min=6; 
.................... int pwm_max=14; 
.................... int delta=1; 
....................  
.................... void main() 
*
0281:  MOVF   03,W
0282:  ANDLW  1F
0283:  MOVWF  03
0284:  CLRF   39
0285:  CLRF   38
0286:  CLRF   37
0287:  CLRF   36
0288:  CLRF   3D
0289:  CLRF   3C
028A:  CLRF   3B
028B:  CLRF   3A
028C:  CLRF   41
028D:  CLRF   40
028E:  CLRF   3F
028F:  CLRF   3E
0290:  MOVLW  0A
0291:  MOVWF  43
0292:  MOVLW  06
0293:  MOVWF  44
0294:  MOVLW  0E
0295:  MOVWF  45
0296:  MOVLW  01
0297:  MOVWF  46
0298:  MOVLW  FF
0299:  MOVWF  47
029A:  BSF    03.5
029B:  BSF    1F.0
029C:  BSF    1F.1
029D:  BSF    1F.2
029E:  BCF    1F.3
029F:  BCF    03.7
.................... { 
....................  
.................... pwm=pwm_start; 
*
02A3:  MOVF   43,W
02A4:  MOVWF  42
....................  
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
02A5:  BSF    03.5
02A6:  BCF    1F.0
02A7:  BCF    1F.1
02A8:  BCF    1F.2
02A9:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_8); 
02AA:  BCF    03.5
02AB:  BSF    1F.6
02AC:  BCF    1F.7
02AD:  BSF    03.5
02AE:  BCF    1F.7
02AF:  BCF    03.5
02B0:  BSF    1F.0
....................  
.................... output_low(PIN_C1);           /* set CCP1 output low */ 
02B1:  BCF    47.1
02B2:  MOVF   47,W
02B3:  BSF    03.5
02B4:  MOVWF  07
02B5:  BCF    03.5
02B6:  BCF    07.1
....................  
.................... setup_ccp1(CCP_PWM);          /* setup pin CCP1 (RC2) to do PWM */ 
02B7:  BCF    47.2
02B8:  MOVF   47,W
02B9:  BSF    03.5
02BA:  MOVWF  07
02BB:  BCF    03.5
02BC:  BCF    07.2
02BD:  MOVLW  0C
02BE:  MOVWF  17
....................  
.................... setup_timer_2(T2_DIV_BY_1,19,1);  /* 50 KHZ */ 
02BF:  MOVLW  00
02C0:  MOVWF  78
02C1:  IORLW  04
02C2:  MOVWF  12
02C3:  MOVLW  13
02C4:  BSF    03.5
02C5:  MOVWF  12
....................  
.................... delay_ms(1000);          
02C6:  MOVLW  04
02C7:  BCF    03.5
02C8:  MOVWF  59
02C9:  MOVLW  FA
02CA:  MOVWF  5A
02CB:  CALL   004
02CC:  DECFSZ 59,F
02CD:  GOTO   2C9
.................... set_adc_channel(0);     /* select RA */ 
02CE:  MOVLW  00
02CF:  MOVWF  78
02D0:  MOVF   1F,W
02D1:  ANDLW  C7
02D2:  IORWF  78,W
02D3:  MOVWF  1F
.................... delay_ms(20);            /* wait to read ADC */ 
02D4:  MOVLW  14
02D5:  MOVWF  5A
02D6:  CALL   004
.................... Vsolar =read_adc();   /* Read the voltage input from ADC channel 0 */ 
02D7:  BSF    1F.2
02D8:  BTFSC  1F.2
02D9:  GOTO   2D8
02DA:  MOVF   1E,W
02DB:  CLRF   5A
02DC:  MOVWF  59
02DD:  CALL   018
02DE:  MOVF   7A,W
02DF:  MOVWF  2D
02E0:  MOVF   79,W
02E1:  MOVWF  2C
02E2:  MOVF   78,W
02E3:  MOVWF  2B
02E4:  MOVF   77,W
02E5:  MOVWF  2A
....................  
.................... set_adc_channel(1);           /* select RA1 */ 
02E6:  MOVLW  08
02E7:  MOVWF  78
02E8:  MOVF   1F,W
02E9:  ANDLW  C7
02EA:  IORWF  78,W
02EB:  MOVWF  1F
.................... delay_ms(20);                 /* wait to read ADC */ 
02EC:  MOVLW  14
02ED:  MOVWF  5A
02EE:  CALL   004
.................... Isolar =read_adc(); 
02EF:  BSF    1F.2
02F0:  BTFSC  1F.2
02F1:  GOTO   2F0
02F2:  MOVF   1E,W
02F3:  CLRF   5A
02F4:  MOVWF  59
02F5:  CALL   018
02F6:  MOVF   7A,W
02F7:  MOVWF  31
02F8:  MOVF   79,W
02F9:  MOVWF  30
02FA:  MOVF   78,W
02FB:  MOVWF  2F
02FC:  MOVF   77,W
02FD:  MOVWF  2E
....................  
.................... float delta_P=Psolar-PrevPsolar;  
.................... float delta_V=Vsolar-PrevVsolar;  
.................... float delta_I=Isolar-PrevIsolar; 
.................... float gradient=delta_P/delta_V;  
.................... int pwm; 
02FE:  BSF    03.1
02FF:  MOVF   35,W
0300:  MOVWF  5C
0301:  MOVF   34,W
0302:  MOVWF  5B
0303:  MOVF   33,W
0304:  MOVWF  5A
0305:  MOVF   32,W
0306:  MOVWF  59
0307:  MOVF   41,W
0308:  MOVWF  60
0309:  MOVF   40,W
030A:  MOVWF  5F
030B:  MOVF   3F,W
030C:  MOVWF  5E
030D:  MOVF   3E,W
030E:  MOVWF  5D
030F:  CALL   035
0310:  MOVF   7A,W
0311:  MOVWF  4B
0312:  MOVF   79,W
0313:  MOVWF  4A
0314:  MOVF   78,W
0315:  MOVWF  49
0316:  MOVF   77,W
0317:  MOVWF  48
0318:  BSF    03.1
0319:  MOVF   2D,W
031A:  MOVWF  5C
031B:  MOVF   2C,W
031C:  MOVWF  5B
031D:  MOVF   2B,W
031E:  MOVWF  5A
031F:  MOVF   2A,W
0320:  MOVWF  59
0321:  MOVF   39,W
0322:  MOVWF  60
0323:  MOVF   38,W
0324:  MOVWF  5F
0325:  MOVF   37,W
0326:  MOVWF  5E
0327:  MOVF   36,W
0328:  MOVWF  5D
0329:  CALL   035
032A:  MOVF   7A,W
032B:  MOVWF  4F
032C:  MOVF   79,W
032D:  MOVWF  4E
032E:  MOVF   78,W
032F:  MOVWF  4D
0330:  MOVF   77,W
0331:  MOVWF  4C
0332:  BSF    03.1
0333:  MOVF   31,W
0334:  MOVWF  5C
0335:  MOVF   30,W
0336:  MOVWF  5B
0337:  MOVF   2F,W
0338:  MOVWF  5A
0339:  MOVF   2E,W
033A:  MOVWF  59
033B:  MOVF   3D,W
033C:  MOVWF  60
033D:  MOVF   3C,W
033E:  MOVWF  5F
033F:  MOVF   3B,W
0340:  MOVWF  5E
0341:  MOVF   3A,W
0342:  MOVWF  5D
0343:  CALL   035
0344:  MOVF   7A,W
0345:  MOVWF  53
0346:  MOVF   79,W
0347:  MOVWF  52
0348:  MOVF   78,W
0349:  MOVWF  51
034A:  MOVF   77,W
034B:  MOVWF  50
034C:  MOVF   4B,W
034D:  MOVWF  5C
034E:  MOVF   4A,W
034F:  MOVWF  5B
0350:  MOVF   49,W
0351:  MOVWF  5A
0352:  MOVF   48,W
0353:  MOVWF  59
0354:  MOVF   4F,W
0355:  MOVWF  60
0356:  MOVF   4E,W
0357:  MOVWF  5F
0358:  MOVF   4D,W
0359:  MOVWF  5E
035A:  MOVF   4C,W
035B:  MOVWF  5D
035C:  GOTO   176
035D:  MOVF   7A,W
035E:  MOVWF  57
035F:  MOVF   79,W
0360:  MOVWF  56
0361:  MOVF   78,W
0362:  MOVWF  55
0363:  MOVF   77,W
0364:  MOVWF  54
....................  
.................... if(delta_V!=0) 
0365:  MOVF   4F,W
0366:  MOVWF  5C
0367:  MOVF   4E,W
0368:  MOVWF  5B
0369:  MOVF   4D,W
036A:  MOVWF  5A
036B:  MOVF   4C,W
036C:  MOVWF  59
036D:  CLRF   60
036E:  CLRF   5F
036F:  CLRF   5E
0370:  CLRF   5D
0371:  CALL   242
0372:  BTFSC  03.2
0373:  GOTO   49B
.................... {  
.................... if(gradient>0) 
0374:  CLRF   5C
0375:  CLRF   5B
0376:  CLRF   5A
0377:  CLRF   59
0378:  MOVF   57,W
0379:  MOVWF  60
037A:  MOVF   56,W
037B:  MOVWF  5F
037C:  MOVF   55,W
037D:  MOVWF  5E
037E:  MOVF   54,W
037F:  MOVWF  5D
0380:  CALL   242
0381:  BTFSS  03.0
0382:  GOTO   3BE
.................... {  
.................... pwm+=delta;  
0383:  MOVF   46,W
0384:  ADDWF  58,F
.................... PrevPsolar=Psolar; 
0385:  MOVF   35,W
0386:  MOVWF  41
0387:  MOVF   34,W
0388:  MOVWF  40
0389:  MOVF   33,W
038A:  MOVWF  3F
038B:  MOVF   32,W
038C:  MOVWF  3E
.................... PrevVsolar=Vsolar;  
038D:  MOVF   2D,W
038E:  MOVWF  39
038F:  MOVF   2C,W
0390:  MOVWF  38
0391:  MOVF   2B,W
0392:  MOVWF  37
0393:  MOVF   2A,W
0394:  MOVWF  36
.................... PrevIsolar=Isolar;  
0395:  MOVF   31,W
0396:  MOVWF  3D
0397:  MOVF   30,W
0398:  MOVWF  3C
0399:  MOVF   2F,W
039A:  MOVWF  3B
039B:  MOVF   2E,W
039C:  MOVWF  3A
.................... if (pwm<pwm_min) 
039D:  MOVF   44,W
039E:  SUBWF  58,W
039F:  BTFSC  03.0
03A0:  GOTO   3A6
.................... { 
.................... pwm=pwm_min; 
03A1:  MOVF   44,W
03A2:  MOVWF  58
.................... set_pwm1_duty(pwm); 
03A3:  MOVF   58,W
03A4:  MOVWF  15
.................... } 
03A5:  GOTO   3BD
.................... else if (pwm>pwm_max || pwm==pwm_max) 
03A6:  MOVF   58,W
03A7:  SUBWF  45,W
03A8:  BTFSS  03.0
03A9:  GOTO   3AE
03AA:  MOVF   45,W
03AB:  SUBWF  58,W
03AC:  BTFSS  03.2
03AD:  GOTO   3B3
.................... { 
.................... pwm=pwm_max; 
03AE:  MOVF   45,W
03AF:  MOVWF  58
.................... set_pwm1_duty(pwm); 
03B0:  MOVF   58,W
03B1:  MOVWF  15
.................... } 
03B2:  GOTO   3BD
.................... else if (pwm<pwm_max && pwm>pwm_min) 
03B3:  MOVF   45,W
03B4:  SUBWF  58,W
03B5:  BTFSC  03.0
03B6:  GOTO   3BD
03B7:  MOVF   58,W
03B8:  SUBWF  44,W
03B9:  BTFSC  03.0
03BA:  GOTO   3BD
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
03BB:  MOVF   58,W
03BC:  MOVWF  15
.................... } 
.................... } 
03BD:  GOTO   49B
.................... else if(gradient<0) 
03BE:  MOVF   57,W
03BF:  MOVWF  5C
03C0:  MOVF   56,W
03C1:  MOVWF  5B
03C2:  MOVF   55,W
03C3:  MOVWF  5A
03C4:  MOVF   54,W
03C5:  MOVWF  59
03C6:  CLRF   60
03C7:  CLRF   5F
03C8:  CLRF   5E
03C9:  CLRF   5D
03CA:  CALL   242
03CB:  BTFSS  03.0
03CC:  GOTO   408
.................... {  
.................... pwm-=delta;  
03CD:  MOVF   46,W
03CE:  SUBWF  58,F
.................... PrevPsolar=Psolar;  
03CF:  MOVF   35,W
03D0:  MOVWF  41
03D1:  MOVF   34,W
03D2:  MOVWF  40
03D3:  MOVF   33,W
03D4:  MOVWF  3F
03D5:  MOVF   32,W
03D6:  MOVWF  3E
.................... PrevVsolar=Vsolar;  
03D7:  MOVF   2D,W
03D8:  MOVWF  39
03D9:  MOVF   2C,W
03DA:  MOVWF  38
03DB:  MOVF   2B,W
03DC:  MOVWF  37
03DD:  MOVF   2A,W
03DE:  MOVWF  36
.................... PrevIsolar=Isolar;  
03DF:  MOVF   31,W
03E0:  MOVWF  3D
03E1:  MOVF   30,W
03E2:  MOVWF  3C
03E3:  MOVF   2F,W
03E4:  MOVWF  3B
03E5:  MOVF   2E,W
03E6:  MOVWF  3A
.................... if (pwm<pwm_min) 
03E7:  MOVF   44,W
03E8:  SUBWF  58,W
03E9:  BTFSC  03.0
03EA:  GOTO   3F0
.................... { 
.................... pwm=pwm_min; 
03EB:  MOVF   44,W
03EC:  MOVWF  58
.................... set_pwm1_duty(pwm); 
03ED:  MOVF   58,W
03EE:  MOVWF  15
.................... } 
03EF:  GOTO   407
.................... else if (pwm>pwm_max || pwm==pwm_max) 
03F0:  MOVF   58,W
03F1:  SUBWF  45,W
03F2:  BTFSS  03.0
03F3:  GOTO   3F8
03F4:  MOVF   45,W
03F5:  SUBWF  58,W
03F6:  BTFSS  03.2
03F7:  GOTO   3FD
.................... { 
.................... pwm=pwm_max; 
03F8:  MOVF   45,W
03F9:  MOVWF  58
.................... set_pwm1_duty(pwm); 
03FA:  MOVF   58,W
03FB:  MOVWF  15
.................... } 
03FC:  GOTO   407
.................... else if (pwm<pwm_max && pwm>pwm_min) 
03FD:  MOVF   45,W
03FE:  SUBWF  58,W
03FF:  BTFSC  03.0
0400:  GOTO   407
0401:  MOVF   58,W
0402:  SUBWF  44,W
0403:  BTFSC  03.0
0404:  GOTO   407
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0405:  MOVF   58,W
0406:  MOVWF  15
.................... } 
.................... }  
0407:  GOTO   49B
....................  
.................... else  
.................... { 
.................... if(delta_I>0) 
0408:  CLRF   5C
0409:  CLRF   5B
040A:  CLRF   5A
040B:  CLRF   59
040C:  MOVF   53,W
040D:  MOVWF  60
040E:  MOVF   52,W
040F:  MOVWF  5F
0410:  MOVF   51,W
0411:  MOVWF  5E
0412:  MOVF   50,W
0413:  MOVWF  5D
0414:  CALL   242
0415:  BTFSS  03.0
0416:  GOTO   452
.................... {  
.................... pwm+=delta;  
0417:  MOVF   46,W
0418:  ADDWF  58,F
.................... PrevPsolar=Psolar;  
0419:  MOVF   35,W
041A:  MOVWF  41
041B:  MOVF   34,W
041C:  MOVWF  40
041D:  MOVF   33,W
041E:  MOVWF  3F
041F:  MOVF   32,W
0420:  MOVWF  3E
.................... PrevVsolar=Vsolar;  
0421:  MOVF   2D,W
0422:  MOVWF  39
0423:  MOVF   2C,W
0424:  MOVWF  38
0425:  MOVF   2B,W
0426:  MOVWF  37
0427:  MOVF   2A,W
0428:  MOVWF  36
.................... PrevIsolar=Isolar; 
0429:  MOVF   31,W
042A:  MOVWF  3D
042B:  MOVF   30,W
042C:  MOVWF  3C
042D:  MOVF   2F,W
042E:  MOVWF  3B
042F:  MOVF   2E,W
0430:  MOVWF  3A
.................... if (pwm<pwm_min) 
0431:  MOVF   44,W
0432:  SUBWF  58,W
0433:  BTFSC  03.0
0434:  GOTO   43A
.................... { 
.................... pwm=pwm_min; 
0435:  MOVF   44,W
0436:  MOVWF  58
.................... set_pwm1_duty(pwm); 
0437:  MOVF   58,W
0438:  MOVWF  15
.................... } 
0439:  GOTO   451
.................... else if (pwm>pwm_max || pwm==pwm_max) 
043A:  MOVF   58,W
043B:  SUBWF  45,W
043C:  BTFSS  03.0
043D:  GOTO   442
043E:  MOVF   45,W
043F:  SUBWF  58,W
0440:  BTFSS  03.2
0441:  GOTO   447
.................... { 
.................... pwm=pwm_max; 
0442:  MOVF   45,W
0443:  MOVWF  58
.................... set_pwm1_duty(pwm); 
0444:  MOVF   58,W
0445:  MOVWF  15
.................... } 
0446:  GOTO   451
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0447:  MOVF   45,W
0448:  SUBWF  58,W
0449:  BTFSC  03.0
044A:  GOTO   451
044B:  MOVF   58,W
044C:  SUBWF  44,W
044D:  BTFSC  03.0
044E:  GOTO   451
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
044F:  MOVF   58,W
0450:  MOVWF  15
.................... } 
.................... } 
0451:  GOTO   49B
....................  
.................... else if(delta_I<0) 
0452:  MOVF   53,W
0453:  MOVWF  5C
0454:  MOVF   52,W
0455:  MOVWF  5B
0456:  MOVF   51,W
0457:  MOVWF  5A
0458:  MOVF   50,W
0459:  MOVWF  59
045A:  CLRF   60
045B:  CLRF   5F
045C:  CLRF   5E
045D:  CLRF   5D
045E:  CALL   242
045F:  BTFSS  03.0
0460:  GOTO   49B
.................... {  
.................... pwm-=delta;  
0461:  MOVF   46,W
0462:  SUBWF  58,F
.................... PrevPsolar=Psolar;  
0463:  MOVF   35,W
0464:  MOVWF  41
0465:  MOVF   34,W
0466:  MOVWF  40
0467:  MOVF   33,W
0468:  MOVWF  3F
0469:  MOVF   32,W
046A:  MOVWF  3E
.................... PrevVsolar=Vsolar;  
046B:  MOVF   2D,W
046C:  MOVWF  39
046D:  MOVF   2C,W
046E:  MOVWF  38
046F:  MOVF   2B,W
0470:  MOVWF  37
0471:  MOVF   2A,W
0472:  MOVWF  36
.................... PrevIsolar=Isolar; 
0473:  MOVF   31,W
0474:  MOVWF  3D
0475:  MOVF   30,W
0476:  MOVWF  3C
0477:  MOVF   2F,W
0478:  MOVWF  3B
0479:  MOVF   2E,W
047A:  MOVWF  3A
.................... if (pwm<pwm_min) 
047B:  MOVF   44,W
047C:  SUBWF  58,W
047D:  BTFSC  03.0
047E:  GOTO   484
.................... { 
.................... pwm=pwm_min; 
047F:  MOVF   44,W
0480:  MOVWF  58
.................... set_pwm1_duty(pwm); 
0481:  MOVF   58,W
0482:  MOVWF  15
.................... } 
0483:  GOTO   49B
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0484:  MOVF   58,W
0485:  SUBWF  45,W
0486:  BTFSS  03.0
0487:  GOTO   48C
0488:  MOVF   45,W
0489:  SUBWF  58,W
048A:  BTFSS  03.2
048B:  GOTO   491
.................... { 
.................... pwm=pwm_max; 
048C:  MOVF   45,W
048D:  MOVWF  58
.................... set_pwm1_duty(pwm); 
048E:  MOVF   58,W
048F:  MOVWF  15
.................... } 
0490:  GOTO   49B
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0491:  MOVF   45,W
0492:  SUBWF  58,W
0493:  BTFSC  03.0
0494:  GOTO   49B
0495:  MOVF   58,W
0496:  SUBWF  44,W
0497:  BTFSC  03.0
0498:  GOTO   49B
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0499:  MOVF   58,W
049A:  MOVWF  15
.................... } 
.................... } 
.................... } 
.................... } 
.................... } 
....................  
049B:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
