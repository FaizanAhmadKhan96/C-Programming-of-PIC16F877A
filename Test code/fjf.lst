CCS PCM C Compiler, Version 5.015, 5967               01-May-19 14:09

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\Test code\fjf.lst

               ROM used:   3356 words (41%)
                           Largest free fragment is 2048
               RAM used:   73 (20%) at main() level
                           117 (32%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include<16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  DATA 50,2B
0005:  DATA 20,23
0006:  DATA 65,32
0007:  DATA 20,00
0008:  DATA C3,37
0009:  DATA 6E,3B
000A:  DATA 65,39
000B:  DATA F3,34
000C:  DATA 6F,37
000D:  DATA A0,2B
000E:  DATA 69,3A
000F:  DATA 68,00
0010:  DATA 45,3C
0011:  DATA E9,39
0012:  DATA F4,34
0013:  DATA EE,33
0014:  DATA A0,2A
0015:  DATA D0,29
0016:  DATA 00,01
0017:  DATA CD,30
0018:  DATA E4,32
0019:  DATA 20,31
001A:  DATA 79,1D
001B:  DATA 00,01
001C:  DATA C6,30
001D:  DATA 69,3D
001E:  DATA 61,37
001F:  DATA AC,29
0020:  DATA E8,30
0021:  DATA EB,34
0022:  DATA 72,00
0023:  DATA CD,30
0024:  DATA E4,32
0025:  DATA 20,31
0026:  DATA 79,1D
0027:  DATA 00,01
0028:  DATA 41,37
0029:  DATA 64,10
002A:  DATA C8,30
002B:  DATA 6D,3D
002C:  DATA 61,00
002D:  DATA D6,27
002E:  DATA 4C,2A
002F:  DATA C1,23
0030:  DATA 45,1D
0031:  DATA 25,33
0032:  DATA 20,2B
0033:  DATA 00,00
0034:  DATA C3,2A
0035:  DATA 52,29
0036:  DATA 45,27
0037:  DATA 54,1D
0038:  DATA 25,33
0039:  DATA A0,20
003A:  DATA 00,01
003B:  DATA 49,27
003C:  DATA D0,2A
003D:  DATA 54,10
003E:  DATA D0,27
003F:  DATA D7,22
0040:  DATA 52,1D
0041:  DATA 00,01
0042:  DATA D6,27
0043:  DATA 4C,2A
0044:  DATA C1,23
0045:  DATA 45,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 56,00
0049:  DATA C3,2A
004A:  DATA 52,29
004B:  DATA 45,27
004C:  DATA 54,1D
004D:  DATA A0,12
004E:  DATA 66,10
004F:  DATA 41,00
0050:  DATA CF,2A
0051:  DATA 54,28
0052:  DATA 55,2A
0053:  DATA 20,28
0054:  DATA CF,2B
0055:  DATA 45,29
0056:  DATA 3A,00
*
00B5:  MOVF   0B,W
00B6:  MOVWF  72
00B7:  BCF    0B.7
00B8:  BSF    03.5
00B9:  BSF    03.6
00BA:  BSF    0C.7
00BB:  BSF    0C.0
00BC:  NOP
00BD:  NOP
00BE:  BTFSS  72.7
00BF:  GOTO   0C5
00C0:  BCF    03.5
00C1:  BCF    03.6
00C2:  BSF    0B.7
00C3:  BSF    03.5
00C4:  BSF    03.6
00C5:  BCF    03.5
00C6:  MOVF   0C,W
00C7:  ANDLW  7F
00C8:  BTFSC  03.2
00C9:  GOTO   107
00CA:  MOVWF  72
00CB:  MOVF   0D,W
00CC:  MOVWF  73
00CD:  MOVF   0F,W
00CE:  MOVWF  74
00CF:  MOVF   72,W
00D0:  BSF    03.5
00D1:  BCF    03.6
00D2:  MOVWF  28
00D3:  BCF    03.5
00D4:  CALL   09E
00D5:  MOVF   73,W
00D6:  BSF    03.6
00D7:  MOVWF  0D
00D8:  MOVF   74,W
00D9:  MOVWF  0F
00DA:  BCF    03.6
00DB:  MOVF   0B,W
00DC:  MOVWF  75
00DD:  BCF    0B.7
00DE:  BSF    03.5
00DF:  BSF    03.6
00E0:  BSF    0C.7
00E1:  BSF    0C.0
00E2:  NOP
00E3:  NOP
00E4:  BTFSS  75.7
00E5:  GOTO   0EB
00E6:  BCF    03.5
00E7:  BCF    03.6
00E8:  BSF    0B.7
00E9:  BSF    03.5
00EA:  BSF    03.6
00EB:  BCF    03.5
00EC:  RLF    0C,W
00ED:  RLF    0E,W
00EE:  ANDLW  7F
00EF:  BTFSC  03.2
00F0:  GOTO   107
00F1:  MOVWF  72
00F2:  MOVF   0D,W
00F3:  MOVWF  73
00F4:  MOVF   0F,W
00F5:  MOVWF  74
00F6:  MOVF   72,W
00F7:  BSF    03.5
00F8:  BCF    03.6
00F9:  MOVWF  28
00FA:  BCF    03.5
00FB:  CALL   09E
00FC:  MOVF   73,W
00FD:  BSF    03.6
00FE:  MOVWF  0D
00FF:  MOVF   74,W
0100:  MOVWF  0F
0101:  INCF   0D,F
0102:  BTFSC  03.2
0103:  INCF   0F,F
0104:  BCF    03.6
0105:  GOTO   0B5
0106:  BSF    03.6
0107:  BCF    03.6
0108:  RETURN
*
0121:  MOVLW  8E
0122:  MOVWF  77
0123:  MOVF   73,W
0124:  MOVWF  78
0125:  MOVF   72,W
0126:  MOVWF  79
0127:  CLRF   7A
0128:  MOVF   78,F
0129:  BTFSS  03.2
012A:  GOTO   135
012B:  MOVF   79,W
012C:  MOVWF  78
012D:  CLRF   79
012E:  MOVLW  08
012F:  SUBWF  77,F
0130:  MOVF   78,F
0131:  BTFSS  03.2
0132:  GOTO   135
0133:  CLRF   77
0134:  GOTO   13D
0135:  BCF    03.0
0136:  BTFSC  78.7
0137:  GOTO   13C
0138:  RLF    79,F
0139:  RLF    78,F
013A:  DECF   77,F
013B:  GOTO   135
013C:  BCF    78.7
013D:  RETURN
013E:  BSF    03.5
013F:  MOVF   28,W
0140:  BTFSC  03.2
0141:  GOTO   1AF
0142:  MOVWF  30
0143:  MOVF   2C,W
0144:  BTFSC  03.2
0145:  GOTO   1AF
0146:  ADDWF  30,F
0147:  BTFSC  03.0
0148:  GOTO   150
0149:  MOVLW  7F
014A:  SUBWF  30,F
014B:  BTFSS  03.0
014C:  GOTO   1AF
014D:  BTFSC  03.2
014E:  GOTO   1AF
014F:  GOTO   154
0150:  MOVLW  81
0151:  ADDWF  30,F
0152:  BTFSC  03.0
0153:  GOTO   1AF
0154:  MOVF   30,W
0155:  MOVWF  77
0156:  CLRF   78
0157:  CLRF   79
0158:  CLRF   7A
0159:  MOVF   29,W
015A:  MOVWF  34
015B:  BSF    34.7
015C:  MOVF   2A,W
015D:  MOVWF  33
015E:  MOVF   2B,W
015F:  MOVWF  32
0160:  MOVLW  18
0161:  MOVWF  30
0162:  CLRF   31
0163:  BTFSS  32.0
0164:  GOTO   17D
0165:  MOVF   2F,W
0166:  ADDWF  7A,F
0167:  BTFSS  03.0
0168:  GOTO   16F
0169:  INCF   79,F
016A:  BTFSS  03.2
016B:  GOTO   16F
016C:  INCF   78,F
016D:  BTFSC  03.2
016E:  BSF    31.7
016F:  MOVF   2E,W
0170:  ADDWF  79,F
0171:  BTFSS  03.0
0172:  GOTO   176
0173:  INCF   78,F
0174:  BTFSC  03.2
0175:  BSF    31.7
0176:  MOVF   2D,W
0177:  MOVWF  2A
0178:  BSF    2A.7
0179:  MOVF   2A,W
017A:  ADDWF  78,F
017B:  BTFSC  03.0
017C:  BSF    31.7
017D:  RLF    31,F
017E:  RRF    78,F
017F:  RRF    79,F
0180:  RRF    7A,F
0181:  RRF    34,F
0182:  RRF    33,F
0183:  RRF    32,F
0184:  BCF    03.0
0185:  DECFSZ 30,F
0186:  GOTO   162
0187:  MOVLW  01
0188:  ADDWF  77,F
0189:  BTFSC  03.0
018A:  GOTO   1AF
018B:  BTFSC  78.7
018C:  GOTO   194
018D:  RLF    34,F
018E:  RLF    7A,F
018F:  RLF    79,F
0190:  RLF    78,F
0191:  DECF   77,F
0192:  BTFSC  03.2
0193:  GOTO   1AF
0194:  BTFSS  34.7
0195:  GOTO   1A5
0196:  INCF   7A,F
0197:  BTFSS  03.2
0198:  GOTO   1A5
0199:  INCF   79,F
019A:  BTFSS  03.2
019B:  GOTO   1A5
019C:  INCF   78,F
019D:  BTFSS  03.2
019E:  GOTO   1A5
019F:  RRF    78,F
01A0:  RRF    79,F
01A1:  RRF    7A,F
01A2:  INCF   77,F
01A3:  BTFSC  03.2
01A4:  GOTO   1AF
01A5:  MOVF   29,W
01A6:  MOVWF  31
01A7:  MOVF   2D,W
01A8:  XORWF  31,F
01A9:  BTFSS  31.7
01AA:  GOTO   1AD
01AB:  BSF    78.7
01AC:  GOTO   1B3
01AD:  BCF    78.7
01AE:  GOTO   1B3
01AF:  CLRF   77
01B0:  CLRF   78
01B1:  CLRF   79
01B2:  CLRF   7A
01B3:  BCF    03.5
01B4:  RETURN
01B5:  MOVF   7B,W
01B6:  BTFSC  03.2
01B7:  GOTO   287
01B8:  BSF    03.5
01B9:  MOVWF  28
01BA:  MOVF   20,W
01BB:  BTFSS  03.2
01BC:  GOTO   1BF
01BD:  BCF    03.5
01BE:  GOTO   287
01BF:  SUBWF  28,F
01C0:  BTFSS  03.0
01C1:  GOTO   1C9
01C2:  MOVLW  7F
01C3:  ADDWF  28,F
01C4:  BTFSS  03.0
01C5:  GOTO   1C8
01C6:  BCF    03.5
01C7:  GOTO   287
01C8:  GOTO   1D3
01C9:  MOVLW  81
01CA:  SUBWF  28,F
01CB:  BTFSC  03.0
01CC:  GOTO   1CF
01CD:  BCF    03.5
01CE:  GOTO   287
01CF:  BTFSS  03.2
01D0:  GOTO   1D3
01D1:  BCF    03.5
01D2:  GOTO   287
01D3:  MOVF   28,W
01D4:  MOVWF  77
01D5:  CLRF   78
01D6:  CLRF   79
01D7:  CLRF   7A
01D8:  CLRF   27
01D9:  MOVF   7C,W
01DA:  MOVWF  26
01DB:  BSF    26.7
01DC:  MOVF   7D,W
01DD:  MOVWF  25
01DE:  MOVF   7E,W
01DF:  MOVWF  24
01E0:  MOVLW  19
01E1:  MOVWF  28
01E2:  MOVF   23,W
01E3:  SUBWF  24,F
01E4:  BTFSC  03.0
01E5:  GOTO   1F6
01E6:  MOVLW  01
01E7:  SUBWF  25,F
01E8:  BTFSC  03.0
01E9:  GOTO   1F6
01EA:  SUBWF  26,F
01EB:  BTFSC  03.0
01EC:  GOTO   1F6
01ED:  SUBWF  27,F
01EE:  BTFSC  03.0
01EF:  GOTO   1F6
01F0:  INCF   27,F
01F1:  INCF   26,F
01F2:  INCF   25,F
01F3:  MOVF   23,W
01F4:  ADDWF  24,F
01F5:  GOTO   228
01F6:  MOVF   22,W
01F7:  SUBWF  25,F
01F8:  BTFSC  03.0
01F9:  GOTO   211
01FA:  MOVLW  01
01FB:  SUBWF  26,F
01FC:  BTFSC  03.0
01FD:  GOTO   211
01FE:  SUBWF  27,F
01FF:  BTFSC  03.0
0200:  GOTO   211
0201:  INCF   27,F
0202:  INCF   26,F
0203:  MOVF   22,W
0204:  ADDWF  25,F
0205:  MOVF   23,W
0206:  ADDWF  24,F
0207:  BTFSS  03.0
0208:  GOTO   228
0209:  INCF   25,F
020A:  BTFSS  03.2
020B:  GOTO   228
020C:  INCF   26,F
020D:  BTFSS  03.2
020E:  GOTO   228
020F:  INCF   27,F
0210:  GOTO   228
0211:  MOVF   21,W
0212:  IORLW  80
0213:  SUBWF  26,F
0214:  BTFSC  03.0
0215:  GOTO   227
0216:  MOVLW  01
0217:  SUBWF  27,F
0218:  BTFSC  03.0
0219:  GOTO   227
021A:  INCF   27,F
021B:  MOVF   21,W
021C:  IORLW  80
021D:  ADDWF  26,F
021E:  MOVF   22,W
021F:  ADDWF  25,F
0220:  BTFSS  03.0
0221:  GOTO   205
0222:  INCF   26,F
0223:  BTFSS  03.2
0224:  GOTO   205
0225:  INCF   27,F
0226:  GOTO   205
0227:  BSF    7A.0
0228:  DECFSZ 28,F
0229:  GOTO   22B
022A:  GOTO   236
022B:  BCF    03.0
022C:  RLF    24,F
022D:  RLF    25,F
022E:  RLF    26,F
022F:  RLF    27,F
0230:  BCF    03.0
0231:  RLF    7A,F
0232:  RLF    79,F
0233:  RLF    78,F
0234:  RLF    29,F
0235:  GOTO   1E2
0236:  BTFSS  29.0
0237:  GOTO   23E
0238:  BCF    03.0
0239:  RRF    78,F
023A:  RRF    79,F
023B:  RRF    7A,F
023C:  RRF    29,F
023D:  GOTO   242
023E:  DECFSZ 77,F
023F:  GOTO   242
0240:  BCF    03.5
0241:  GOTO   287
0242:  BTFSC  29.7
0243:  GOTO   26B
0244:  BCF    03.0
0245:  RLF    24,F
0246:  RLF    25,F
0247:  RLF    26,F
0248:  RLF    27,F
0249:  MOVF   23,W
024A:  SUBWF  24,F
024B:  BTFSC  03.0
024C:  GOTO   257
024D:  MOVLW  01
024E:  SUBWF  25,F
024F:  BTFSC  03.0
0250:  GOTO   257
0251:  SUBWF  26,F
0252:  BTFSC  03.0
0253:  GOTO   257
0254:  SUBWF  27,F
0255:  BTFSS  03.0
0256:  GOTO   27C
0257:  MOVF   22,W
0258:  SUBWF  25,F
0259:  BTFSC  03.0
025A:  GOTO   262
025B:  MOVLW  01
025C:  SUBWF  26,F
025D:  BTFSC  03.0
025E:  GOTO   262
025F:  SUBWF  27,F
0260:  BTFSS  03.0
0261:  GOTO   27C
0262:  MOVF   21,W
0263:  IORLW  80
0264:  SUBWF  26,F
0265:  BTFSC  03.0
0266:  GOTO   26B
0267:  MOVLW  01
0268:  SUBWF  27,F
0269:  BTFSS  03.0
026A:  GOTO   27C
026B:  INCF   7A,F
026C:  BTFSS  03.2
026D:  GOTO   27C
026E:  INCF   79,F
026F:  BTFSS  03.2
0270:  GOTO   27C
0271:  INCF   78,F
0272:  BTFSS  03.2
0273:  GOTO   27C
0274:  INCF   77,F
0275:  BTFSS  03.2
0276:  GOTO   279
0277:  BCF    03.5
0278:  GOTO   287
0279:  RRF    78,F
027A:  RRF    79,F
027B:  RRF    7A,F
027C:  MOVF   7C,W
027D:  MOVWF  28
027E:  MOVF   21,W
027F:  XORWF  28,F
0280:  BTFSS  28.7
0281:  GOTO   284
0282:  BSF    78.7
0283:  GOTO   28C
0284:  BCF    78.7
0285:  GOTO   28C
0286:  BCF    03.5
0287:  CLRF   77
0288:  CLRF   78
0289:  CLRF   79
028A:  CLRF   7A
028B:  BSF    03.5
028C:  BCF    03.5
028D:  RETURN
028E:  MOVLW  80
028F:  BTFSS  03.1
0290:  GOTO   294
0291:  BSF    03.5
0292:  XORWF  21,F
0293:  BCF    03.5
0294:  BSF    03.5
0295:  CLRF   26
0296:  CLRF   27
0297:  MOVF   7C,W
0298:  MOVWF  25
0299:  MOVF   21,W
029A:  XORWF  25,F
029B:  MOVF   7B,W
029C:  BTFSC  03.2
029D:  GOTO   382
029E:  MOVWF  24
029F:  MOVWF  77
02A0:  MOVF   20,W
02A1:  BTFSC  03.2
02A2:  GOTO   38B
02A3:  SUBWF  24,F
02A4:  BTFSC  03.2
02A5:  GOTO   327
02A6:  BTFSS  03.0
02A7:  GOTO   2E5
02A8:  MOVF   21,W
02A9:  MOVWF  2A
02AA:  BSF    2A.7
02AB:  MOVF   22,W
02AC:  MOVWF  29
02AD:  MOVF   23,W
02AE:  MOVWF  28
02AF:  CLRF   27
02B0:  BCF    03.0
02B1:  RRF    2A,F
02B2:  RRF    29,F
02B3:  RRF    28,F
02B4:  RRF    27,F
02B5:  DECFSZ 24,F
02B6:  GOTO   2AF
02B7:  BTFSS  25.7
02B8:  GOTO   2BC
02B9:  BSF    26.0
02BA:  GOTO   39F
02BB:  BCF    26.0
02BC:  BCF    24.0
02BD:  BSF    26.4
02BE:  MOVLW  7E
02BF:  MOVWF  04
02C0:  BCF    03.7
02C1:  GOTO   3B4
02C2:  BCF    26.4
02C3:  BTFSC  25.7
02C4:  GOTO   2CF
02C5:  BTFSS  24.0
02C6:  GOTO   2DA
02C7:  RRF    2A,F
02C8:  RRF    29,F
02C9:  RRF    28,F
02CA:  RRF    27,F
02CB:  INCF   77,F
02CC:  BTFSC  03.2
02CD:  GOTO   39A
02CE:  GOTO   2DA
02CF:  BTFSC  2A.7
02D0:  GOTO   2DD
02D1:  BCF    03.0
02D2:  RLF    27,F
02D3:  RLF    28,F
02D4:  RLF    29,F
02D5:  RLF    2A,F
02D6:  DECF   77,F
02D7:  BTFSC  03.2
02D8:  GOTO   39A
02D9:  GOTO   2CF
02DA:  BSF    26.6
02DB:  GOTO   347
02DC:  BCF    26.6
02DD:  MOVF   7C,W
02DE:  MOVWF  25
02DF:  BTFSS  25.7
02E0:  GOTO   2E3
02E1:  BSF    2A.7
02E2:  GOTO   393
02E3:  BCF    2A.7
02E4:  GOTO   393
02E5:  MOVF   20,W
02E6:  MOVWF  24
02E7:  MOVWF  77
02E8:  MOVF   7B,W
02E9:  SUBWF  24,F
02EA:  MOVF   7C,W
02EB:  MOVWF  2A
02EC:  BSF    2A.7
02ED:  MOVF   7D,W
02EE:  MOVWF  29
02EF:  MOVF   7E,W
02F0:  MOVWF  28
02F1:  CLRF   27
02F2:  BCF    03.0
02F3:  RRF    2A,F
02F4:  RRF    29,F
02F5:  RRF    28,F
02F6:  RRF    27,F
02F7:  DECFSZ 24,F
02F8:  GOTO   2F1
02F9:  BTFSS  25.7
02FA:  GOTO   2FE
02FB:  BSF    26.1
02FC:  GOTO   39F
02FD:  BCF    26.1
02FE:  BCF    24.0
02FF:  BSF    26.5
0300:  MOVLW  A3
0301:  MOVWF  04
0302:  BCF    03.7
0303:  GOTO   3B4
0304:  BCF    26.5
0305:  BTFSC  25.7
0306:  GOTO   311
0307:  BTFSS  24.0
0308:  GOTO   31C
0309:  RRF    2A,F
030A:  RRF    29,F
030B:  RRF    28,F
030C:  RRF    27,F
030D:  INCF   77,F
030E:  BTFSC  03.2
030F:  GOTO   39A
0310:  GOTO   31C
0311:  BTFSC  2A.7
0312:  GOTO   31F
0313:  BCF    03.0
0314:  RLF    27,F
0315:  RLF    28,F
0316:  RLF    29,F
0317:  RLF    2A,F
0318:  DECF   77,F
0319:  BTFSC  03.2
031A:  GOTO   39A
031B:  GOTO   311
031C:  BSF    26.7
031D:  GOTO   347
031E:  BCF    26.7
031F:  MOVF   21,W
0320:  MOVWF  25
0321:  BTFSS  25.7
0322:  GOTO   325
0323:  BSF    2A.7
0324:  GOTO   393
0325:  BCF    2A.7
0326:  GOTO   393
0327:  MOVF   21,W
0328:  MOVWF  2A
0329:  BSF    2A.7
032A:  MOVF   22,W
032B:  MOVWF  29
032C:  MOVF   23,W
032D:  MOVWF  28
032E:  BTFSS  25.7
032F:  GOTO   334
0330:  BCF    2A.7
0331:  BSF    26.2
0332:  GOTO   39F
0333:  BCF    26.2
0334:  CLRF   27
0335:  BCF    24.0
0336:  MOVLW  7E
0337:  MOVWF  04
0338:  BCF    03.7
0339:  GOTO   3B4
033A:  BTFSC  25.7
033B:  GOTO   35D
033C:  MOVF   7C,W
033D:  MOVWF  25
033E:  BTFSS  24.0
033F:  GOTO   347
0340:  RRF    2A,F
0341:  RRF    29,F
0342:  RRF    28,F
0343:  RRF    27,F
0344:  INCF   77,F
0345:  BTFSC  03.2
0346:  GOTO   39A
0347:  BTFSS  27.7
0348:  GOTO   358
0349:  INCF   28,F
034A:  BTFSS  03.2
034B:  GOTO   358
034C:  INCF   29,F
034D:  BTFSS  03.2
034E:  GOTO   358
034F:  INCF   2A,F
0350:  BTFSS  03.2
0351:  GOTO   358
0352:  RRF    2A,F
0353:  RRF    29,F
0354:  RRF    28,F
0355:  INCF   77,F
0356:  BTFSC  03.2
0357:  GOTO   39A
0358:  BTFSC  26.6
0359:  GOTO   2DC
035A:  BTFSC  26.7
035B:  GOTO   31E
035C:  GOTO   37C
035D:  MOVLW  80
035E:  XORWF  2A,F
035F:  BTFSS  2A.7
0360:  GOTO   365
0361:  GOTO   39F
0362:  MOVF   21,W
0363:  MOVWF  25
0364:  GOTO   372
0365:  MOVF   7C,W
0366:  MOVWF  25
0367:  MOVF   2A,F
0368:  BTFSS  03.2
0369:  GOTO   372
036A:  MOVF   29,F
036B:  BTFSS  03.2
036C:  GOTO   372
036D:  MOVF   28,F
036E:  BTFSS  03.2
036F:  GOTO   372
0370:  CLRF   77
0371:  GOTO   393
0372:  BTFSC  2A.7
0373:  GOTO   37C
0374:  BCF    03.0
0375:  RLF    27,F
0376:  RLF    28,F
0377:  RLF    29,F
0378:  RLF    2A,F
0379:  DECFSZ 77,F
037A:  GOTO   372
037B:  GOTO   39A
037C:  BTFSS  25.7
037D:  GOTO   380
037E:  BSF    2A.7
037F:  GOTO   393
0380:  BCF    2A.7
0381:  GOTO   393
0382:  MOVF   20,W
0383:  MOVWF  77
0384:  MOVF   21,W
0385:  MOVWF  2A
0386:  MOVF   22,W
0387:  MOVWF  29
0388:  MOVF   23,W
0389:  MOVWF  28
038A:  GOTO   393
038B:  MOVF   7B,W
038C:  MOVWF  77
038D:  MOVF   7C,W
038E:  MOVWF  2A
038F:  MOVF   7D,W
0390:  MOVWF  29
0391:  MOVF   7E,W
0392:  MOVWF  28
0393:  MOVF   2A,W
0394:  MOVWF  78
0395:  MOVF   29,W
0396:  MOVWF  79
0397:  MOVF   28,W
0398:  MOVWF  7A
0399:  GOTO   3D2
039A:  CLRF   77
039B:  CLRF   78
039C:  CLRF   79
039D:  CLRF   7A
039E:  GOTO   3D2
039F:  CLRF   27
03A0:  COMF   28,F
03A1:  COMF   29,F
03A2:  COMF   2A,F
03A3:  COMF   27,F
03A4:  INCF   27,F
03A5:  BTFSS  03.2
03A6:  GOTO   3AD
03A7:  INCF   28,F
03A8:  BTFSS  03.2
03A9:  GOTO   3AD
03AA:  INCF   29,F
03AB:  BTFSC  03.2
03AC:  INCF   2A,F
03AD:  BTFSC  26.0
03AE:  GOTO   2BB
03AF:  BTFSC  26.1
03B0:  GOTO   2FD
03B1:  BTFSC  26.2
03B2:  GOTO   333
03B3:  GOTO   362
03B4:  MOVF   00,W
03B5:  ADDWF  28,F
03B6:  BTFSS  03.0
03B7:  GOTO   3BE
03B8:  INCF   29,F
03B9:  BTFSS  03.2
03BA:  GOTO   3BE
03BB:  INCF   2A,F
03BC:  BTFSC  03.2
03BD:  BSF    24.0
03BE:  DECF   04,F
03BF:  MOVF   00,W
03C0:  ADDWF  29,F
03C1:  BTFSS  03.0
03C2:  GOTO   3C6
03C3:  INCF   2A,F
03C4:  BTFSC  03.2
03C5:  BSF    24.0
03C6:  DECF   04,F
03C7:  MOVF   00,W
03C8:  BTFSS  00.7
03C9:  XORLW  80
03CA:  ADDWF  2A,F
03CB:  BTFSC  03.0
03CC:  BSF    24.0
03CD:  BTFSC  26.4
03CE:  GOTO   2C2
03CF:  BTFSC  26.5
03D0:  GOTO   304
03D1:  GOTO   33A
03D2:  BCF    03.5
03D3:  RETURN
03D4:  MOVF   0B,W
03D5:  MOVWF  73
03D6:  BCF    0B.7
03D7:  BSF    03.5
03D8:  BSF    03.6
03D9:  BSF    0C.7
03DA:  BSF    0C.0
03DB:  NOP
03DC:  NOP
03DD:  BTFSS  73.7
03DE:  GOTO   3E4
03DF:  BCF    03.5
03E0:  BCF    03.6
03E1:  BSF    0B.7
03E2:  BSF    03.5
03E3:  BSF    03.6
03E4:  BTFSC  03.0
03E5:  GOTO   40D
03E6:  BCF    03.5
03E7:  MOVF   0C,W
03E8:  ANDLW  7F
03E9:  MOVWF  73
03EA:  MOVF   0D,W
03EB:  MOVWF  74
03EC:  MOVF   0F,W
03ED:  MOVWF  75
03EE:  MOVF   73,W
03EF:  BSF    03.5
03F0:  BCF    03.6
03F1:  MOVWF  28
03F2:  BCF    03.5
03F3:  CALL   09E
03F4:  MOVF   74,W
03F5:  BSF    03.6
03F6:  MOVWF  0D
03F7:  MOVF   75,W
03F8:  MOVWF  0F
03F9:  BCF    03.6
03FA:  MOVF   0B,W
03FB:  MOVWF  76
03FC:  BCF    0B.7
03FD:  BSF    03.5
03FE:  BSF    03.6
03FF:  BSF    0C.7
0400:  BSF    0C.0
0401:  NOP
0402:  NOP
0403:  BTFSS  76.7
0404:  GOTO   40A
0405:  BCF    03.5
0406:  BCF    03.6
0407:  BSF    0B.7
0408:  BSF    03.5
0409:  BSF    03.6
040A:  DECFSZ 72,F
040B:  GOTO   40D
040C:  GOTO   42B
040D:  BCF    03.5
040E:  RLF    0C,W
040F:  RLF    0E,W
0410:  ANDLW  7F
0411:  MOVWF  73
0412:  MOVF   0D,W
0413:  MOVWF  74
0414:  MOVF   0F,W
0415:  MOVWF  75
0416:  MOVF   73,W
0417:  BSF    03.5
0418:  BCF    03.6
0419:  MOVWF  28
041A:  BCF    03.5
041B:  CALL   09E
041C:  MOVF   74,W
041D:  BSF    03.6
041E:  MOVWF  0D
041F:  MOVF   75,W
0420:  MOVWF  0F
0421:  INCF   0D,F
0422:  BTFSC  03.2
0423:  INCF   0F,F
0424:  BCF    03.0
0425:  DECFSZ 72,F
0426:  GOTO   428
0427:  GOTO   42A
0428:  BCF    03.6
0429:  GOTO   3D4
042A:  BSF    03.5
042B:  BCF    03.5
042C:  BCF    03.6
042D:  RETURN
042E:  BTFSC  03.1
042F:  GOTO   433
0430:  MOVLW  B0
0431:  MOVWF  04
0432:  BCF    03.7
0433:  CLRF   77
0434:  CLRF   78
0435:  CLRF   79
0436:  CLRF   7A
0437:  BSF    03.5
0438:  CLRF   30
0439:  CLRF   31
043A:  CLRF   32
043B:  CLRF   33
043C:  MOVF   2F,W
043D:  IORWF  2E,W
043E:  IORWF  2D,W
043F:  IORWF  2C,W
0440:  BTFSC  03.2
0441:  GOTO   472
0442:  MOVLW  20
0443:  MOVWF  34
0444:  BCF    03.0
0445:  RLF    28,F
0446:  RLF    29,F
0447:  RLF    2A,F
0448:  RLF    2B,F
0449:  RLF    30,F
044A:  RLF    31,F
044B:  RLF    32,F
044C:  RLF    33,F
044D:  MOVF   2F,W
044E:  SUBWF  33,W
044F:  BTFSS  03.2
0450:  GOTO   45B
0451:  MOVF   2E,W
0452:  SUBWF  32,W
0453:  BTFSS  03.2
0454:  GOTO   45B
0455:  MOVF   2D,W
0456:  SUBWF  31,W
0457:  BTFSS  03.2
0458:  GOTO   45B
0459:  MOVF   2C,W
045A:  SUBWF  30,W
045B:  BTFSS  03.0
045C:  GOTO   46C
045D:  MOVF   2C,W
045E:  SUBWF  30,F
045F:  MOVF   2D,W
0460:  BTFSS  03.0
0461:  INCFSZ 2D,W
0462:  SUBWF  31,F
0463:  MOVF   2E,W
0464:  BTFSS  03.0
0465:  INCFSZ 2E,W
0466:  SUBWF  32,F
0467:  MOVF   2F,W
0468:  BTFSS  03.0
0469:  INCFSZ 2F,W
046A:  SUBWF  33,F
046B:  BSF    03.0
046C:  RLF    77,F
046D:  RLF    78,F
046E:  RLF    79,F
046F:  RLF    7A,F
0470:  DECFSZ 34,F
0471:  GOTO   444
0472:  MOVF   30,W
0473:  MOVWF  00
0474:  INCF   04,F
0475:  MOVF   31,W
0476:  MOVWF  00
0477:  INCF   04,F
0478:  MOVF   32,W
0479:  MOVWF  00
047A:  INCF   04,F
047B:  MOVF   33,W
047C:  MOVWF  00
047D:  BCF    03.5
047E:  RETURN
047F:  MOVF   04,W
0480:  BSF    03.5
0481:  MOVWF  20
0482:  MOVF   76,W
0483:  MOVWF  22
0484:  BTFSC  03.2
0485:  GOTO   4A1
0486:  MOVF   75,W
0487:  MOVWF  2B
0488:  MOVF   74,W
0489:  MOVWF  2A
048A:  MOVF   73,W
048B:  MOVWF  29
048C:  MOVF   72,W
048D:  MOVWF  28
048E:  CLRF   2F
048F:  CLRF   2E
0490:  MOVLW  20
0491:  MOVWF  2D
0492:  MOVLW  82
0493:  MOVWF  2C
0494:  BCF    03.5
0495:  CALL   13E
0496:  MOVF   7A,W
0497:  MOVWF  75
0498:  MOVF   79,W
0499:  MOVWF  74
049A:  MOVF   78,W
049B:  MOVWF  73
049C:  MOVF   77,W
049D:  MOVWF  72
049E:  BSF    03.5
049F:  DECFSZ 22,F
04A0:  GOTO   486
04A1:  MOVF   75,W
04A2:  MOVWF  2B
04A3:  MOVF   74,W
04A4:  MOVWF  2A
04A5:  MOVF   73,W
04A6:  MOVWF  29
04A7:  MOVF   72,W
04A8:  MOVWF  28
04A9:  MOVF   28,W
04AA:  SUBLW  B6
04AB:  MOVWF  28
04AC:  CLRF   7A
04AD:  MOVF   29,W
04AE:  MOVWF  2C
04AF:  BSF    29.7
04B0:  BCF    03.0
04B1:  RRF    29,F
04B2:  RRF    2A,F
04B3:  RRF    2B,F
04B4:  RRF    7A,F
04B5:  RRF    79,F
04B6:  RRF    78,F
04B7:  RRF    77,F
04B8:  DECFSZ 28,F
04B9:  GOTO   4B0
04BA:  BTFSS  2C.7
04BB:  GOTO   4C7
04BC:  COMF   77,F
04BD:  COMF   78,F
04BE:  COMF   79,F
04BF:  COMF   7A,F
04C0:  INCF   77,F
04C1:  BTFSC  03.2
04C2:  INCF   78,F
04C3:  BTFSC  03.2
04C4:  INCF   79,F
04C5:  BTFSC  03.2
04C6:  INCF   7A,F
04C7:  MOVF   7A,W
04C8:  MOVWF  75
04C9:  MOVF   79,W
04CA:  MOVWF  74
04CB:  MOVF   78,W
04CC:  MOVWF  73
04CD:  MOVF   77,W
04CE:  MOVWF  72
04CF:  BTFSS  75.7
04D0:  GOTO   4DE
04D1:  DECF   20,F
04D2:  BSF    20.5
04D3:  COMF   72,F
04D4:  COMF   73,F
04D5:  COMF   74,F
04D6:  COMF   75,F
04D7:  INCF   72,F
04D8:  BTFSC  03.2
04D9:  INCF   73,F
04DA:  BTFSC  03.2
04DB:  INCF   74,F
04DC:  BTFSC  03.2
04DD:  INCF   75,F
04DE:  MOVLW  3B
04DF:  MOVWF  27
04E0:  MOVLW  9A
04E1:  MOVWF  26
04E2:  MOVLW  CA
04E3:  MOVWF  25
04E4:  CLRF   24
04E5:  MOVLW  0A
04E6:  MOVWF  22
04E7:  MOVF   76,W
04E8:  BTFSC  03.2
04E9:  INCF   20,F
04EA:  BSF    03.1
04EB:  MOVLW  72
04EC:  MOVWF  04
04ED:  BCF    03.7
04EE:  MOVF   75,W
04EF:  MOVWF  2B
04F0:  MOVF   74,W
04F1:  MOVWF  2A
04F2:  MOVF   73,W
04F3:  MOVWF  29
04F4:  MOVF   72,W
04F5:  MOVWF  28
04F6:  MOVF   27,W
04F7:  MOVWF  2F
04F8:  MOVF   26,W
04F9:  MOVWF  2E
04FA:  MOVF   25,W
04FB:  MOVWF  2D
04FC:  MOVF   24,W
04FD:  MOVWF  2C
04FE:  BCF    03.5
04FF:  CALL   42E
0500:  MOVF   78,W
0501:  MOVF   77,F
0502:  BTFSS  03.2
0503:  GOTO   51B
0504:  INCF   76,W
0505:  BSF    03.5
0506:  SUBWF  22,W
0507:  BTFSS  03.2
0508:  GOTO   50B
0509:  BCF    03.5
050A:  GOTO   51B
050B:  MOVF   20,W
050C:  BTFSC  03.2
050D:  GOTO   51E
050E:  ANDLW  0F
050F:  SUBWF  22,W
0510:  BTFSC  03.2
0511:  GOTO   514
0512:  BTFSC  03.0
0513:  GOTO   556
0514:  BTFSC  20.7
0515:  GOTO   556
0516:  BTFSC  20.6
0517:  GOTO   51E
0518:  MOVLW  20
0519:  GOTO   550
051A:  BCF    03.5
051B:  MOVLW  20
051C:  BSF    03.5
051D:  ANDWF  20,F
051E:  BTFSS  20.5
051F:  GOTO   52E
0520:  BCF    20.5
0521:  MOVF   76,W
0522:  BTFSS  03.2
0523:  DECF   20,F
0524:  MOVF   77,W
0525:  MOVWF  20
0526:  MOVLW  2D
0527:  MOVWF  28
0528:  BCF    03.5
0529:  CALL   09E
052A:  BSF    03.5
052B:  MOVF   20,W
052C:  MOVWF  77
052D:  CLRF   20
052E:  MOVF   76,W
052F:  SUBWF  22,W
0530:  BTFSS  03.2
0531:  GOTO   53E
0532:  MOVF   77,W
0533:  MOVWF  20
0534:  MOVLW  2E
0535:  MOVWF  28
0536:  BCF    03.5
0537:  CALL   09E
0538:  BSF    03.5
0539:  MOVF   20,W
053A:  MOVWF  77
053B:  MOVLW  20
053C:  ANDWF  20,F
053D:  MOVLW  00
053E:  MOVLW  30
053F:  BTFSS  20.5
0540:  GOTO   550
0541:  BCF    20.5
0542:  MOVF   76,W
0543:  BTFSS  03.2
0544:  DECF   20,F
0545:  MOVF   77,W
0546:  MOVWF  20
0547:  MOVLW  2D
0548:  MOVWF  28
0549:  BCF    03.5
054A:  CALL   09E
054B:  BSF    03.5
054C:  MOVF   20,W
054D:  MOVWF  77
054E:  CLRF   20
054F:  MOVLW  30
0550:  ADDWF  77,F
0551:  MOVF   77,W
0552:  MOVWF  28
0553:  BCF    03.5
0554:  CALL   09E
0555:  BSF    03.5
0556:  BCF    03.1
0557:  MOVF   27,W
0558:  MOVWF  2B
0559:  MOVF   26,W
055A:  MOVWF  2A
055B:  MOVF   25,W
055C:  MOVWF  29
055D:  MOVF   24,W
055E:  MOVWF  28
055F:  CLRF   2F
0560:  CLRF   2E
0561:  CLRF   2D
0562:  MOVLW  0A
0563:  MOVWF  2C
0564:  BCF    03.5
0565:  CALL   42E
0566:  MOVF   7A,W
0567:  BSF    03.5
0568:  MOVWF  27
0569:  MOVF   79,W
056A:  MOVWF  26
056B:  MOVF   78,W
056C:  MOVWF  25
056D:  MOVF   77,W
056E:  MOVWF  24
056F:  DECFSZ 22,F
0570:  GOTO   4EA
0571:  BCF    03.5
0572:  RETURN
0573:  MOVF   73,W
0574:  BSF    03.5
0575:  MOVWF  20
0576:  MOVF   7C,W
0577:  XORWF  20,F
0578:  BTFSS  20.7
0579:  GOTO   57F
057A:  BCF    03.2
057B:  BCF    03.0
057C:  BTFSC  73.7
057D:  BSF    03.0
057E:  GOTO   5B2
057F:  MOVF   73,W
0580:  MOVWF  20
0581:  MOVF   7B,W
0582:  MOVWF  21
0583:  MOVF   72,W
0584:  SUBWF  21,F
0585:  BTFSC  03.2
0586:  GOTO   58D
0587:  BTFSS  20.7
0588:  GOTO   5B2
0589:  MOVF   03,W
058A:  XORLW  01
058B:  MOVWF  03
058C:  GOTO   5B2
058D:  MOVF   7C,W
058E:  MOVWF  21
058F:  MOVF   73,W
0590:  SUBWF  21,F
0591:  BTFSC  03.2
0592:  GOTO   599
0593:  BTFSS  20.7
0594:  GOTO   5B2
0595:  MOVF   03,W
0596:  XORLW  01
0597:  MOVWF  03
0598:  GOTO   5B2
0599:  MOVF   7D,W
059A:  MOVWF  21
059B:  MOVF   74,W
059C:  SUBWF  21,F
059D:  BTFSC  03.2
059E:  GOTO   5A5
059F:  BTFSS  20.7
05A0:  GOTO   5B2
05A1:  MOVF   03,W
05A2:  XORLW  01
05A3:  MOVWF  03
05A4:  GOTO   5B2
05A5:  MOVF   7E,W
05A6:  MOVWF  21
05A7:  MOVF   75,W
05A8:  SUBWF  21,F
05A9:  BTFSC  03.2
05AA:  GOTO   5B1
05AB:  BTFSS  20.7
05AC:  GOTO   5B2
05AD:  MOVF   03,W
05AE:  XORLW  01
05AF:  MOVWF  03
05B0:  GOTO   5B2
05B1:  BCF    03.0
05B2:  BCF    03.5
05B3:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,BROWNOUT,NOWDT,NOLVP 
.................... #use delay(clock=20M) 
*
0057:  MOVLW  75
0058:  MOVWF  04
0059:  BCF    03.7
005A:  MOVF   00,W
005B:  BTFSC  03.2
005C:  GOTO   06A
005D:  MOVLW  06
005E:  MOVWF  78
005F:  CLRF   77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  DECFSZ 78,F
0063:  GOTO   05F
0064:  MOVLW  7B
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 00,F
0069:  GOTO   05D
006A:  RETURN
.................... #endif 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
081F:  BCF    03.5
0820:  CLRF   20
0821:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #define lcd_rs pin_d0 
.................... #define lcd_en pin_d1 
.................... #define sd pin_c0 
.................... #define on output_high 
.................... #define off output_low 
.................... #define fan pin_d7 
.................... #define relay pin_d6 
.................... #define green pin_d5 
.................... #define yellow2 pin_d4 
.................... #define yellow1 pin_c7 
.................... #define red pin_c6 
.................... #define WAPDA pin_d3 
.................... #define solar pin_d2 
.................... #define disp_clear 0b00000001 
.................... #define disp_control 0b00001110 
.................... #define func_set 0b00111000 
.................... #define lscrol 0b00011000 
.................... #define rscrol 0b00011100 
.................... #define line1 0b10000000 
.................... #define line2 0b11000000 
.................... float PrevVsolar=0,PrevIsolar=0,PrevPsolar=0,adc_value,Vsolar,Vbattery; 
.................... float Isolar,Ibattery,Pin,Pout,delta_V,delta_P,delta_I; 
.................... int pwm,pwm_start=40,pwm_min=35,pwm_max=49,delta=1; 
.................... void lcd_init (void); 
.................... void lcd_data (unsigned char); 
.................... void lcd_cmd (unsigned char); 
.................... void lcd_lscrol (unsigned char); 
.................... void lcd_rscrol (unsigned char); 
.................... void lcd_line1 (unsigned char); 
.................... void lcd_line2 (unsigned char); 
.................... void lcd_init (void) 
.................... { 
.................... delay_ms(300); 
*
0082:  MOVLW  02
0083:  MOVWF  72
0084:  MOVLW  96
0085:  MOVWF  75
0086:  CALL   057
0087:  DECFSZ 72,F
0088:  GOTO   084
.................... lcd_cmd (func_set); 
0089:  MOVLW  38
008A:  MOVWF  74
008B:  CALL   06B
.................... lcd_cmd (disp_control); 
008C:  MOVLW  0E
008D:  MOVWF  74
008E:  CALL   06B
.................... lcd_cmd(disp_clear); 
008F:  MOVLW  01
0090:  MOVWF  74
0091:  CALL   06B
....................  delay_ms(50); 
0092:  MOVLW  32
0093:  MOVWF  75
0094:  CALL   057
0095:  BSF    0A.3
0096:  BCF    0A.4
0097:  GOTO   026 (RETURN)
.................... } 
.................... void lcd_cmd (unsigned char i) 
.................... { 
.................... output_low(lcd_rs); 
*
006B:  BSF    03.5
006C:  BCF    08.0
006D:  BCF    03.5
006E:  BCF    08.0
.................... output_b(i); 
006F:  BSF    03.5
0070:  CLRF   06
0071:  MOVF   74,W
0072:  BCF    03.5
0073:  MOVWF  06
.................... output_high(lcd_en); 
0074:  BSF    03.5
0075:  BCF    08.1
0076:  BCF    03.5
0077:  BSF    08.1
.................... delay_us(100); 
0078:  MOVLW  A6
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  NOP
.................... output_low(lcd_en); 
007D:  BSF    03.5
007E:  BCF    08.1
007F:  BCF    03.5
0080:  BCF    08.1
0081:  RETURN
.................... } 
.................... void lcd_data (unsigned char i) 
.................... { 
.................... output_high(lcd_rs); 
*
009E:  BSF    03.5
009F:  BCF    08.0
00A0:  BCF    03.5
00A1:  BSF    08.0
.................... output_b(i); 
00A2:  BSF    03.5
00A3:  CLRF   06
00A4:  MOVF   28,W
00A5:  BCF    03.5
00A6:  MOVWF  06
.................... output_high(lcd_en); 
00A7:  BSF    03.5
00A8:  BCF    08.1
00A9:  BCF    03.5
00AA:  BSF    08.1
.................... delay_us(100); 
00AB:  MOVLW  A6
00AC:  MOVWF  77
00AD:  DECFSZ 77,F
00AE:  GOTO   0AD
00AF:  NOP
.................... output_low(lcd_en); 
00B0:  BSF    03.5
00B1:  BCF    08.1
00B2:  BCF    03.5
00B3:  BCF    08.1
00B4:  RETURN
.................... } 
.................... void lcd_lscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
.................... { 
.................... lcd_cmd(lscrol); 
.................... delay_ms(300); 
.................... } 
.................... } 
.................... void lcd_rscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
*
010F:  CLRF   73
0110:  MOVF   72,W
0111:  SUBWF  73,W
0112:  BTFSC  03.0
0113:  GOTO   120
.................... { 
.................... lcd_cmd(rscrol); 
0114:  MOVLW  1C
0115:  MOVWF  74
0116:  CALL   06B
.................... delay_ms(300); 
0117:  MOVLW  02
0118:  MOVWF  74
0119:  MOVLW  96
011A:  MOVWF  75
011B:  CALL   057
011C:  DECFSZ 74,F
011D:  GOTO   119
011E:  INCF   73,F
011F:  GOTO   110
.................... } 
0120:  RETURN
.................... } 
.................... void lcd_line1 (unsigned char position) 
.................... { 
.................... lcd_cmd(line1 + position); 
*
0098:  MOVLW  80
0099:  ADDWF  72,W
009A:  MOVWF  73
009B:  MOVWF  74
009C:  CALL   06B
009D:  RETURN
.................... } 
.................... void lcd_line2 (unsigned char position) 
.................... { 
.................... lcd_cmd(line2 + position); 
*
0109:  MOVLW  C0
010A:  ADDWF  72,W
010B:  MOVWF  73
010C:  MOVWF  74
010D:  CALL   06B
010E:  RETURN
.................... } 
.................... void main(void) 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   29
0804:  CLRF   28
0805:  CLRF   27
0806:  CLRF   26
0807:  CLRF   2D
0808:  CLRF   2C
0809:  CLRF   2B
080A:  CLRF   2A
080B:  CLRF   31
080C:  CLRF   30
080D:  CLRF   2F
080E:  CLRF   2E
080F:  MOVLW  28
0810:  MOVWF  5B
0811:  MOVLW  23
0812:  MOVWF  5C
0813:  MOVLW  31
0814:  MOVWF  5D
0815:  MOVLW  01
0816:  MOVWF  5E
0817:  MOVLW  FF
0818:  MOVWF  5F
0819:  BSF    03.5
081A:  BSF    1F.0
081B:  BSF    1F.1
081C:  BSF    1F.2
081D:  BCF    1F.3
081E:  BCF    03.7
.................... { 
.................... pwm=pwm_start; 
*
0822:  MOVF   5B,W
0823:  MOVWF  5A
.................... lcd_init(); 
0824:  BCF    0A.3
0825:  GOTO   082
0826:  BSF    0A.3
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
0827:  BSF    03.5
0828:  BCF    1F.0
0829:  BCF    1F.1
082A:  BCF    1F.2
082B:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_8); 
082C:  BCF    03.5
082D:  BSF    1F.6
082E:  BCF    1F.7
082F:  BSF    03.5
0830:  BSF    1F.7
0831:  BCF    03.5
0832:  BSF    1F.0
.................... output_low(PIN_C1);            
0833:  BCF    5F.1
0834:  MOVF   5F,W
0835:  BSF    03.5
0836:  MOVWF  07
0837:  BCF    03.5
0838:  BCF    07.1
.................... setup_ccp1(CCP_PWM);        
0839:  BCF    5F.2
083A:  MOVF   5F,W
083B:  BSF    03.5
083C:  MOVWF  07
083D:  BCF    03.5
083E:  BCF    07.2
083F:  MOVLW  0C
0840:  MOVWF  17
.................... setup_timer_2(T2_DIV_BY_1,49,1); 
0841:  MOVLW  00
0842:  MOVWF  78
0843:  IORLW  04
0844:  MOVWF  12
0845:  MOVLW  31
0846:  BSF    03.5
0847:  MOVWF  12
.................... int i=0; 
0848:  BCF    03.5
0849:  CLRF   60
.................... do 
.................... { 
.................... lcd_line1 (3); 
084A:  MOVLW  03
084B:  MOVWF  72
084C:  BCF    0A.3
084D:  CALL   098
084E:  BSF    0A.3
.................... lcd_data ("PV Fed "); 
084F:  MOVLW  04
0850:  BSF    03.6
0851:  MOVWF  0D
0852:  MOVLW  00
0853:  MOVWF  0F
0854:  BCF    0A.3
0855:  BCF    03.6
0856:  CALL   0B5
0857:  BSF    0A.3
.................... lcd_line2 (0); 
0858:  CLRF   72
0859:  BCF    0A.3
085A:  CALL   109
085B:  BSF    0A.3
.................... lcd_data ("Conversion With"); 
085C:  MOVLW  08
085D:  BSF    03.6
085E:  MOVWF  0D
085F:  MOVLW  00
0860:  MOVWF  0F
0861:  BCF    0A.3
0862:  BCF    03.6
0863:  CALL   0B5
0864:  BSF    0A.3
.................... delay_ms(1000); 
0865:  MOVLW  04
0866:  MOVWF  72
0867:  MOVLW  FA
0868:  MOVWF  75
0869:  BCF    0A.3
086A:  CALL   057
086B:  BSF    0A.3
086C:  DECFSZ 72,F
086D:  GOTO   067
.................... lcd_rscrol(20); 
086E:  MOVLW  14
086F:  MOVWF  72
0870:  BCF    0A.3
0871:  CALL   10F
0872:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0873:  MOVLW  01
0874:  MOVWF  74
0875:  BCF    0A.3
0876:  CALL   06B
0877:  BSF    0A.3
....................  delay_ms(50); 
0878:  MOVLW  32
0879:  MOVWF  75
087A:  BCF    0A.3
087B:  CALL   057
087C:  BSF    0A.3
....................  lcd_line1 (0); 
087D:  CLRF   72
087E:  BCF    0A.3
087F:  CALL   098
0880:  BSF    0A.3
.................... lcd_data ("Existing UPS"); 
0881:  MOVLW  10
0882:  BSF    03.6
0883:  MOVWF  0D
0884:  MOVLW  00
0885:  MOVWF  0F
0886:  BCF    0A.3
0887:  BCF    03.6
0888:  CALL   0B5
0889:  BSF    0A.3
.................... delay_ms(1000); 
088A:  MOVLW  04
088B:  MOVWF  72
088C:  MOVLW  FA
088D:  MOVWF  75
088E:  BCF    0A.3
088F:  CALL   057
0890:  BSF    0A.3
0891:  DECFSZ 72,F
0892:  GOTO   08C
.................... lcd_rscrol(20); 
0893:  MOVLW  14
0894:  MOVWF  72
0895:  BCF    0A.3
0896:  CALL   10F
0897:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0898:  MOVLW  01
0899:  MOVWF  74
089A:  BCF    0A.3
089B:  CALL   06B
089C:  BSF    0A.3
....................  delay_ms(50); 
089D:  MOVLW  32
089E:  MOVWF  75
089F:  BCF    0A.3
08A0:  CALL   057
08A1:  BSF    0A.3
.................... lcd_line1 (3); 
08A2:  MOVLW  03
08A3:  MOVWF  72
08A4:  BCF    0A.3
08A5:  CALL   098
08A6:  BSF    0A.3
.................... lcd_data ("Made by:"); 
08A7:  MOVLW  17
08A8:  BSF    03.6
08A9:  MOVWF  0D
08AA:  MOVLW  00
08AB:  MOVWF  0F
08AC:  BCF    0A.3
08AD:  BCF    03.6
08AE:  CALL   0B5
08AF:  BSF    0A.3
.................... lcd_line2 (0); 
08B0:  CLRF   72
08B1:  BCF    0A.3
08B2:  CALL   109
08B3:  BSF    0A.3
.................... lcd_data ("Faizan,Shakir"); 
08B4:  MOVLW  1C
08B5:  BSF    03.6
08B6:  MOVWF  0D
08B7:  MOVLW  00
08B8:  MOVWF  0F
08B9:  BCF    0A.3
08BA:  BCF    03.6
08BB:  CALL   0B5
08BC:  BSF    0A.3
.................... delay_ms(1000); 
08BD:  MOVLW  04
08BE:  MOVWF  72
08BF:  MOVLW  FA
08C0:  MOVWF  75
08C1:  BCF    0A.3
08C2:  CALL   057
08C3:  BSF    0A.3
08C4:  DECFSZ 72,F
08C5:  GOTO   0BF
.................... lcd_rscrol(20); 
08C6:  MOVLW  14
08C7:  MOVWF  72
08C8:  BCF    0A.3
08C9:  CALL   10F
08CA:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
08CB:  MOVLW  01
08CC:  MOVWF  74
08CD:  BCF    0A.3
08CE:  CALL   06B
08CF:  BSF    0A.3
....................  delay_ms(50); 
08D0:  MOVLW  32
08D1:  MOVWF  75
08D2:  BCF    0A.3
08D3:  CALL   057
08D4:  BSF    0A.3
.................... lcd_line1 (3); 
08D5:  MOVLW  03
08D6:  MOVWF  72
08D7:  BCF    0A.3
08D8:  CALL   098
08D9:  BSF    0A.3
.................... lcd_data ("Made by:"); 
08DA:  MOVLW  23
08DB:  BSF    03.6
08DC:  MOVWF  0D
08DD:  MOVLW  00
08DE:  MOVWF  0F
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   0B5
08E2:  BSF    0A.3
.................... lcd_line2 (2); 
08E3:  MOVLW  02
08E4:  MOVWF  72
08E5:  BCF    0A.3
08E6:  CALL   109
08E7:  BSF    0A.3
.................... lcd_data ("And Hamza"); 
08E8:  MOVLW  28
08E9:  BSF    03.6
08EA:  MOVWF  0D
08EB:  MOVLW  00
08EC:  MOVWF  0F
08ED:  BCF    0A.3
08EE:  BCF    03.6
08EF:  CALL   0B5
08F0:  BSF    0A.3
.................... delay_ms(1000); 
08F1:  MOVLW  04
08F2:  MOVWF  72
08F3:  MOVLW  FA
08F4:  MOVWF  75
08F5:  BCF    0A.3
08F6:  CALL   057
08F7:  BSF    0A.3
08F8:  DECFSZ 72,F
08F9:  GOTO   0F3
.................... lcd_rscrol(20); 
08FA:  MOVLW  14
08FB:  MOVWF  72
08FC:  BCF    0A.3
08FD:  CALL   10F
08FE:  BSF    0A.3
.................... i++; 
08FF:  INCF   60,F
.................... } 
.................... while(i==0); 
0900:  MOVF   60,F
0901:  BTFSC  03.2
0902:  GOTO   04A
.................... lcd_cmd(disp_clear); 
0903:  MOVLW  01
0904:  MOVWF  74
0905:  BCF    0A.3
0906:  CALL   06B
0907:  BSF    0A.3
....................  delay_ms(50); 
0908:  MOVLW  32
0909:  MOVWF  75
090A:  BCF    0A.3
090B:  CALL   057
090C:  BSF    0A.3
.................... while(1) 
.................... { 
.................... on(relay); 
090D:  BSF    03.5
090E:  BCF    08.6
090F:  BCF    03.5
0910:  BSF    08.6
....................  on(sd); 
0911:  BCF    5F.0
0912:  MOVF   5F,W
0913:  BSF    03.5
0914:  MOVWF  07
0915:  BCF    03.5
0916:  BSF    07.0
....................  on(fan); 
0917:  BSF    03.5
0918:  BCF    08.7
0919:  BCF    03.5
091A:  BSF    08.7
....................  on(solar); 
091B:  BSF    03.5
091C:  BCF    08.2
091D:  BCF    03.5
091E:  BSF    08.2
.................... set_adc_channel(0); 
091F:  MOVLW  00
0920:  MOVWF  78
0921:  MOVF   1F,W
0922:  ANDLW  C7
0923:  IORWF  78,W
0924:  MOVWF  1F
.................... delay_us(100); 
0925:  MOVLW  A6
0926:  MOVWF  77
0927:  DECFSZ 77,F
0928:  GOTO   127
0929:  NOP
.................... adc_value = read_adc(); 
092A:  BSF    1F.2
092B:  BTFSC  1F.2
092C:  GOTO   12B
092D:  MOVF   1E,W
092E:  MOVWF  7A
092F:  BSF    03.5
0930:  MOVF   1E,W
0931:  MOVWF  72
0932:  MOVF   7A,W
0933:  MOVWF  73
0934:  BCF    0A.3
0935:  BCF    03.5
0936:  CALL   121
0937:  BSF    0A.3
0938:  MOVF   7A,W
0939:  MOVWF  35
093A:  MOVF   79,W
093B:  MOVWF  34
093C:  MOVF   78,W
093D:  MOVWF  33
093E:  MOVF   77,W
093F:  MOVWF  32
.................... Vsolar= (5.0*adc_value/1023.0)/0.167; 
0940:  BSF    03.5
0941:  CLRF   2B
0942:  CLRF   2A
0943:  MOVLW  20
0944:  MOVWF  29
0945:  MOVLW  81
0946:  MOVWF  28
0947:  BCF    03.5
0948:  MOVF   35,W
0949:  BSF    03.5
094A:  MOVWF  2F
094B:  BCF    03.5
094C:  MOVF   34,W
094D:  BSF    03.5
094E:  MOVWF  2E
094F:  BCF    03.5
0950:  MOVF   33,W
0951:  BSF    03.5
0952:  MOVWF  2D
0953:  BCF    03.5
0954:  MOVF   32,W
0955:  BSF    03.5
0956:  MOVWF  2C
0957:  BCF    0A.3
0958:  BCF    03.5
0959:  CALL   13E
095A:  BSF    0A.3
095B:  MOVF   7A,W
095C:  MOVWF  75
095D:  MOVF   79,W
095E:  MOVWF  74
095F:  MOVF   78,W
0960:  MOVWF  73
0961:  MOVF   77,W
0962:  MOVWF  72
0963:  MOVF   75,W
0964:  MOVWF  7E
0965:  MOVF   74,W
0966:  MOVWF  7D
0967:  MOVF   73,W
0968:  MOVWF  7C
0969:  MOVF   72,W
096A:  MOVWF  7B
096B:  BSF    03.5
096C:  CLRF   23
096D:  MOVLW  C0
096E:  MOVWF  22
096F:  MOVLW  7F
0970:  MOVWF  21
0971:  MOVLW  88
0972:  MOVWF  20
0973:  BCF    0A.3
0974:  BCF    03.5
0975:  CALL   1B5
0976:  BSF    0A.3
0977:  MOVF   7A,W
0978:  MOVWF  75
0979:  MOVF   79,W
097A:  MOVWF  74
097B:  MOVF   78,W
097C:  MOVWF  73
097D:  MOVF   77,W
097E:  MOVWF  72
097F:  MOVF   75,W
0980:  MOVWF  7E
0981:  MOVF   74,W
0982:  MOVWF  7D
0983:  MOVF   73,W
0984:  MOVWF  7C
0985:  MOVF   72,W
0986:  MOVWF  7B
0987:  MOVLW  0C
0988:  BSF    03.5
0989:  MOVWF  23
098A:  MOVLW  02
098B:  MOVWF  22
098C:  MOVLW  2B
098D:  MOVWF  21
098E:  MOVLW  7C
098F:  MOVWF  20
0990:  BCF    0A.3
0991:  BCF    03.5
0992:  CALL   1B5
0993:  BSF    0A.3
0994:  MOVF   7A,W
0995:  MOVWF  39
0996:  MOVF   79,W
0997:  MOVWF  38
0998:  MOVF   78,W
0999:  MOVWF  37
099A:  MOVF   77,W
099B:  MOVWF  36
....................  set_adc_channel(1); 
099C:  MOVLW  08
099D:  MOVWF  78
099E:  MOVF   1F,W
099F:  ANDLW  C7
09A0:  IORWF  78,W
09A1:  MOVWF  1F
.................... delay_ms(100); 
09A2:  MOVLW  64
09A3:  MOVWF  75
09A4:  BCF    0A.3
09A5:  CALL   057
09A6:  BSF    0A.3
.................... adc_value = read_adc(); 
09A7:  BSF    1F.2
09A8:  BTFSC  1F.2
09A9:  GOTO   1A8
09AA:  MOVF   1E,W
09AB:  MOVWF  7A
09AC:  BSF    03.5
09AD:  MOVF   1E,W
09AE:  MOVWF  72
09AF:  MOVF   7A,W
09B0:  MOVWF  73
09B1:  BCF    0A.3
09B2:  BCF    03.5
09B3:  CALL   121
09B4:  BSF    0A.3
09B5:  MOVF   7A,W
09B6:  MOVWF  35
09B7:  MOVF   79,W
09B8:  MOVWF  34
09B9:  MOVF   78,W
09BA:  MOVWF  33
09BB:  MOVF   77,W
09BC:  MOVWF  32
.................... Isolar= ((5.0/1023.0*adc_value)-2.47)/0.064; 
09BD:  MOVLW  0A
09BE:  BSF    03.5
09BF:  MOVWF  2B
09C0:  MOVLW  28
09C1:  MOVWF  2A
09C2:  MOVLW  20
09C3:  MOVWF  29
09C4:  MOVLW  77
09C5:  MOVWF  28
09C6:  BCF    03.5
09C7:  MOVF   35,W
09C8:  BSF    03.5
09C9:  MOVWF  2F
09CA:  BCF    03.5
09CB:  MOVF   34,W
09CC:  BSF    03.5
09CD:  MOVWF  2E
09CE:  BCF    03.5
09CF:  MOVF   33,W
09D0:  BSF    03.5
09D1:  MOVWF  2D
09D2:  BCF    03.5
09D3:  MOVF   32,W
09D4:  BSF    03.5
09D5:  MOVWF  2C
09D6:  BCF    0A.3
09D7:  BCF    03.5
09D8:  CALL   13E
09D9:  BSF    0A.3
09DA:  MOVF   7A,W
09DB:  MOVWF  75
09DC:  MOVF   79,W
09DD:  MOVWF  74
09DE:  MOVF   78,W
09DF:  MOVWF  73
09E0:  MOVF   77,W
09E1:  MOVWF  72
09E2:  BSF    03.1
09E3:  MOVF   75,W
09E4:  MOVWF  7E
09E5:  MOVF   74,W
09E6:  MOVWF  7D
09E7:  MOVF   73,W
09E8:  MOVWF  7C
09E9:  MOVF   72,W
09EA:  MOVWF  7B
09EB:  MOVLW  7B
09EC:  BSF    03.5
09ED:  MOVWF  23
09EE:  MOVLW  14
09EF:  MOVWF  22
09F0:  MOVLW  1E
09F1:  MOVWF  21
09F2:  MOVLW  80
09F3:  MOVWF  20
09F4:  BCF    0A.3
09F5:  BCF    03.5
09F6:  CALL   28E
09F7:  BSF    0A.3
09F8:  MOVF   7A,W
09F9:  MOVWF  75
09FA:  MOVF   79,W
09FB:  MOVWF  74
09FC:  MOVF   78,W
09FD:  MOVWF  73
09FE:  MOVF   77,W
09FF:  MOVWF  72
0A00:  MOVF   75,W
0A01:  MOVWF  7E
0A02:  MOVF   74,W
0A03:  MOVWF  7D
0A04:  MOVF   73,W
0A05:  MOVWF  7C
0A06:  MOVF   72,W
0A07:  MOVWF  7B
0A08:  MOVLW  6F
0A09:  BSF    03.5
0A0A:  MOVWF  23
0A0B:  MOVLW  12
0A0C:  MOVWF  22
0A0D:  MOVLW  03
0A0E:  MOVWF  21
0A0F:  MOVLW  7B
0A10:  MOVWF  20
0A11:  BCF    0A.3
0A12:  BCF    03.5
0A13:  CALL   1B5
0A14:  BSF    0A.3
0A15:  MOVF   7A,W
0A16:  MOVWF  41
0A17:  MOVF   79,W
0A18:  MOVWF  40
0A19:  MOVF   78,W
0A1A:  MOVWF  3F
0A1B:  MOVF   77,W
0A1C:  MOVWF  3E
.................... set_adc_channel(2); 
0A1D:  MOVLW  10
0A1E:  MOVWF  78
0A1F:  MOVF   1F,W
0A20:  ANDLW  C7
0A21:  IORWF  78,W
0A22:  MOVWF  1F
.................... delay_us(100); 
0A23:  MOVLW  A6
0A24:  MOVWF  77
0A25:  DECFSZ 77,F
0A26:  GOTO   225
0A27:  NOP
.................... adc_value = read_adc(); 
0A28:  BSF    1F.2
0A29:  BTFSC  1F.2
0A2A:  GOTO   229
0A2B:  MOVF   1E,W
0A2C:  MOVWF  7A
0A2D:  BSF    03.5
0A2E:  MOVF   1E,W
0A2F:  MOVWF  72
0A30:  MOVF   7A,W
0A31:  MOVWF  73
0A32:  BCF    0A.3
0A33:  BCF    03.5
0A34:  CALL   121
0A35:  BSF    0A.3
0A36:  MOVF   7A,W
0A37:  MOVWF  35
0A38:  MOVF   79,W
0A39:  MOVWF  34
0A3A:  MOVF   78,W
0A3B:  MOVWF  33
0A3C:  MOVF   77,W
0A3D:  MOVWF  32
.................... Vbattery= (5.0*adc_value/1023.0)/0.333; 
0A3E:  BSF    03.5
0A3F:  CLRF   2B
0A40:  CLRF   2A
0A41:  MOVLW  20
0A42:  MOVWF  29
0A43:  MOVLW  81
0A44:  MOVWF  28
0A45:  BCF    03.5
0A46:  MOVF   35,W
0A47:  BSF    03.5
0A48:  MOVWF  2F
0A49:  BCF    03.5
0A4A:  MOVF   34,W
0A4B:  BSF    03.5
0A4C:  MOVWF  2E
0A4D:  BCF    03.5
0A4E:  MOVF   33,W
0A4F:  BSF    03.5
0A50:  MOVWF  2D
0A51:  BCF    03.5
0A52:  MOVF   32,W
0A53:  BSF    03.5
0A54:  MOVWF  2C
0A55:  BCF    0A.3
0A56:  BCF    03.5
0A57:  CALL   13E
0A58:  BSF    0A.3
0A59:  MOVF   7A,W
0A5A:  MOVWF  75
0A5B:  MOVF   79,W
0A5C:  MOVWF  74
0A5D:  MOVF   78,W
0A5E:  MOVWF  73
0A5F:  MOVF   77,W
0A60:  MOVWF  72
0A61:  MOVF   75,W
0A62:  MOVWF  7E
0A63:  MOVF   74,W
0A64:  MOVWF  7D
0A65:  MOVF   73,W
0A66:  MOVWF  7C
0A67:  MOVF   72,W
0A68:  MOVWF  7B
0A69:  BSF    03.5
0A6A:  CLRF   23
0A6B:  MOVLW  C0
0A6C:  MOVWF  22
0A6D:  MOVLW  7F
0A6E:  MOVWF  21
0A6F:  MOVLW  88
0A70:  MOVWF  20
0A71:  BCF    0A.3
0A72:  BCF    03.5
0A73:  CALL   1B5
0A74:  BSF    0A.3
0A75:  MOVF   7A,W
0A76:  MOVWF  75
0A77:  MOVF   79,W
0A78:  MOVWF  74
0A79:  MOVF   78,W
0A7A:  MOVWF  73
0A7B:  MOVF   77,W
0A7C:  MOVWF  72
0A7D:  MOVF   75,W
0A7E:  MOVWF  7E
0A7F:  MOVF   74,W
0A80:  MOVWF  7D
0A81:  MOVF   73,W
0A82:  MOVWF  7C
0A83:  MOVF   72,W
0A84:  MOVWF  7B
0A85:  MOVLW  FA
0A86:  BSF    03.5
0A87:  MOVWF  23
0A88:  MOVLW  7E
0A89:  MOVWF  22
0A8A:  MOVLW  2A
0A8B:  MOVWF  21
0A8C:  MOVLW  7D
0A8D:  MOVWF  20
0A8E:  BCF    0A.3
0A8F:  BCF    03.5
0A90:  CALL   1B5
0A91:  BSF    0A.3
0A92:  MOVF   7A,W
0A93:  MOVWF  3D
0A94:  MOVF   79,W
0A95:  MOVWF  3C
0A96:  MOVF   78,W
0A97:  MOVWF  3B
0A98:  MOVF   77,W
0A99:  MOVWF  3A
....................  set_adc_channel(3); 
0A9A:  MOVLW  18
0A9B:  MOVWF  78
0A9C:  MOVF   1F,W
0A9D:  ANDLW  C7
0A9E:  IORWF  78,W
0A9F:  MOVWF  1F
.................... delay_ms(100); 
0AA0:  MOVLW  64
0AA1:  MOVWF  75
0AA2:  BCF    0A.3
0AA3:  CALL   057
0AA4:  BSF    0A.3
.................... adc_value = read_adc(); 
0AA5:  BSF    1F.2
0AA6:  BTFSC  1F.2
0AA7:  GOTO   2A6
0AA8:  MOVF   1E,W
0AA9:  MOVWF  7A
0AAA:  BSF    03.5
0AAB:  MOVF   1E,W
0AAC:  MOVWF  72
0AAD:  MOVF   7A,W
0AAE:  MOVWF  73
0AAF:  BCF    0A.3
0AB0:  BCF    03.5
0AB1:  CALL   121
0AB2:  BSF    0A.3
0AB3:  MOVF   7A,W
0AB4:  MOVWF  35
0AB5:  MOVF   79,W
0AB6:  MOVWF  34
0AB7:  MOVF   78,W
0AB8:  MOVWF  33
0AB9:  MOVF   77,W
0ABA:  MOVWF  32
.................... Ibattery= ((5.0/1023.0*adc_value)-2.47)/0.064; 
0ABB:  MOVLW  0A
0ABC:  BSF    03.5
0ABD:  MOVWF  2B
0ABE:  MOVLW  28
0ABF:  MOVWF  2A
0AC0:  MOVLW  20
0AC1:  MOVWF  29
0AC2:  MOVLW  77
0AC3:  MOVWF  28
0AC4:  BCF    03.5
0AC5:  MOVF   35,W
0AC6:  BSF    03.5
0AC7:  MOVWF  2F
0AC8:  BCF    03.5
0AC9:  MOVF   34,W
0ACA:  BSF    03.5
0ACB:  MOVWF  2E
0ACC:  BCF    03.5
0ACD:  MOVF   33,W
0ACE:  BSF    03.5
0ACF:  MOVWF  2D
0AD0:  BCF    03.5
0AD1:  MOVF   32,W
0AD2:  BSF    03.5
0AD3:  MOVWF  2C
0AD4:  BCF    0A.3
0AD5:  BCF    03.5
0AD6:  CALL   13E
0AD7:  BSF    0A.3
0AD8:  MOVF   7A,W
0AD9:  MOVWF  75
0ADA:  MOVF   79,W
0ADB:  MOVWF  74
0ADC:  MOVF   78,W
0ADD:  MOVWF  73
0ADE:  MOVF   77,W
0ADF:  MOVWF  72
0AE0:  BSF    03.1
0AE1:  MOVF   75,W
0AE2:  MOVWF  7E
0AE3:  MOVF   74,W
0AE4:  MOVWF  7D
0AE5:  MOVF   73,W
0AE6:  MOVWF  7C
0AE7:  MOVF   72,W
0AE8:  MOVWF  7B
0AE9:  MOVLW  7B
0AEA:  BSF    03.5
0AEB:  MOVWF  23
0AEC:  MOVLW  14
0AED:  MOVWF  22
0AEE:  MOVLW  1E
0AEF:  MOVWF  21
0AF0:  MOVLW  80
0AF1:  MOVWF  20
0AF2:  BCF    0A.3
0AF3:  BCF    03.5
0AF4:  CALL   28E
0AF5:  BSF    0A.3
0AF6:  MOVF   7A,W
0AF7:  MOVWF  75
0AF8:  MOVF   79,W
0AF9:  MOVWF  74
0AFA:  MOVF   78,W
0AFB:  MOVWF  73
0AFC:  MOVF   77,W
0AFD:  MOVWF  72
0AFE:  MOVF   75,W
0AFF:  MOVWF  7E
0B00:  MOVF   74,W
0B01:  MOVWF  7D
0B02:  MOVF   73,W
0B03:  MOVWF  7C
0B04:  MOVF   72,W
0B05:  MOVWF  7B
0B06:  MOVLW  6F
0B07:  BSF    03.5
0B08:  MOVWF  23
0B09:  MOVLW  12
0B0A:  MOVWF  22
0B0B:  MOVLW  03
0B0C:  MOVWF  21
0B0D:  MOVLW  7B
0B0E:  MOVWF  20
0B0F:  BCF    0A.3
0B10:  BCF    03.5
0B11:  CALL   1B5
0B12:  BSF    0A.3
0B13:  MOVF   7A,W
0B14:  MOVWF  45
0B15:  MOVF   79,W
0B16:  MOVWF  44
0B17:  MOVF   78,W
0B18:  MOVWF  43
0B19:  MOVF   77,W
0B1A:  MOVWF  42
....................  lcd_line1(0); 
0B1B:  CLRF   72
0B1C:  BCF    0A.3
0B1D:  CALL   098
0B1E:  BSF    0A.3
.................... printf(lcd_data,"VOLTAGE:%f V",Vsolar); 
0B1F:  MOVLW  2D
0B20:  BSF    03.6
0B21:  MOVWF  0D
0B22:  MOVLW  00
0B23:  MOVWF  0F
0B24:  BCF    03.0
0B25:  MOVLW  08
0B26:  MOVWF  72
0B27:  BCF    0A.3
0B28:  BCF    03.6
0B29:  CALL   3D4
0B2A:  BSF    0A.3
0B2B:  MOVLW  89
0B2C:  MOVWF  04
0B2D:  MOVF   39,W
0B2E:  MOVWF  75
0B2F:  MOVF   38,W
0B30:  MOVWF  74
0B31:  MOVF   37,W
0B32:  MOVWF  73
0B33:  MOVF   36,W
0B34:  MOVWF  72
0B35:  MOVLW  02
0B36:  MOVWF  76
0B37:  BCF    0A.3
0B38:  CALL   47F
0B39:  BSF    0A.3
0B3A:  MOVLW  20
0B3B:  BSF    03.5
0B3C:  MOVWF  28
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   09E
0B40:  BSF    0A.3
0B41:  MOVLW  56
0B42:  BSF    03.5
0B43:  MOVWF  28
0B44:  BCF    0A.3
0B45:  BCF    03.5
0B46:  CALL   09E
0B47:  BSF    0A.3
.................... delay_ms(1000); 
0B48:  MOVLW  04
0B49:  MOVWF  72
0B4A:  MOVLW  FA
0B4B:  MOVWF  75
0B4C:  BCF    0A.3
0B4D:  CALL   057
0B4E:  BSF    0A.3
0B4F:  DECFSZ 72,F
0B50:  GOTO   34A
.................... lcd_rscrol(20); 
0B51:  MOVLW  14
0B52:  MOVWF  72
0B53:  BCF    0A.3
0B54:  CALL   10F
0B55:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0B56:  MOVLW  01
0B57:  MOVWF  74
0B58:  BCF    0A.3
0B59:  CALL   06B
0B5A:  BSF    0A.3
....................  delay_ms(50); 
0B5B:  MOVLW  32
0B5C:  MOVWF  75
0B5D:  BCF    0A.3
0B5E:  CALL   057
0B5F:  BSF    0A.3
.................... lcd_line1(0); 
0B60:  CLRF   72
0B61:  BCF    0A.3
0B62:  CALL   098
0B63:  BSF    0A.3
....................  printf(lcd_data,"CURRENT:%f A",Isolar); 
0B64:  MOVLW  34
0B65:  BSF    03.6
0B66:  MOVWF  0D
0B67:  MOVLW  00
0B68:  MOVWF  0F
0B69:  BCF    03.0
0B6A:  MOVLW  08
0B6B:  MOVWF  72
0B6C:  BCF    0A.3
0B6D:  BCF    03.6
0B6E:  CALL   3D4
0B6F:  BSF    0A.3
0B70:  MOVLW  89
0B71:  MOVWF  04
0B72:  MOVF   41,W
0B73:  MOVWF  75
0B74:  MOVF   40,W
0B75:  MOVWF  74
0B76:  MOVF   3F,W
0B77:  MOVWF  73
0B78:  MOVF   3E,W
0B79:  MOVWF  72
0B7A:  MOVLW  02
0B7B:  MOVWF  76
0B7C:  BCF    0A.3
0B7D:  CALL   47F
0B7E:  BSF    0A.3
0B7F:  MOVLW  20
0B80:  BSF    03.5
0B81:  MOVWF  28
0B82:  BCF    0A.3
0B83:  BCF    03.5
0B84:  CALL   09E
0B85:  BSF    0A.3
0B86:  MOVLW  41
0B87:  BSF    03.5
0B88:  MOVWF  28
0B89:  BCF    0A.3
0B8A:  BCF    03.5
0B8B:  CALL   09E
0B8C:  BSF    0A.3
.................... delay_ms(1000); 
0B8D:  MOVLW  04
0B8E:  MOVWF  72
0B8F:  MOVLW  FA
0B90:  MOVWF  75
0B91:  BCF    0A.3
0B92:  CALL   057
0B93:  BSF    0A.3
0B94:  DECFSZ 72,F
0B95:  GOTO   38F
.................... lcd_rscrol(20); 
0B96:  MOVLW  14
0B97:  MOVWF  72
0B98:  BCF    0A.3
0B99:  CALL   10F
0B9A:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0B9B:  MOVLW  01
0B9C:  MOVWF  74
0B9D:  BCF    0A.3
0B9E:  CALL   06B
0B9F:  BSF    0A.3
....................  delay_ms(50); 
0BA0:  MOVLW  32
0BA1:  MOVWF  75
0BA2:  BCF    0A.3
0BA3:  CALL   057
0BA4:  BSF    0A.3
....................  Pin=Vsolar*Isolar; 
0BA5:  MOVF   39,W
0BA6:  BSF    03.5
0BA7:  MOVWF  2B
0BA8:  BCF    03.5
0BA9:  MOVF   38,W
0BAA:  BSF    03.5
0BAB:  MOVWF  2A
0BAC:  BCF    03.5
0BAD:  MOVF   37,W
0BAE:  BSF    03.5
0BAF:  MOVWF  29
0BB0:  BCF    03.5
0BB1:  MOVF   36,W
0BB2:  BSF    03.5
0BB3:  MOVWF  28
0BB4:  BCF    03.5
0BB5:  MOVF   41,W
0BB6:  BSF    03.5
0BB7:  MOVWF  2F
0BB8:  BCF    03.5
0BB9:  MOVF   40,W
0BBA:  BSF    03.5
0BBB:  MOVWF  2E
0BBC:  BCF    03.5
0BBD:  MOVF   3F,W
0BBE:  BSF    03.5
0BBF:  MOVWF  2D
0BC0:  BCF    03.5
0BC1:  MOVF   3E,W
0BC2:  BSF    03.5
0BC3:  MOVWF  2C
0BC4:  BCF    0A.3
0BC5:  BCF    03.5
0BC6:  CALL   13E
0BC7:  BSF    0A.3
0BC8:  MOVF   7A,W
0BC9:  MOVWF  49
0BCA:  MOVF   79,W
0BCB:  MOVWF  48
0BCC:  MOVF   78,W
0BCD:  MOVWF  47
0BCE:  MOVF   77,W
0BCF:  MOVWF  46
....................  lcd_line1(0); 
0BD0:  CLRF   72
0BD1:  BCF    0A.3
0BD2:  CALL   098
0BD3:  BSF    0A.3
....................  lcd_data("INPUT POWER:"); 
0BD4:  MOVLW  3B
0BD5:  BSF    03.6
0BD6:  MOVWF  0D
0BD7:  MOVLW  00
0BD8:  MOVWF  0F
0BD9:  BCF    0A.3
0BDA:  BCF    03.6
0BDB:  CALL   0B5
0BDC:  BSF    0A.3
....................  lcd_line2(3); 
0BDD:  MOVLW  03
0BDE:  MOVWF  72
0BDF:  BCF    0A.3
0BE0:  CALL   109
0BE1:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pin); 
0BE2:  MOVLW  89
0BE3:  MOVWF  04
0BE4:  MOVF   49,W
0BE5:  MOVWF  75
0BE6:  MOVF   48,W
0BE7:  MOVWF  74
0BE8:  MOVF   47,W
0BE9:  MOVWF  73
0BEA:  MOVF   46,W
0BEB:  MOVWF  72
0BEC:  MOVLW  02
0BED:  MOVWF  76
0BEE:  BCF    0A.3
0BEF:  CALL   47F
0BF0:  BSF    0A.3
0BF1:  MOVLW  20
0BF2:  BSF    03.5
0BF3:  MOVWF  28
0BF4:  BCF    0A.3
0BF5:  BCF    03.5
0BF6:  CALL   09E
0BF7:  BSF    0A.3
0BF8:  MOVLW  57
0BF9:  BSF    03.5
0BFA:  MOVWF  28
0BFB:  BCF    0A.3
0BFC:  BCF    03.5
0BFD:  CALL   09E
0BFE:  BSF    0A.3
.................... delay_ms(1000); 
0BFF:  MOVLW  04
0C00:  MOVWF  72
0C01:  MOVLW  FA
0C02:  MOVWF  75
0C03:  BCF    0A.3
0C04:  CALL   057
0C05:  BSF    0A.3
0C06:  DECFSZ 72,F
0C07:  GOTO   401
.................... lcd_rscrol(20); 
0C08:  MOVLW  14
0C09:  MOVWF  72
0C0A:  BCF    0A.3
0C0B:  CALL   10F
0C0C:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0C0D:  MOVLW  01
0C0E:  MOVWF  74
0C0F:  BCF    0A.3
0C10:  CALL   06B
0C11:  BSF    0A.3
....................  delay_ms(50); 
0C12:  MOVLW  32
0C13:  MOVWF  75
0C14:  BCF    0A.3
0C15:  CALL   057
0C16:  BSF    0A.3
.................... lcd_line1(0); 
0C17:  CLRF   72
0C18:  BCF    0A.3
0C19:  CALL   098
0C1A:  BSF    0A.3
.................... printf(lcd_data,"VOLTAGE: %f V",Vbattery); 
0C1B:  MOVLW  42
0C1C:  BSF    03.6
0C1D:  MOVWF  0D
0C1E:  MOVLW  00
0C1F:  MOVWF  0F
0C20:  BCF    03.0
0C21:  MOVLW  09
0C22:  MOVWF  72
0C23:  BCF    0A.3
0C24:  BCF    03.6
0C25:  CALL   3D4
0C26:  BSF    0A.3
0C27:  MOVLW  89
0C28:  MOVWF  04
0C29:  MOVF   3D,W
0C2A:  MOVWF  75
0C2B:  MOVF   3C,W
0C2C:  MOVWF  74
0C2D:  MOVF   3B,W
0C2E:  MOVWF  73
0C2F:  MOVF   3A,W
0C30:  MOVWF  72
0C31:  MOVLW  02
0C32:  MOVWF  76
0C33:  BCF    0A.3
0C34:  CALL   47F
0C35:  BSF    0A.3
0C36:  MOVLW  20
0C37:  BSF    03.5
0C38:  MOVWF  28
0C39:  BCF    0A.3
0C3A:  BCF    03.5
0C3B:  CALL   09E
0C3C:  BSF    0A.3
0C3D:  MOVLW  56
0C3E:  BSF    03.5
0C3F:  MOVWF  28
0C40:  BCF    0A.3
0C41:  BCF    03.5
0C42:  CALL   09E
0C43:  BSF    0A.3
.................... delay_ms(1000); 
0C44:  MOVLW  04
0C45:  MOVWF  72
0C46:  MOVLW  FA
0C47:  MOVWF  75
0C48:  BCF    0A.3
0C49:  CALL   057
0C4A:  BSF    0A.3
0C4B:  DECFSZ 72,F
0C4C:  GOTO   446
.................... lcd_rscrol(20); 
0C4D:  MOVLW  14
0C4E:  MOVWF  72
0C4F:  BCF    0A.3
0C50:  CALL   10F
0C51:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0C52:  MOVLW  01
0C53:  MOVWF  74
0C54:  BCF    0A.3
0C55:  CALL   06B
0C56:  BSF    0A.3
....................  delay_ms(50); 
0C57:  MOVLW  32
0C58:  MOVWF  75
0C59:  BCF    0A.3
0C5A:  CALL   057
0C5B:  BSF    0A.3
.................... lcd_line1(0); 
0C5C:  CLRF   72
0C5D:  BCF    0A.3
0C5E:  CALL   098
0C5F:  BSF    0A.3
.................... printf(lcd_data,"CURRENT: %f A",Ibattery); 
0C60:  MOVLW  49
0C61:  BSF    03.6
0C62:  MOVWF  0D
0C63:  MOVLW  00
0C64:  MOVWF  0F
0C65:  BCF    03.0
0C66:  MOVLW  09
0C67:  MOVWF  72
0C68:  BCF    0A.3
0C69:  BCF    03.6
0C6A:  CALL   3D4
0C6B:  BSF    0A.3
0C6C:  MOVLW  89
0C6D:  MOVWF  04
0C6E:  MOVF   45,W
0C6F:  MOVWF  75
0C70:  MOVF   44,W
0C71:  MOVWF  74
0C72:  MOVF   43,W
0C73:  MOVWF  73
0C74:  MOVF   42,W
0C75:  MOVWF  72
0C76:  MOVLW  02
0C77:  MOVWF  76
0C78:  BCF    0A.3
0C79:  CALL   47F
0C7A:  BSF    0A.3
0C7B:  MOVLW  20
0C7C:  BSF    03.5
0C7D:  MOVWF  28
0C7E:  BCF    0A.3
0C7F:  BCF    03.5
0C80:  CALL   09E
0C81:  BSF    0A.3
0C82:  MOVLW  41
0C83:  BSF    03.5
0C84:  MOVWF  28
0C85:  BCF    0A.3
0C86:  BCF    03.5
0C87:  CALL   09E
0C88:  BSF    0A.3
.................... delay_ms(1000); 
0C89:  MOVLW  04
0C8A:  MOVWF  72
0C8B:  MOVLW  FA
0C8C:  MOVWF  75
0C8D:  BCF    0A.3
0C8E:  CALL   057
0C8F:  BSF    0A.3
0C90:  DECFSZ 72,F
0C91:  GOTO   48B
.................... lcd_rscrol(20); 
0C92:  MOVLW  14
0C93:  MOVWF  72
0C94:  BCF    0A.3
0C95:  CALL   10F
0C96:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0C97:  MOVLW  01
0C98:  MOVWF  74
0C99:  BCF    0A.3
0C9A:  CALL   06B
0C9B:  BSF    0A.3
....................  delay_ms(50); 
0C9C:  MOVLW  32
0C9D:  MOVWF  75
0C9E:  BCF    0A.3
0C9F:  CALL   057
0CA0:  BSF    0A.3
....................   Pout=Vbattery*Ibattery; 
0CA1:  MOVF   3D,W
0CA2:  BSF    03.5
0CA3:  MOVWF  2B
0CA4:  BCF    03.5
0CA5:  MOVF   3C,W
0CA6:  BSF    03.5
0CA7:  MOVWF  2A
0CA8:  BCF    03.5
0CA9:  MOVF   3B,W
0CAA:  BSF    03.5
0CAB:  MOVWF  29
0CAC:  BCF    03.5
0CAD:  MOVF   3A,W
0CAE:  BSF    03.5
0CAF:  MOVWF  28
0CB0:  BCF    03.5
0CB1:  MOVF   45,W
0CB2:  BSF    03.5
0CB3:  MOVWF  2F
0CB4:  BCF    03.5
0CB5:  MOVF   44,W
0CB6:  BSF    03.5
0CB7:  MOVWF  2E
0CB8:  BCF    03.5
0CB9:  MOVF   43,W
0CBA:  BSF    03.5
0CBB:  MOVWF  2D
0CBC:  BCF    03.5
0CBD:  MOVF   42,W
0CBE:  BSF    03.5
0CBF:  MOVWF  2C
0CC0:  BCF    0A.3
0CC1:  BCF    03.5
0CC2:  CALL   13E
0CC3:  BSF    0A.3
0CC4:  MOVF   7A,W
0CC5:  MOVWF  4D
0CC6:  MOVF   79,W
0CC7:  MOVWF  4C
0CC8:  MOVF   78,W
0CC9:  MOVWF  4B
0CCA:  MOVF   77,W
0CCB:  MOVWF  4A
....................  lcd_line1(0); 
0CCC:  CLRF   72
0CCD:  BCF    0A.3
0CCE:  CALL   098
0CCF:  BSF    0A.3
....................  lcd_data("OUTPUT POWER:"); 
0CD0:  MOVLW  50
0CD1:  BSF    03.6
0CD2:  MOVWF  0D
0CD3:  MOVLW  00
0CD4:  MOVWF  0F
0CD5:  BCF    0A.3
0CD6:  BCF    03.6
0CD7:  CALL   0B5
0CD8:  BSF    0A.3
....................  lcd_line2(3); 
0CD9:  MOVLW  03
0CDA:  MOVWF  72
0CDB:  BCF    0A.3
0CDC:  CALL   109
0CDD:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pout); 
0CDE:  MOVLW  89
0CDF:  MOVWF  04
0CE0:  MOVF   4D,W
0CE1:  MOVWF  75
0CE2:  MOVF   4C,W
0CE3:  MOVWF  74
0CE4:  MOVF   4B,W
0CE5:  MOVWF  73
0CE6:  MOVF   4A,W
0CE7:  MOVWF  72
0CE8:  MOVLW  02
0CE9:  MOVWF  76
0CEA:  BCF    0A.3
0CEB:  CALL   47F
0CEC:  BSF    0A.3
0CED:  MOVLW  20
0CEE:  BSF    03.5
0CEF:  MOVWF  28
0CF0:  BCF    0A.3
0CF1:  BCF    03.5
0CF2:  CALL   09E
0CF3:  BSF    0A.3
0CF4:  MOVLW  57
0CF5:  BSF    03.5
0CF6:  MOVWF  28
0CF7:  BCF    0A.3
0CF8:  BCF    03.5
0CF9:  CALL   09E
0CFA:  BSF    0A.3
.................... delay_ms(1000); 
0CFB:  MOVLW  04
0CFC:  MOVWF  72
0CFD:  MOVLW  FA
0CFE:  MOVWF  75
0CFF:  BCF    0A.3
0D00:  CALL   057
0D01:  BSF    0A.3
0D02:  DECFSZ 72,F
0D03:  GOTO   4FD
.................... lcd_rscrol(20); 
0D04:  MOVLW  14
0D05:  MOVWF  72
0D06:  BCF    0A.3
0D07:  CALL   10F
0D08:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0D09:  MOVLW  01
0D0A:  MOVWF  74
0D0B:  BCF    0A.3
0D0C:  CALL   06B
0D0D:  BSF    0A.3
....................  delay_ms(50); 
0D0E:  MOVLW  32
0D0F:  MOVWF  75
0D10:  BCF    0A.3
0D11:  CALL   057
0D12:  BSF    0A.3
....................   if(Vbattery<11.8) 
0D13:  MOVF   3D,W
0D14:  MOVWF  75
0D15:  MOVF   3C,W
0D16:  MOVWF  74
0D17:  MOVF   3B,W
0D18:  MOVWF  73
0D19:  MOVF   3A,W
0D1A:  MOVWF  72
0D1B:  MOVLW  CD
0D1C:  MOVWF  7E
0D1D:  MOVLW  CC
0D1E:  MOVWF  7D
0D1F:  MOVLW  3C
0D20:  MOVWF  7C
0D21:  MOVLW  82
0D22:  MOVWF  7B
0D23:  BCF    0A.3
0D24:  CALL   573
0D25:  BSF    0A.3
0D26:  BTFSS  03.0
0D27:  GOTO   52E
....................  {on(red);} 
0D28:  BCF    5F.6
0D29:  MOVF   5F,W
0D2A:  BSF    03.5
0D2B:  MOVWF  07
0D2C:  BCF    03.5
0D2D:  BSF    07.6
....................  if(Vbattery<12.5) 
0D2E:  MOVF   3D,W
0D2F:  MOVWF  75
0D30:  MOVF   3C,W
0D31:  MOVWF  74
0D32:  MOVF   3B,W
0D33:  MOVWF  73
0D34:  MOVF   3A,W
0D35:  MOVWF  72
0D36:  CLRF   7E
0D37:  CLRF   7D
0D38:  MOVLW  48
0D39:  MOVWF  7C
0D3A:  MOVLW  82
0D3B:  MOVWF  7B
0D3C:  BCF    0A.3
0D3D:  CALL   573
0D3E:  BSF    0A.3
0D3F:  BTFSS  03.0
0D40:  GOTO   54D
....................  {on(red); 
0D41:  BCF    5F.6
0D42:  MOVF   5F,W
0D43:  BSF    03.5
0D44:  MOVWF  07
0D45:  BCF    03.5
0D46:  BSF    07.6
....................  on(yellow1);} 
0D47:  BCF    5F.7
0D48:  MOVF   5F,W
0D49:  BSF    03.5
0D4A:  MOVWF  07
0D4B:  BCF    03.5
0D4C:  BSF    07.7
....................  if(Vbattery<13) 
0D4D:  MOVF   3D,W
0D4E:  MOVWF  75
0D4F:  MOVF   3C,W
0D50:  MOVWF  74
0D51:  MOVF   3B,W
0D52:  MOVWF  73
0D53:  MOVF   3A,W
0D54:  MOVWF  72
0D55:  CLRF   7E
0D56:  CLRF   7D
0D57:  MOVLW  50
0D58:  MOVWF  7C
0D59:  MOVLW  82
0D5A:  MOVWF  7B
0D5B:  BCF    0A.3
0D5C:  CALL   573
0D5D:  BSF    0A.3
0D5E:  BTFSS  03.0
0D5F:  GOTO   570
....................  {on(red); 
0D60:  BCF    5F.6
0D61:  MOVF   5F,W
0D62:  BSF    03.5
0D63:  MOVWF  07
0D64:  BCF    03.5
0D65:  BSF    07.6
....................  on(yellow1); 
0D66:  BCF    5F.7
0D67:  MOVF   5F,W
0D68:  BSF    03.5
0D69:  MOVWF  07
0D6A:  BCF    03.5
0D6B:  BSF    07.7
....................  on(yellow2);} 
0D6C:  BSF    03.5
0D6D:  BCF    08.4
0D6E:  BCF    03.5
0D6F:  BSF    08.4
....................  if(Vbattery<13.5) 
0D70:  MOVF   3D,W
0D71:  MOVWF  75
0D72:  MOVF   3C,W
0D73:  MOVWF  74
0D74:  MOVF   3B,W
0D75:  MOVWF  73
0D76:  MOVF   3A,W
0D77:  MOVWF  72
0D78:  CLRF   7E
0D79:  CLRF   7D
0D7A:  MOVLW  58
0D7B:  MOVWF  7C
0D7C:  MOVLW  82
0D7D:  MOVWF  7B
0D7E:  BCF    0A.3
0D7F:  CALL   573
0D80:  BSF    0A.3
0D81:  BTFSS  03.0
0D82:  GOTO   597
....................  {on(red); 
0D83:  BCF    5F.6
0D84:  MOVF   5F,W
0D85:  BSF    03.5
0D86:  MOVWF  07
0D87:  BCF    03.5
0D88:  BSF    07.6
....................  on(yellow1); 
0D89:  BCF    5F.7
0D8A:  MOVF   5F,W
0D8B:  BSF    03.5
0D8C:  MOVWF  07
0D8D:  BCF    03.5
0D8E:  BSF    07.7
....................  on(yellow2); 
0D8F:  BSF    03.5
0D90:  BCF    08.4
0D91:  BCF    03.5
0D92:  BSF    08.4
....................  on(green);} 
0D93:  BSF    03.5
0D94:  BCF    08.5
0D95:  BCF    03.5
0D96:  BSF    08.5
....................  float delta_P=Pin-PrevPsolar,delta_V=Vsolar-PrevVsolar; 
....................  float delta_I=Isolar-PrevIsolar,gradient=delta_P/delta_V; 
.................... int pwm; 
0D97:  BSF    03.1
0D98:  MOVF   49,W
0D99:  MOVWF  7E
0D9A:  MOVF   48,W
0D9B:  MOVWF  7D
0D9C:  MOVF   47,W
0D9D:  MOVWF  7C
0D9E:  MOVF   46,W
0D9F:  MOVWF  7B
0DA0:  MOVF   31,W
0DA1:  BSF    03.5
0DA2:  MOVWF  23
0DA3:  BCF    03.5
0DA4:  MOVF   30,W
0DA5:  BSF    03.5
0DA6:  MOVWF  22
0DA7:  BCF    03.5
0DA8:  MOVF   2F,W
0DA9:  BSF    03.5
0DAA:  MOVWF  21
0DAB:  BCF    03.5
0DAC:  MOVF   2E,W
0DAD:  BSF    03.5
0DAE:  MOVWF  20
0DAF:  BCF    0A.3
0DB0:  BCF    03.5
0DB1:  CALL   28E
0DB2:  BSF    0A.3
0DB3:  MOVF   7A,W
0DB4:  MOVWF  64
0DB5:  MOVF   79,W
0DB6:  MOVWF  63
0DB7:  MOVF   78,W
0DB8:  MOVWF  62
0DB9:  MOVF   77,W
0DBA:  MOVWF  61
0DBB:  BSF    03.1
0DBC:  MOVF   39,W
0DBD:  MOVWF  7E
0DBE:  MOVF   38,W
0DBF:  MOVWF  7D
0DC0:  MOVF   37,W
0DC1:  MOVWF  7C
0DC2:  MOVF   36,W
0DC3:  MOVWF  7B
0DC4:  MOVF   29,W
0DC5:  BSF    03.5
0DC6:  MOVWF  23
0DC7:  BCF    03.5
0DC8:  MOVF   28,W
0DC9:  BSF    03.5
0DCA:  MOVWF  22
0DCB:  BCF    03.5
0DCC:  MOVF   27,W
0DCD:  BSF    03.5
0DCE:  MOVWF  21
0DCF:  BCF    03.5
0DD0:  MOVF   26,W
0DD1:  BSF    03.5
0DD2:  MOVWF  20
0DD3:  BCF    0A.3
0DD4:  BCF    03.5
0DD5:  CALL   28E
0DD6:  BSF    0A.3
0DD7:  MOVF   7A,W
0DD8:  MOVWF  68
0DD9:  MOVF   79,W
0DDA:  MOVWF  67
0DDB:  MOVF   78,W
0DDC:  MOVWF  66
0DDD:  MOVF   77,W
0DDE:  MOVWF  65
0DDF:  BSF    03.1
0DE0:  MOVF   41,W
0DE1:  MOVWF  7E
0DE2:  MOVF   40,W
0DE3:  MOVWF  7D
0DE4:  MOVF   3F,W
0DE5:  MOVWF  7C
0DE6:  MOVF   3E,W
0DE7:  MOVWF  7B
0DE8:  MOVF   2D,W
0DE9:  BSF    03.5
0DEA:  MOVWF  23
0DEB:  BCF    03.5
0DEC:  MOVF   2C,W
0DED:  BSF    03.5
0DEE:  MOVWF  22
0DEF:  BCF    03.5
0DF0:  MOVF   2B,W
0DF1:  BSF    03.5
0DF2:  MOVWF  21
0DF3:  BCF    03.5
0DF4:  MOVF   2A,W
0DF5:  BSF    03.5
0DF6:  MOVWF  20
0DF7:  BCF    0A.3
0DF8:  BCF    03.5
0DF9:  CALL   28E
0DFA:  BSF    0A.3
0DFB:  MOVF   7A,W
0DFC:  MOVWF  6C
0DFD:  MOVF   79,W
0DFE:  MOVWF  6B
0DFF:  MOVF   78,W
0E00:  MOVWF  6A
0E01:  MOVF   77,W
0E02:  MOVWF  69
0E03:  MOVF   64,W
0E04:  MOVWF  7E
0E05:  MOVF   63,W
0E06:  MOVWF  7D
0E07:  MOVF   62,W
0E08:  MOVWF  7C
0E09:  MOVF   61,W
0E0A:  MOVWF  7B
0E0B:  MOVF   68,W
0E0C:  BSF    03.5
0E0D:  MOVWF  23
0E0E:  BCF    03.5
0E0F:  MOVF   67,W
0E10:  BSF    03.5
0E11:  MOVWF  22
0E12:  BCF    03.5
0E13:  MOVF   66,W
0E14:  BSF    03.5
0E15:  MOVWF  21
0E16:  BCF    03.5
0E17:  MOVF   65,W
0E18:  BSF    03.5
0E19:  MOVWF  20
0E1A:  BCF    0A.3
0E1B:  BCF    03.5
0E1C:  CALL   1B5
0E1D:  BSF    0A.3
0E1E:  MOVF   7A,W
0E1F:  MOVWF  70
0E20:  MOVF   79,W
0E21:  MOVWF  6F
0E22:  MOVF   78,W
0E23:  MOVWF  6E
0E24:  MOVF   77,W
0E25:  MOVWF  6D
.................... if(delta_V!=0) 
0E26:  MOVF   68,W
0E27:  MOVWF  75
0E28:  MOVF   67,W
0E29:  MOVWF  74
0E2A:  MOVF   66,W
0E2B:  MOVWF  73
0E2C:  MOVF   65,W
0E2D:  MOVWF  72
0E2E:  CLRF   7E
0E2F:  CLRF   7D
0E30:  CLRF   7C
0E31:  CLRF   7B
0E32:  BCF    0A.3
0E33:  CALL   573
0E34:  BSF    0A.3
0E35:  BTFSC  03.2
0E36:  GOTO   766
.................... { if(gradient>0) 
0E37:  CLRF   75
0E38:  CLRF   74
0E39:  CLRF   73
0E3A:  CLRF   72
0E3B:  MOVF   70,W
0E3C:  MOVWF  7E
0E3D:  MOVF   6F,W
0E3E:  MOVWF  7D
0E3F:  MOVF   6E,W
0E40:  MOVWF  7C
0E41:  MOVF   6D,W
0E42:  MOVWF  7B
0E43:  BCF    0A.3
0E44:  CALL   573
0E45:  BSF    0A.3
0E46:  BTFSS  03.0
0E47:  GOTO   683
.................... { pwm+=delta; 
0E48:  MOVF   5E,W
0E49:  ADDWF  71,F
.................... PrevPsolar=Pin; 
0E4A:  MOVF   49,W
0E4B:  MOVWF  31
0E4C:  MOVF   48,W
0E4D:  MOVWF  30
0E4E:  MOVF   47,W
0E4F:  MOVWF  2F
0E50:  MOVF   46,W
0E51:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0E52:  MOVF   39,W
0E53:  MOVWF  29
0E54:  MOVF   38,W
0E55:  MOVWF  28
0E56:  MOVF   37,W
0E57:  MOVWF  27
0E58:  MOVF   36,W
0E59:  MOVWF  26
.................... PrevIsolar=Isolar;  
0E5A:  MOVF   41,W
0E5B:  MOVWF  2D
0E5C:  MOVF   40,W
0E5D:  MOVWF  2C
0E5E:  MOVF   3F,W
0E5F:  MOVWF  2B
0E60:  MOVF   3E,W
0E61:  MOVWF  2A
.................... if (pwm<pwm_min) 
0E62:  MOVF   5C,W
0E63:  SUBWF  71,W
0E64:  BTFSC  03.0
0E65:  GOTO   66B
.................... {pwm=pwm_min; 
0E66:  MOVF   5C,W
0E67:  MOVWF  71
.................... set_pwm1_duty(pwm);} 
0E68:  MOVF   71,W
0E69:  MOVWF  15
0E6A:  GOTO   682
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0E6B:  MOVF   71,W
0E6C:  SUBWF  5D,W
0E6D:  BTFSS  03.0
0E6E:  GOTO   673
0E6F:  MOVF   5D,W
0E70:  SUBWF  71,W
0E71:  BTFSS  03.2
0E72:  GOTO   678
.................... {pwm=pwm_max; 
0E73:  MOVF   5D,W
0E74:  MOVWF  71
.................... set_pwm1_duty(pwm);} 
0E75:  MOVF   71,W
0E76:  MOVWF  15
0E77:  GOTO   682
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0E78:  MOVF   5D,W
0E79:  SUBWF  71,W
0E7A:  BTFSC  03.0
0E7B:  GOTO   682
0E7C:  MOVF   71,W
0E7D:  SUBWF  5C,W
0E7E:  BTFSC  03.0
0E7F:  GOTO   682
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0E80:  MOVF   71,W
0E81:  MOVWF  15
.................... }} 
0E82:  GOTO   766
.................... else if(gradient<0) 
0E83:  MOVF   70,W
0E84:  MOVWF  75
0E85:  MOVF   6F,W
0E86:  MOVWF  74
0E87:  MOVF   6E,W
0E88:  MOVWF  73
0E89:  MOVF   6D,W
0E8A:  MOVWF  72
0E8B:  CLRF   7E
0E8C:  CLRF   7D
0E8D:  CLRF   7C
0E8E:  CLRF   7B
0E8F:  BCF    0A.3
0E90:  CALL   573
0E91:  BSF    0A.3
0E92:  BTFSS  03.0
0E93:  GOTO   6CF
.................... {  
.................... pwm-=delta; 
0E94:  MOVF   5E,W
0E95:  SUBWF  71,F
.................... PrevPsolar=Pin;  
0E96:  MOVF   49,W
0E97:  MOVWF  31
0E98:  MOVF   48,W
0E99:  MOVWF  30
0E9A:  MOVF   47,W
0E9B:  MOVWF  2F
0E9C:  MOVF   46,W
0E9D:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0E9E:  MOVF   39,W
0E9F:  MOVWF  29
0EA0:  MOVF   38,W
0EA1:  MOVWF  28
0EA2:  MOVF   37,W
0EA3:  MOVWF  27
0EA4:  MOVF   36,W
0EA5:  MOVWF  26
.................... PrevIsolar=Isolar;  
0EA6:  MOVF   41,W
0EA7:  MOVWF  2D
0EA8:  MOVF   40,W
0EA9:  MOVWF  2C
0EAA:  MOVF   3F,W
0EAB:  MOVWF  2B
0EAC:  MOVF   3E,W
0EAD:  MOVWF  2A
.................... if (pwm<pwm_min) 
0EAE:  MOVF   5C,W
0EAF:  SUBWF  71,W
0EB0:  BTFSC  03.0
0EB1:  GOTO   6B7
.................... { 
.................... pwm=pwm_min; 
0EB2:  MOVF   5C,W
0EB3:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0EB4:  MOVF   71,W
0EB5:  MOVWF  15
.................... } 
0EB6:  GOTO   6CE
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0EB7:  MOVF   71,W
0EB8:  SUBWF  5D,W
0EB9:  BTFSS  03.0
0EBA:  GOTO   6BF
0EBB:  MOVF   5D,W
0EBC:  SUBWF  71,W
0EBD:  BTFSS  03.2
0EBE:  GOTO   6C4
.................... { 
.................... pwm=pwm_max; 
0EBF:  MOVF   5D,W
0EC0:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0EC1:  MOVF   71,W
0EC2:  MOVWF  15
.................... } 
0EC3:  GOTO   6CE
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0EC4:  MOVF   5D,W
0EC5:  SUBWF  71,W
0EC6:  BTFSC  03.0
0EC7:  GOTO   6CE
0EC8:  MOVF   71,W
0EC9:  SUBWF  5C,W
0ECA:  BTFSC  03.0
0ECB:  GOTO   6CE
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0ECC:  MOVF   71,W
0ECD:  MOVWF  15
.................... }} 
0ECE:  GOTO   766
.................... else  
.................... { 
.................... if(delta_I>0) 
0ECF:  CLRF   75
0ED0:  CLRF   74
0ED1:  CLRF   73
0ED2:  CLRF   72
0ED3:  MOVF   6C,W
0ED4:  MOVWF  7E
0ED5:  MOVF   6B,W
0ED6:  MOVWF  7D
0ED7:  MOVF   6A,W
0ED8:  MOVWF  7C
0ED9:  MOVF   69,W
0EDA:  MOVWF  7B
0EDB:  BCF    0A.3
0EDC:  CALL   573
0EDD:  BSF    0A.3
0EDE:  BTFSS  03.0
0EDF:  GOTO   71B
.................... {  
.................... pwm+=delta; 
0EE0:  MOVF   5E,W
0EE1:  ADDWF  71,F
.................... PrevPsolar=Pin;  
0EE2:  MOVF   49,W
0EE3:  MOVWF  31
0EE4:  MOVF   48,W
0EE5:  MOVWF  30
0EE6:  MOVF   47,W
0EE7:  MOVWF  2F
0EE8:  MOVF   46,W
0EE9:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0EEA:  MOVF   39,W
0EEB:  MOVWF  29
0EEC:  MOVF   38,W
0EED:  MOVWF  28
0EEE:  MOVF   37,W
0EEF:  MOVWF  27
0EF0:  MOVF   36,W
0EF1:  MOVWF  26
.................... PrevIsolar=Isolar; 
0EF2:  MOVF   41,W
0EF3:  MOVWF  2D
0EF4:  MOVF   40,W
0EF5:  MOVWF  2C
0EF6:  MOVF   3F,W
0EF7:  MOVWF  2B
0EF8:  MOVF   3E,W
0EF9:  MOVWF  2A
.................... if (pwm<pwm_min) 
0EFA:  MOVF   5C,W
0EFB:  SUBWF  71,W
0EFC:  BTFSC  03.0
0EFD:  GOTO   703
.................... { 
.................... pwm=pwm_min; 
0EFE:  MOVF   5C,W
0EFF:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F00:  MOVF   71,W
0F01:  MOVWF  15
.................... } 
0F02:  GOTO   71A
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0F03:  MOVF   71,W
0F04:  SUBWF  5D,W
0F05:  BTFSS  03.0
0F06:  GOTO   70B
0F07:  MOVF   5D,W
0F08:  SUBWF  71,W
0F09:  BTFSS  03.2
0F0A:  GOTO   710
.................... { 
.................... pwm=pwm_max; 
0F0B:  MOVF   5D,W
0F0C:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F0D:  MOVF   71,W
0F0E:  MOVWF  15
.................... } 
0F0F:  GOTO   71A
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0F10:  MOVF   5D,W
0F11:  SUBWF  71,W
0F12:  BTFSC  03.0
0F13:  GOTO   71A
0F14:  MOVF   71,W
0F15:  SUBWF  5C,W
0F16:  BTFSC  03.0
0F17:  GOTO   71A
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0F18:  MOVF   71,W
0F19:  MOVWF  15
.................... }} 
0F1A:  GOTO   766
.................... else if(delta_I<0) 
0F1B:  MOVF   6C,W
0F1C:  MOVWF  75
0F1D:  MOVF   6B,W
0F1E:  MOVWF  74
0F1F:  MOVF   6A,W
0F20:  MOVWF  73
0F21:  MOVF   69,W
0F22:  MOVWF  72
0F23:  CLRF   7E
0F24:  CLRF   7D
0F25:  CLRF   7C
0F26:  CLRF   7B
0F27:  BCF    0A.3
0F28:  CALL   573
0F29:  BSF    0A.3
0F2A:  BTFSS  03.0
0F2B:  GOTO   766
.................... {  
.................... pwm-=delta; 
0F2C:  MOVF   5E,W
0F2D:  SUBWF  71,F
.................... PrevPsolar=Pin;  
0F2E:  MOVF   49,W
0F2F:  MOVWF  31
0F30:  MOVF   48,W
0F31:  MOVWF  30
0F32:  MOVF   47,W
0F33:  MOVWF  2F
0F34:  MOVF   46,W
0F35:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0F36:  MOVF   39,W
0F37:  MOVWF  29
0F38:  MOVF   38,W
0F39:  MOVWF  28
0F3A:  MOVF   37,W
0F3B:  MOVWF  27
0F3C:  MOVF   36,W
0F3D:  MOVWF  26
.................... PrevIsolar=Isolar; 
0F3E:  MOVF   41,W
0F3F:  MOVWF  2D
0F40:  MOVF   40,W
0F41:  MOVWF  2C
0F42:  MOVF   3F,W
0F43:  MOVWF  2B
0F44:  MOVF   3E,W
0F45:  MOVWF  2A
.................... if (pwm<pwm_min) 
0F46:  MOVF   5C,W
0F47:  SUBWF  71,W
0F48:  BTFSC  03.0
0F49:  GOTO   74F
.................... { 
.................... pwm=pwm_min; 
0F4A:  MOVF   5C,W
0F4B:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F4C:  MOVF   71,W
0F4D:  MOVWF  15
.................... } 
0F4E:  GOTO   766
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0F4F:  MOVF   71,W
0F50:  SUBWF  5D,W
0F51:  BTFSS  03.0
0F52:  GOTO   757
0F53:  MOVF   5D,W
0F54:  SUBWF  71,W
0F55:  BTFSS  03.2
0F56:  GOTO   75C
.................... { 
.................... pwm=pwm_max; 
0F57:  MOVF   5D,W
0F58:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F59:  MOVF   71,W
0F5A:  MOVWF  15
.................... } 
0F5B:  GOTO   766
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0F5C:  MOVF   5D,W
0F5D:  SUBWF  71,W
0F5E:  BTFSC  03.0
0F5F:  GOTO   766
0F60:  MOVF   71,W
0F61:  SUBWF  5C,W
0F62:  BTFSC  03.0
0F63:  GOTO   766
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm);}}}}}} 
0F64:  MOVF   71,W
0F65:  MOVWF  15
0F66:  GOTO   10D
....................   
0F67:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
