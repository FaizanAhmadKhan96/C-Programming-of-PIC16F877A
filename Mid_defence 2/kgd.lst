CCS PCM C Compiler, Version 5.015, 5967               05-Mar-19 13:47

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\Mid_defence 2\kgd.lst

               ROM used:   3207 words (39%)
                           Largest free fragment is 2048
               RAM used:   61 (17%) at main() level
                           104 (28%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  DATA CD,30
0005:  DATA E4,32
0006:  DATA 20,31
0007:  DATA 79,1D
0008:  DATA 00,00
0009:  DATA C6,30
000A:  DATA 69,3D
000B:  DATA 61,37
000C:  DATA AC,29
000D:  DATA E8,30
000E:  DATA EB,34
000F:  DATA 72,00
0010:  DATA CD,30
0011:  DATA E4,32
0012:  DATA 20,31
0013:  DATA 79,1D
0014:  DATA 00,01
0015:  DATA 41,37
0016:  DATA 64,10
0017:  DATA C8,30
0018:  DATA 6D,3D
0019:  DATA 61,00
001A:  DATA D6,27
001B:  DATA 4C,2A
001C:  DATA C1,23
001D:  DATA 45,1D
001E:  DATA 25,33
001F:  DATA 20,2B
0020:  DATA 00,00
0021:  DATA C3,2A
0022:  DATA 52,29
0023:  DATA 45,27
0024:  DATA 54,1D
0025:  DATA 25,33
0026:  DATA A0,20
0027:  DATA 00,01
0028:  DATA 49,27
0029:  DATA D0,2A
002A:  DATA 54,10
002B:  DATA D0,27
002C:  DATA D7,22
002D:  DATA 52,1D
002E:  DATA 00,01
002F:  DATA D6,27
0030:  DATA 4C,2A
0031:  DATA C1,23
0032:  DATA 45,1D
0033:  DATA A0,12
0034:  DATA 66,10
0035:  DATA 56,00
0036:  DATA C3,2A
0037:  DATA 52,29
0038:  DATA 45,27
0039:  DATA 54,1D
003A:  DATA A0,12
003B:  DATA 66,10
003C:  DATA 41,00
003D:  DATA CF,2A
003E:  DATA 54,28
003F:  DATA 55,2A
0040:  DATA 20,28
0041:  DATA CF,2B
0042:  DATA 45,29
0043:  DATA 3A,00
0044:  DATA C4,2A
0045:  DATA D4,2C
0046:  DATA A0,21
0047:  DATA D9,21
0048:  DATA CC,22
0049:  DATA 3A,10
004A:  DATA 25,32
004B:  DATA 20,00
*
00AA:  MOVF   0B,W
00AB:  MOVWF  65
00AC:  BCF    0B.7
00AD:  BSF    03.5
00AE:  BSF    03.6
00AF:  BSF    0C.7
00B0:  BSF    0C.0
00B1:  NOP
00B2:  NOP
00B3:  BCF    03.5
00B4:  BCF    03.6
00B5:  BTFSC  65.7
00B6:  BSF    0B.7
00B7:  BSF    03.6
00B8:  MOVF   0C,W
00B9:  ANDLW  7F
00BA:  BTFSC  03.2
00BB:  GOTO   0FE
00BC:  BCF    03.6
00BD:  MOVWF  65
00BE:  BSF    03.6
00BF:  MOVF   0D,W
00C0:  BCF    03.6
00C1:  MOVWF  66
00C2:  BSF    03.6
00C3:  MOVF   0F,W
00C4:  BCF    03.6
00C5:  MOVWF  67
00C6:  MOVF   65,W
00C7:  MOVWF  72
00C8:  CALL   093
00C9:  MOVF   66,W
00CA:  BSF    03.6
00CB:  MOVWF  0D
00CC:  BCF    03.6
00CD:  MOVF   67,W
00CE:  BSF    03.6
00CF:  MOVWF  0F
00D0:  BCF    03.6
00D1:  MOVF   0B,W
00D2:  MOVWF  68
00D3:  BCF    0B.7
00D4:  BSF    03.5
00D5:  BSF    03.6
00D6:  BSF    0C.7
00D7:  BSF    0C.0
00D8:  NOP
00D9:  NOP
00DA:  BCF    03.5
00DB:  BCF    03.6
00DC:  BTFSC  68.7
00DD:  BSF    0B.7
00DE:  BSF    03.6
00DF:  RLF    0C,W
00E0:  RLF    0E,W
00E1:  ANDLW  7F
00E2:  BTFSC  03.2
00E3:  GOTO   0FE
00E4:  BCF    03.6
00E5:  MOVWF  65
00E6:  BSF    03.6
00E7:  MOVF   0D,W
00E8:  BCF    03.6
00E9:  MOVWF  66
00EA:  BSF    03.6
00EB:  MOVF   0F,W
00EC:  BCF    03.6
00ED:  MOVWF  67
00EE:  MOVF   65,W
00EF:  MOVWF  72
00F0:  CALL   093
00F1:  MOVF   66,W
00F2:  BSF    03.6
00F3:  MOVWF  0D
00F4:  BCF    03.6
00F5:  MOVF   67,W
00F6:  BSF    03.6
00F7:  MOVWF  0F
00F8:  INCF   0D,F
00F9:  BTFSC  03.2
00FA:  INCF   0F,F
00FB:  BCF    03.6
00FC:  GOTO   0AA
00FD:  BSF    03.6
00FE:  BCF    03.6
00FF:  RETURN
*
0118:  MOVLW  8E
0119:  MOVWF  77
011A:  MOVF   66,W
011B:  MOVWF  78
011C:  MOVF   65,W
011D:  MOVWF  79
011E:  CLRF   7A
011F:  MOVF   78,F
0120:  BTFSS  03.2
0121:  GOTO   12C
0122:  MOVF   79,W
0123:  MOVWF  78
0124:  CLRF   79
0125:  MOVLW  08
0126:  SUBWF  77,F
0127:  MOVF   78,F
0128:  BTFSS  03.2
0129:  GOTO   12C
012A:  CLRF   77
012B:  GOTO   134
012C:  BCF    03.0
012D:  BTFSC  78.7
012E:  GOTO   133
012F:  RLF    79,F
0130:  RLF    78,F
0131:  DECF   77,F
0132:  GOTO   12C
0133:  BCF    78.7
0134:  RETURN
0135:  MOVF   72,W
0136:  BTFSC  03.2
0137:  GOTO   1B4
0138:  BSF    03.5
0139:  MOVWF  20
013A:  MOVF   7B,W
013B:  BTFSS  03.2
013C:  GOTO   13F
013D:  BCF    03.5
013E:  GOTO   1B4
013F:  ADDWF  20,F
0140:  BTFSC  03.0
0141:  GOTO   14D
0142:  MOVLW  7F
0143:  SUBWF  20,F
0144:  BTFSC  03.0
0145:  GOTO   148
0146:  BCF    03.5
0147:  GOTO   1B4
0148:  BTFSS  03.2
0149:  GOTO   14C
014A:  BCF    03.5
014B:  GOTO   1B4
014C:  GOTO   153
014D:  MOVLW  81
014E:  ADDWF  20,F
014F:  BTFSS  03.0
0150:  GOTO   153
0151:  BCF    03.5
0152:  GOTO   1B4
0153:  MOVF   20,W
0154:  MOVWF  77
0155:  CLRF   78
0156:  CLRF   79
0157:  CLRF   7A
0158:  MOVF   73,W
0159:  MOVWF  24
015A:  BSF    24.7
015B:  MOVF   74,W
015C:  MOVWF  23
015D:  MOVF   75,W
015E:  MOVWF  22
015F:  MOVLW  18
0160:  MOVWF  20
0161:  CLRF   21
0162:  BTFSS  22.0
0163:  GOTO   17C
0164:  MOVF   7E,W
0165:  ADDWF  7A,F
0166:  BTFSS  03.0
0167:  GOTO   16E
0168:  INCF   79,F
0169:  BTFSS  03.2
016A:  GOTO   16E
016B:  INCF   78,F
016C:  BTFSC  03.2
016D:  BSF    21.7
016E:  MOVF   7D,W
016F:  ADDWF  79,F
0170:  BTFSS  03.0
0171:  GOTO   175
0172:  INCF   78,F
0173:  BTFSC  03.2
0174:  BSF    21.7
0175:  MOVF   7C,W
0176:  MOVWF  74
0177:  BSF    74.7
0178:  MOVF   74,W
0179:  ADDWF  78,F
017A:  BTFSC  03.0
017B:  BSF    21.7
017C:  RLF    21,F
017D:  RRF    78,F
017E:  RRF    79,F
017F:  RRF    7A,F
0180:  RRF    24,F
0181:  RRF    23,F
0182:  RRF    22,F
0183:  BCF    03.0
0184:  DECFSZ 20,F
0185:  GOTO   161
0186:  MOVLW  01
0187:  ADDWF  77,F
0188:  BTFSS  03.0
0189:  GOTO   18C
018A:  BCF    03.5
018B:  GOTO   1B4
018C:  BTFSC  78.7
018D:  GOTO   196
018E:  RLF    24,F
018F:  RLF    7A,F
0190:  RLF    79,F
0191:  RLF    78,F
0192:  DECFSZ 77,F
0193:  GOTO   196
0194:  BCF    03.5
0195:  GOTO   1B4
0196:  BTFSS  24.7
0197:  GOTO   1A9
0198:  INCF   7A,F
0199:  BTFSS  03.2
019A:  GOTO   1A9
019B:  INCF   79,F
019C:  BTFSS  03.2
019D:  GOTO   1A9
019E:  INCF   78,F
019F:  BTFSS  03.2
01A0:  GOTO   1A9
01A1:  RRF    78,F
01A2:  RRF    79,F
01A3:  RRF    7A,F
01A4:  INCF   77,F
01A5:  BTFSS  03.2
01A6:  GOTO   1A9
01A7:  BCF    03.5
01A8:  GOTO   1B4
01A9:  MOVF   73,W
01AA:  MOVWF  21
01AB:  MOVF   7C,W
01AC:  XORWF  21,F
01AD:  BTFSS  21.7
01AE:  GOTO   1B1
01AF:  BSF    78.7
01B0:  GOTO   1B9
01B1:  BCF    78.7
01B2:  GOTO   1B9
01B3:  BCF    03.5
01B4:  CLRF   77
01B5:  CLRF   78
01B6:  CLRF   79
01B7:  CLRF   7A
01B8:  BSF    03.5
01B9:  BCF    03.5
01BA:  RETURN
01BB:  MOVF   69,W
01BC:  BTFSC  03.2
01BD:  GOTO   280
01BE:  MOVWF  75
01BF:  MOVF   6D,W
01C0:  BTFSC  03.2
01C1:  GOTO   280
01C2:  SUBWF  75,F
01C3:  BTFSS  03.0
01C4:  GOTO   1CA
01C5:  MOVLW  7F
01C6:  ADDWF  75,F
01C7:  BTFSC  03.0
01C8:  GOTO   280
01C9:  GOTO   1D0
01CA:  MOVLW  81
01CB:  SUBWF  75,F
01CC:  BTFSS  03.0
01CD:  GOTO   280
01CE:  BTFSC  03.2
01CF:  GOTO   280
01D0:  MOVF   75,W
01D1:  MOVWF  77
01D2:  CLRF   78
01D3:  CLRF   79
01D4:  CLRF   7A
01D5:  CLRF   74
01D6:  MOVF   6A,W
01D7:  MOVWF  73
01D8:  BSF    73.7
01D9:  MOVF   6B,W
01DA:  MOVWF  72
01DB:  MOVF   6C,W
01DC:  MOVWF  71
01DD:  MOVLW  19
01DE:  MOVWF  75
01DF:  MOVF   70,W
01E0:  SUBWF  71,F
01E1:  BTFSC  03.0
01E2:  GOTO   1F3
01E3:  MOVLW  01
01E4:  SUBWF  72,F
01E5:  BTFSC  03.0
01E6:  GOTO   1F3
01E7:  SUBWF  73,F
01E8:  BTFSC  03.0
01E9:  GOTO   1F3
01EA:  SUBWF  74,F
01EB:  BTFSC  03.0
01EC:  GOTO   1F3
01ED:  INCF   74,F
01EE:  INCF   73,F
01EF:  INCF   72,F
01F0:  MOVF   70,W
01F1:  ADDWF  71,F
01F2:  GOTO   225
01F3:  MOVF   6F,W
01F4:  SUBWF  72,F
01F5:  BTFSC  03.0
01F6:  GOTO   20E
01F7:  MOVLW  01
01F8:  SUBWF  73,F
01F9:  BTFSC  03.0
01FA:  GOTO   20E
01FB:  SUBWF  74,F
01FC:  BTFSC  03.0
01FD:  GOTO   20E
01FE:  INCF   74,F
01FF:  INCF   73,F
0200:  MOVF   6F,W
0201:  ADDWF  72,F
0202:  MOVF   70,W
0203:  ADDWF  71,F
0204:  BTFSS  03.0
0205:  GOTO   225
0206:  INCF   72,F
0207:  BTFSS  03.2
0208:  GOTO   225
0209:  INCF   73,F
020A:  BTFSS  03.2
020B:  GOTO   225
020C:  INCF   74,F
020D:  GOTO   225
020E:  MOVF   6E,W
020F:  IORLW  80
0210:  SUBWF  73,F
0211:  BTFSC  03.0
0212:  GOTO   224
0213:  MOVLW  01
0214:  SUBWF  74,F
0215:  BTFSC  03.0
0216:  GOTO   224
0217:  INCF   74,F
0218:  MOVF   6E,W
0219:  IORLW  80
021A:  ADDWF  73,F
021B:  MOVF   6F,W
021C:  ADDWF  72,F
021D:  BTFSS  03.0
021E:  GOTO   202
021F:  INCF   73,F
0220:  BTFSS  03.2
0221:  GOTO   202
0222:  INCF   74,F
0223:  GOTO   202
0224:  BSF    7A.0
0225:  DECFSZ 75,F
0226:  GOTO   228
0227:  GOTO   233
0228:  BCF    03.0
0229:  RLF    71,F
022A:  RLF    72,F
022B:  RLF    73,F
022C:  RLF    74,F
022D:  BCF    03.0
022E:  RLF    7A,F
022F:  RLF    79,F
0230:  RLF    78,F
0231:  RLF    76,F
0232:  GOTO   1DF
0233:  BTFSS  76.0
0234:  GOTO   23B
0235:  BCF    03.0
0236:  RRF    78,F
0237:  RRF    79,F
0238:  RRF    7A,F
0239:  RRF    76,F
023A:  GOTO   23E
023B:  DECF   77,F
023C:  BTFSC  03.2
023D:  GOTO   280
023E:  BTFSC  76.7
023F:  GOTO   267
0240:  BCF    03.0
0241:  RLF    71,F
0242:  RLF    72,F
0243:  RLF    73,F
0244:  RLF    74,F
0245:  MOVF   70,W
0246:  SUBWF  71,F
0247:  BTFSC  03.0
0248:  GOTO   253
0249:  MOVLW  01
024A:  SUBWF  72,F
024B:  BTFSC  03.0
024C:  GOTO   253
024D:  SUBWF  73,F
024E:  BTFSC  03.0
024F:  GOTO   253
0250:  SUBWF  74,F
0251:  BTFSS  03.0
0252:  GOTO   276
0253:  MOVF   6F,W
0254:  SUBWF  72,F
0255:  BTFSC  03.0
0256:  GOTO   25E
0257:  MOVLW  01
0258:  SUBWF  73,F
0259:  BTFSC  03.0
025A:  GOTO   25E
025B:  SUBWF  74,F
025C:  BTFSS  03.0
025D:  GOTO   276
025E:  MOVF   6E,W
025F:  IORLW  80
0260:  SUBWF  73,F
0261:  BTFSC  03.0
0262:  GOTO   267
0263:  MOVLW  01
0264:  SUBWF  74,F
0265:  BTFSS  03.0
0266:  GOTO   276
0267:  INCF   7A,F
0268:  BTFSS  03.2
0269:  GOTO   276
026A:  INCF   79,F
026B:  BTFSS  03.2
026C:  GOTO   276
026D:  INCF   78,F
026E:  BTFSS  03.2
026F:  GOTO   276
0270:  INCF   77,F
0271:  BTFSC  03.2
0272:  GOTO   280
0273:  RRF    78,F
0274:  RRF    79,F
0275:  RRF    7A,F
0276:  MOVF   6A,W
0277:  MOVWF  75
0278:  MOVF   6E,W
0279:  XORWF  75,F
027A:  BTFSS  75.7
027B:  GOTO   27E
027C:  BSF    78.7
027D:  GOTO   284
027E:  BCF    78.7
027F:  GOTO   284
0280:  CLRF   77
0281:  CLRF   78
0282:  CLRF   79
0283:  CLRF   7A
0284:  RETURN
0285:  MOVLW  80
0286:  BTFSC  03.1
0287:  XORWF  6E,F
0288:  BSF    03.5
0289:  CLRF   22
028A:  CLRF   23
028B:  BCF    03.5
028C:  MOVF   6A,W
028D:  BSF    03.5
028E:  MOVWF  21
028F:  BCF    03.5
0290:  MOVF   6E,W
0291:  BSF    03.5
0292:  XORWF  21,F
0293:  BCF    03.5
0294:  MOVF   69,W
0295:  BTFSC  03.2
0296:  GOTO   39B
0297:  BSF    03.5
0298:  MOVWF  20
0299:  MOVWF  77
029A:  BCF    03.5
029B:  MOVF   6D,W
029C:  BTFSC  03.2
029D:  GOTO   3A8
029E:  BSF    03.5
029F:  SUBWF  20,F
02A0:  BTFSC  03.2
02A1:  GOTO   335
02A2:  BTFSS  03.0
02A3:  GOTO   2E7
02A4:  BCF    03.5
02A5:  MOVF   6E,W
02A6:  BSF    03.5
02A7:  MOVWF  26
02A8:  BSF    26.7
02A9:  BCF    03.5
02AA:  MOVF   6F,W
02AB:  BSF    03.5
02AC:  MOVWF  25
02AD:  MOVF   70,W
02AE:  MOVWF  24
02AF:  CLRF   23
02B0:  BCF    03.0
02B1:  RRF    26,F
02B2:  RRF    25,F
02B3:  RRF    24,F
02B4:  RRF    23,F
02B5:  DECFSZ 20,F
02B6:  GOTO   2AF
02B7:  BTFSS  21.7
02B8:  GOTO   2BC
02B9:  BSF    22.0
02BA:  GOTO   3C1
02BB:  BCF    22.0
02BC:  BCF    20.0
02BD:  BSF    22.4
02BE:  MOVLW  6C
02BF:  MOVWF  04
02C0:  BCF    03.7
02C1:  GOTO   3D6
02C2:  BCF    22.4
02C3:  BTFSC  21.7
02C4:  GOTO   2CF
02C5:  BTFSS  20.0
02C6:  GOTO   2DA
02C7:  RRF    26,F
02C8:  RRF    25,F
02C9:  RRF    24,F
02CA:  RRF    23,F
02CB:  INCF   77,F
02CC:  BTFSC  03.2
02CD:  GOTO   3BC
02CE:  GOTO   2DA
02CF:  BTFSC  26.7
02D0:  GOTO   2DD
02D1:  BCF    03.0
02D2:  RLF    23,F
02D3:  RLF    24,F
02D4:  RLF    25,F
02D5:  RLF    26,F
02D6:  DECF   77,F
02D7:  BTFSC  03.2
02D8:  GOTO   3BC
02D9:  GOTO   2CF
02DA:  BSF    22.6
02DB:  GOTO   35B
02DC:  BCF    22.6
02DD:  BCF    03.5
02DE:  MOVF   6A,W
02DF:  BSF    03.5
02E0:  MOVWF  21
02E1:  BTFSS  21.7
02E2:  GOTO   2E5
02E3:  BSF    26.7
02E4:  GOTO   3B5
02E5:  BCF    26.7
02E6:  GOTO   3B5
02E7:  BCF    03.5
02E8:  MOVF   6D,W
02E9:  BSF    03.5
02EA:  MOVWF  20
02EB:  MOVWF  77
02EC:  BCF    03.5
02ED:  MOVF   69,W
02EE:  BSF    03.5
02EF:  SUBWF  20,F
02F0:  BCF    03.5
02F1:  MOVF   6A,W
02F2:  BSF    03.5
02F3:  MOVWF  26
02F4:  BSF    26.7
02F5:  BCF    03.5
02F6:  MOVF   6B,W
02F7:  BSF    03.5
02F8:  MOVWF  25
02F9:  BCF    03.5
02FA:  MOVF   6C,W
02FB:  BSF    03.5
02FC:  MOVWF  24
02FD:  CLRF   23
02FE:  BCF    03.0
02FF:  RRF    26,F
0300:  RRF    25,F
0301:  RRF    24,F
0302:  RRF    23,F
0303:  DECFSZ 20,F
0304:  GOTO   2FD
0305:  BTFSS  21.7
0306:  GOTO   30A
0307:  BSF    22.1
0308:  GOTO   3C1
0309:  BCF    22.1
030A:  BCF    20.0
030B:  BSF    22.5
030C:  MOVLW  70
030D:  MOVWF  04
030E:  BCF    03.7
030F:  GOTO   3D6
0310:  BCF    22.5
0311:  BTFSC  21.7
0312:  GOTO   31D
0313:  BTFSS  20.0
0314:  GOTO   328
0315:  RRF    26,F
0316:  RRF    25,F
0317:  RRF    24,F
0318:  RRF    23,F
0319:  INCF   77,F
031A:  BTFSC  03.2
031B:  GOTO   3BC
031C:  GOTO   328
031D:  BTFSC  26.7
031E:  GOTO   32B
031F:  BCF    03.0
0320:  RLF    23,F
0321:  RLF    24,F
0322:  RLF    25,F
0323:  RLF    26,F
0324:  DECF   77,F
0325:  BTFSC  03.2
0326:  GOTO   3BC
0327:  GOTO   31D
0328:  BSF    22.7
0329:  GOTO   35B
032A:  BCF    22.7
032B:  BCF    03.5
032C:  MOVF   6E,W
032D:  BSF    03.5
032E:  MOVWF  21
032F:  BTFSS  21.7
0330:  GOTO   333
0331:  BSF    26.7
0332:  GOTO   3B5
0333:  BCF    26.7
0334:  GOTO   3B5
0335:  BCF    03.5
0336:  MOVF   6E,W
0337:  BSF    03.5
0338:  MOVWF  26
0339:  BSF    26.7
033A:  BCF    03.5
033B:  MOVF   6F,W
033C:  BSF    03.5
033D:  MOVWF  25
033E:  MOVF   70,W
033F:  MOVWF  24
0340:  BTFSS  21.7
0341:  GOTO   346
0342:  BCF    26.7
0343:  BSF    22.2
0344:  GOTO   3C1
0345:  BCF    22.2
0346:  CLRF   23
0347:  BCF    20.0
0348:  MOVLW  6C
0349:  MOVWF  04
034A:  BCF    03.7
034B:  GOTO   3D6
034C:  BTFSC  21.7
034D:  GOTO   371
034E:  BCF    03.5
034F:  MOVF   6A,W
0350:  BSF    03.5
0351:  MOVWF  21
0352:  BTFSS  20.0
0353:  GOTO   35B
0354:  RRF    26,F
0355:  RRF    25,F
0356:  RRF    24,F
0357:  RRF    23,F
0358:  INCF   77,F
0359:  BTFSC  03.2
035A:  GOTO   3BC
035B:  BTFSS  23.7
035C:  GOTO   36C
035D:  INCF   24,F
035E:  BTFSS  03.2
035F:  GOTO   36C
0360:  INCF   25,F
0361:  BTFSS  03.2
0362:  GOTO   36C
0363:  INCF   26,F
0364:  BTFSS  03.2
0365:  GOTO   36C
0366:  RRF    26,F
0367:  RRF    25,F
0368:  RRF    24,F
0369:  INCF   77,F
036A:  BTFSC  03.2
036B:  GOTO   3BC
036C:  BTFSC  22.6
036D:  GOTO   2DC
036E:  BTFSC  22.7
036F:  GOTO   32A
0370:  GOTO   394
0371:  MOVLW  80
0372:  XORWF  26,F
0373:  BTFSS  26.7
0374:  GOTO   37B
0375:  GOTO   3C1
0376:  BCF    03.5
0377:  MOVF   6E,W
0378:  BSF    03.5
0379:  MOVWF  21
037A:  GOTO   38A
037B:  BCF    03.5
037C:  MOVF   6A,W
037D:  BSF    03.5
037E:  MOVWF  21
037F:  MOVF   26,F
0380:  BTFSS  03.2
0381:  GOTO   38A
0382:  MOVF   25,F
0383:  BTFSS  03.2
0384:  GOTO   38A
0385:  MOVF   24,F
0386:  BTFSS  03.2
0387:  GOTO   38A
0388:  CLRF   77
0389:  GOTO   3B5
038A:  BTFSC  26.7
038B:  GOTO   394
038C:  BCF    03.0
038D:  RLF    23,F
038E:  RLF    24,F
038F:  RLF    25,F
0390:  RLF    26,F
0391:  DECFSZ 77,F
0392:  GOTO   38A
0393:  GOTO   3BC
0394:  BTFSS  21.7
0395:  GOTO   398
0396:  BSF    26.7
0397:  GOTO   3B5
0398:  BCF    26.7
0399:  GOTO   3B5
039A:  BCF    03.5
039B:  MOVF   6D,W
039C:  MOVWF  77
039D:  MOVF   6E,W
039E:  BSF    03.5
039F:  MOVWF  26
03A0:  BCF    03.5
03A1:  MOVF   6F,W
03A2:  BSF    03.5
03A3:  MOVWF  25
03A4:  MOVF   70,W
03A5:  MOVWF  24
03A6:  GOTO   3B5
03A7:  BCF    03.5
03A8:  MOVF   69,W
03A9:  MOVWF  77
03AA:  MOVF   6A,W
03AB:  BSF    03.5
03AC:  MOVWF  26
03AD:  BCF    03.5
03AE:  MOVF   6B,W
03AF:  BSF    03.5
03B0:  MOVWF  25
03B1:  BCF    03.5
03B2:  MOVF   6C,W
03B3:  BSF    03.5
03B4:  MOVWF  24
03B5:  MOVF   26,W
03B6:  MOVWF  78
03B7:  MOVF   25,W
03B8:  MOVWF  79
03B9:  MOVF   24,W
03BA:  MOVWF  7A
03BB:  GOTO   3F4
03BC:  CLRF   77
03BD:  CLRF   78
03BE:  CLRF   79
03BF:  CLRF   7A
03C0:  GOTO   3F4
03C1:  CLRF   23
03C2:  COMF   24,F
03C3:  COMF   25,F
03C4:  COMF   26,F
03C5:  COMF   23,F
03C6:  INCF   23,F
03C7:  BTFSS  03.2
03C8:  GOTO   3CF
03C9:  INCF   24,F
03CA:  BTFSS  03.2
03CB:  GOTO   3CF
03CC:  INCF   25,F
03CD:  BTFSC  03.2
03CE:  INCF   26,F
03CF:  BTFSC  22.0
03D0:  GOTO   2BB
03D1:  BTFSC  22.1
03D2:  GOTO   309
03D3:  BTFSC  22.2
03D4:  GOTO   345
03D5:  GOTO   376
03D6:  MOVF   00,W
03D7:  ADDWF  24,F
03D8:  BTFSS  03.0
03D9:  GOTO   3E0
03DA:  INCF   25,F
03DB:  BTFSS  03.2
03DC:  GOTO   3E0
03DD:  INCF   26,F
03DE:  BTFSC  03.2
03DF:  BSF    20.0
03E0:  DECF   04,F
03E1:  MOVF   00,W
03E2:  ADDWF  25,F
03E3:  BTFSS  03.0
03E4:  GOTO   3E8
03E5:  INCF   26,F
03E6:  BTFSC  03.2
03E7:  BSF    20.0
03E8:  DECF   04,F
03E9:  MOVF   00,W
03EA:  BTFSS  00.7
03EB:  XORLW  80
03EC:  ADDWF  26,F
03ED:  BTFSC  03.0
03EE:  BSF    20.0
03EF:  BTFSC  22.4
03F0:  GOTO   2C2
03F1:  BTFSC  22.5
03F2:  GOTO   310
03F3:  GOTO   34C
03F4:  BCF    03.5
03F5:  RETURN
03F6:  MOVF   0B,W
03F7:  MOVWF  66
03F8:  BCF    0B.7
03F9:  BSF    03.5
03FA:  BSF    03.6
03FB:  BSF    0C.7
03FC:  BSF    0C.0
03FD:  NOP
03FE:  NOP
03FF:  BCF    03.5
0400:  BCF    03.6
0401:  BTFSC  66.7
0402:  BSF    0B.7
0403:  BTFSC  03.0
0404:  GOTO   42D
0405:  BSF    03.6
0406:  MOVF   0C,W
0407:  ANDLW  7F
0408:  BCF    03.6
0409:  MOVWF  66
040A:  BSF    03.6
040B:  MOVF   0D,W
040C:  BCF    03.6
040D:  MOVWF  67
040E:  BSF    03.6
040F:  MOVF   0F,W
0410:  BCF    03.6
0411:  MOVWF  68
0412:  MOVF   66,W
0413:  MOVWF  72
0414:  CALL   093
0415:  MOVF   67,W
0416:  BSF    03.6
0417:  MOVWF  0D
0418:  BCF    03.6
0419:  MOVF   68,W
041A:  BSF    03.6
041B:  MOVWF  0F
041C:  BCF    03.6
041D:  MOVF   0B,W
041E:  MOVWF  69
041F:  BCF    0B.7
0420:  BSF    03.5
0421:  BSF    03.6
0422:  BSF    0C.7
0423:  BSF    0C.0
0424:  NOP
0425:  NOP
0426:  BCF    03.5
0427:  BCF    03.6
0428:  BTFSC  69.7
0429:  BSF    0B.7
042A:  DECFSZ 65,F
042B:  GOTO   42D
042C:  GOTO   44C
042D:  BSF    03.6
042E:  RLF    0C,W
042F:  RLF    0E,W
0430:  ANDLW  7F
0431:  BCF    03.6
0432:  MOVWF  66
0433:  BSF    03.6
0434:  MOVF   0D,W
0435:  BCF    03.6
0436:  MOVWF  67
0437:  BSF    03.6
0438:  MOVF   0F,W
0439:  BCF    03.6
043A:  MOVWF  68
043B:  MOVF   66,W
043C:  MOVWF  72
043D:  CALL   093
043E:  MOVF   67,W
043F:  BSF    03.6
0440:  MOVWF  0D
0441:  BCF    03.6
0442:  MOVF   68,W
0443:  BSF    03.6
0444:  MOVWF  0F
0445:  INCF   0D,F
0446:  BTFSC  03.2
0447:  INCF   0F,F
0448:  BCF    03.0
0449:  BCF    03.6
044A:  DECFSZ 65,F
044B:  GOTO   3F6
044C:  RETURN
044D:  BTFSC  03.1
044E:  GOTO   452
044F:  MOVLW  A0
0450:  MOVWF  04
0451:  BCF    03.7
0452:  CLRF   77
0453:  CLRF   78
0454:  CLRF   79
0455:  CLRF   7A
0456:  BSF    03.5
0457:  CLRF   20
0458:  CLRF   21
0459:  CLRF   22
045A:  CLRF   23
045B:  MOVF   7E,W
045C:  IORWF  7D,W
045D:  IORWF  7C,W
045E:  IORWF  7B,W
045F:  BTFSC  03.2
0460:  GOTO   491
0461:  MOVLW  20
0462:  MOVWF  24
0463:  BCF    03.0
0464:  RLF    72,F
0465:  RLF    73,F
0466:  RLF    74,F
0467:  RLF    75,F
0468:  RLF    20,F
0469:  RLF    21,F
046A:  RLF    22,F
046B:  RLF    23,F
046C:  MOVF   7E,W
046D:  SUBWF  23,W
046E:  BTFSS  03.2
046F:  GOTO   47A
0470:  MOVF   7D,W
0471:  SUBWF  22,W
0472:  BTFSS  03.2
0473:  GOTO   47A
0474:  MOVF   7C,W
0475:  SUBWF  21,W
0476:  BTFSS  03.2
0477:  GOTO   47A
0478:  MOVF   7B,W
0479:  SUBWF  20,W
047A:  BTFSS  03.0
047B:  GOTO   48B
047C:  MOVF   7B,W
047D:  SUBWF  20,F
047E:  MOVF   7C,W
047F:  BTFSS  03.0
0480:  INCFSZ 7C,W
0481:  SUBWF  21,F
0482:  MOVF   7D,W
0483:  BTFSS  03.0
0484:  INCFSZ 7D,W
0485:  SUBWF  22,F
0486:  MOVF   7E,W
0487:  BTFSS  03.0
0488:  INCFSZ 7E,W
0489:  SUBWF  23,F
048A:  BSF    03.0
048B:  RLF    77,F
048C:  RLF    78,F
048D:  RLF    79,F
048E:  RLF    7A,F
048F:  DECFSZ 24,F
0490:  GOTO   463
0491:  MOVF   20,W
0492:  MOVWF  00
0493:  INCF   04,F
0494:  MOVF   21,W
0495:  MOVWF  00
0496:  INCF   04,F
0497:  MOVF   22,W
0498:  MOVWF  00
0499:  INCF   04,F
049A:  MOVF   23,W
049B:  MOVWF  00
049C:  BCF    03.5
049D:  RETURN
049E:  MOVF   04,W
049F:  MOVWF  6A
04A0:  MOVF   69,W
04A1:  MOVWF  6C
04A2:  BTFSC  03.2
04A3:  GOTO   4BD
04A4:  MOVF   68,W
04A5:  MOVWF  75
04A6:  MOVF   67,W
04A7:  MOVWF  74
04A8:  MOVF   66,W
04A9:  MOVWF  73
04AA:  MOVF   65,W
04AB:  MOVWF  72
04AC:  CLRF   7E
04AD:  CLRF   7D
04AE:  MOVLW  20
04AF:  MOVWF  7C
04B0:  MOVLW  82
04B1:  MOVWF  7B
04B2:  CALL   135
04B3:  MOVF   7A,W
04B4:  MOVWF  68
04B5:  MOVF   79,W
04B6:  MOVWF  67
04B7:  MOVF   78,W
04B8:  MOVWF  66
04B9:  MOVF   77,W
04BA:  MOVWF  65
04BB:  DECFSZ 6C,F
04BC:  GOTO   4A4
04BD:  MOVF   68,W
04BE:  MOVWF  75
04BF:  MOVF   67,W
04C0:  MOVWF  74
04C1:  MOVF   66,W
04C2:  MOVWF  73
04C3:  MOVF   65,W
04C4:  MOVWF  72
04C5:  MOVF   72,W
04C6:  SUBLW  B6
04C7:  MOVWF  72
04C8:  CLRF   7A
04C9:  MOVF   73,W
04CA:  MOVWF  76
04CB:  BSF    73.7
04CC:  BCF    03.0
04CD:  RRF    73,F
04CE:  RRF    74,F
04CF:  RRF    75,F
04D0:  RRF    7A,F
04D1:  RRF    79,F
04D2:  RRF    78,F
04D3:  RRF    77,F
04D4:  DECFSZ 72,F
04D5:  GOTO   4CC
04D6:  BTFSS  76.7
04D7:  GOTO   4E3
04D8:  COMF   77,F
04D9:  COMF   78,F
04DA:  COMF   79,F
04DB:  COMF   7A,F
04DC:  INCF   77,F
04DD:  BTFSC  03.2
04DE:  INCF   78,F
04DF:  BTFSC  03.2
04E0:  INCF   79,F
04E1:  BTFSC  03.2
04E2:  INCF   7A,F
04E3:  MOVF   7A,W
04E4:  MOVWF  68
04E5:  MOVF   79,W
04E6:  MOVWF  67
04E7:  MOVF   78,W
04E8:  MOVWF  66
04E9:  MOVF   77,W
04EA:  MOVWF  65
04EB:  BTFSS  68.7
04EC:  GOTO   4FA
04ED:  DECF   6A,F
04EE:  BSF    6A.5
04EF:  COMF   65,F
04F0:  COMF   66,F
04F1:  COMF   67,F
04F2:  COMF   68,F
04F3:  INCF   65,F
04F4:  BTFSC  03.2
04F5:  INCF   66,F
04F6:  BTFSC  03.2
04F7:  INCF   67,F
04F8:  BTFSC  03.2
04F9:  INCF   68,F
04FA:  MOVLW  3B
04FB:  MOVWF  71
04FC:  MOVLW  9A
04FD:  MOVWF  70
04FE:  MOVLW  CA
04FF:  MOVWF  6F
0500:  CLRF   6E
0501:  MOVLW  0A
0502:  MOVWF  6C
0503:  MOVF   69,W
0504:  BTFSC  03.2
0505:  INCF   6A,F
0506:  BSF    03.1
0507:  MOVLW  65
0508:  MOVWF  04
0509:  BCF    03.7
050A:  MOVF   68,W
050B:  MOVWF  75
050C:  MOVF   67,W
050D:  MOVWF  74
050E:  MOVF   66,W
050F:  MOVWF  73
0510:  MOVF   65,W
0511:  MOVWF  72
0512:  MOVF   71,W
0513:  MOVWF  7E
0514:  MOVF   70,W
0515:  MOVWF  7D
0516:  MOVF   6F,W
0517:  MOVWF  7C
0518:  MOVF   6E,W
0519:  MOVWF  7B
051A:  CALL   44D
051B:  MOVF   78,W
051C:  MOVF   77,F
051D:  BTFSS  03.2
051E:  GOTO   532
051F:  INCF   69,W
0520:  SUBWF  6C,W
0521:  BTFSC  03.2
0522:  GOTO   532
0523:  MOVF   6A,W
0524:  BTFSC  03.2
0525:  GOTO   534
0526:  ANDLW  0F
0527:  SUBWF  6C,W
0528:  BTFSC  03.2
0529:  GOTO   52C
052A:  BTFSC  03.0
052B:  GOTO   564
052C:  BTFSC  6A.7
052D:  GOTO   564
052E:  BTFSC  6A.6
052F:  GOTO   534
0530:  MOVLW  20
0531:  GOTO   560
0532:  MOVLW  20
0533:  ANDWF  6A,F
0534:  BTFSS  6A.5
0535:  GOTO   542
0536:  BCF    6A.5
0537:  MOVF   69,W
0538:  BTFSS  03.2
0539:  DECF   6A,F
053A:  MOVF   77,W
053B:  MOVWF  6A
053C:  MOVLW  2D
053D:  MOVWF  72
053E:  CALL   093
053F:  MOVF   6A,W
0540:  MOVWF  77
0541:  CLRF   6A
0542:  MOVF   69,W
0543:  SUBWF  6C,W
0544:  BTFSS  03.2
0545:  GOTO   550
0546:  MOVF   77,W
0547:  MOVWF  6A
0548:  MOVLW  2E
0549:  MOVWF  72
054A:  CALL   093
054B:  MOVF   6A,W
054C:  MOVWF  77
054D:  MOVLW  20
054E:  ANDWF  6A,F
054F:  MOVLW  00
0550:  MOVLW  30
0551:  BTFSS  6A.5
0552:  GOTO   560
0553:  BCF    6A.5
0554:  MOVF   69,W
0555:  BTFSS  03.2
0556:  DECF   6A,F
0557:  MOVF   77,W
0558:  MOVWF  6A
0559:  MOVLW  2D
055A:  MOVWF  72
055B:  CALL   093
055C:  MOVF   6A,W
055D:  MOVWF  77
055E:  CLRF   6A
055F:  MOVLW  30
0560:  ADDWF  77,F
0561:  MOVF   77,W
0562:  MOVWF  72
0563:  CALL   093
0564:  BCF    03.1
0565:  MOVF   71,W
0566:  MOVWF  75
0567:  MOVF   70,W
0568:  MOVWF  74
0569:  MOVF   6F,W
056A:  MOVWF  73
056B:  MOVF   6E,W
056C:  MOVWF  72
056D:  CLRF   7E
056E:  CLRF   7D
056F:  CLRF   7C
0570:  MOVLW  0A
0571:  MOVWF  7B
0572:  CALL   44D
0573:  MOVF   7A,W
0574:  MOVWF  71
0575:  MOVF   79,W
0576:  MOVWF  70
0577:  MOVF   78,W
0578:  MOVWF  6F
0579:  MOVF   77,W
057A:  MOVWF  6E
057B:  DECFSZ 6C,F
057C:  GOTO   506
057D:  RETURN
057E:  MOVF   6C,W
057F:  CLRF   78
0580:  SUBWF  6B,W
0581:  BTFSC  03.0
0582:  GOTO   586
0583:  MOVF   6B,W
0584:  MOVWF  77
0585:  GOTO   592
0586:  CLRF   77
0587:  MOVLW  08
0588:  MOVWF  6D
0589:  RLF    6B,F
058A:  RLF    77,F
058B:  MOVF   6C,W
058C:  SUBWF  77,W
058D:  BTFSC  03.0
058E:  MOVWF  77
058F:  RLF    78,F
0590:  DECFSZ 6D,F
0591:  GOTO   589
0592:  RETURN
0593:  CLRF   77
0594:  CLRF   78
0595:  MOVF   66,W
0596:  BCF    03.0
0597:  BTFSC  67.0
0598:  ADDWF  77,F
0599:  RRF    77,F
059A:  RRF    78,F
059B:  BTFSC  67.1
059C:  ADDWF  77,F
059D:  RRF    77,F
059E:  RRF    78,F
059F:  BTFSC  67.2
05A0:  ADDWF  77,F
05A1:  RRF    77,F
05A2:  RRF    78,F
05A3:  BTFSC  67.3
05A4:  ADDWF  77,F
05A5:  RRF    77,F
05A6:  RRF    78,F
05A7:  BTFSC  67.4
05A8:  ADDWF  77,F
05A9:  RRF    77,F
05AA:  RRF    78,F
05AB:  BTFSC  67.5
05AC:  ADDWF  77,F
05AD:  RRF    77,F
05AE:  RRF    78,F
05AF:  BTFSC  67.6
05B0:  ADDWF  77,F
05B1:  RRF    77,F
05B2:  RRF    78,F
05B3:  BTFSC  67.7
05B4:  ADDWF  77,F
05B5:  RRF    77,F
05B6:  RRF    78,F
05B7:  BSF    0A.3
05B8:  BCF    0A.4
05B9:  GOTO   44D (RETURN)
05BA:  MOVLW  20
05BB:  BTFSS  66.4
05BC:  MOVLW  30
05BD:  MOVWF  67
05BE:  MOVF   65,W
05BF:  MOVWF  77
05C0:  BTFSS  65.7
05C1:  GOTO   5CA
05C2:  COMF   77,F
05C3:  INCF   77,F
05C4:  MOVF   77,W
05C5:  MOVWF  65
05C6:  MOVLW  2D
05C7:  MOVWF  67
05C8:  BSF    66.7
05C9:  BSF    66.0
05CA:  MOVF   65,W
05CB:  MOVWF  6B
05CC:  MOVLW  64
05CD:  MOVWF  6C
05CE:  CALL   57E
05CF:  MOVF   77,W
05D0:  MOVWF  65
05D1:  MOVLW  30
05D2:  ADDWF  78,W
05D3:  MOVWF  68
05D4:  MOVF   65,W
05D5:  MOVWF  6B
05D6:  MOVLW  0A
05D7:  MOVWF  6C
05D8:  CALL   57E
05D9:  MOVLW  30
05DA:  ADDWF  77,W
05DB:  MOVWF  6A
05DC:  MOVLW  30
05DD:  ADDWF  78,W
05DE:  MOVWF  69
05DF:  MOVF   67,W
05E0:  MOVWF  77
05E1:  MOVLW  30
05E2:  SUBWF  68,W
05E3:  BTFSC  03.2
05E4:  GOTO   5E9
05E5:  BSF    66.1
05E6:  BTFSC  66.7
05E7:  BSF    66.2
05E8:  GOTO   5FD
05E9:  MOVF   67,W
05EA:  MOVWF  68
05EB:  MOVLW  20
05EC:  MOVWF  67
05ED:  MOVLW  30
05EE:  SUBWF  69,W
05EF:  BTFSC  03.2
05F0:  GOTO   5F5
05F1:  BSF    66.0
05F2:  BTFSC  66.7
05F3:  BSF    66.1
05F4:  GOTO   5FD
05F5:  BTFSS  03.2
05F6:  BSF    66.0
05F7:  BTFSS  03.2
05F8:  GOTO   5FD
05F9:  MOVF   68,W
05FA:  MOVWF  69
05FB:  MOVLW  20
05FC:  MOVWF  68
05FD:  BTFSC  66.2
05FE:  GOTO   604
05FF:  BTFSC  66.1
0600:  GOTO   607
0601:  BTFSC  66.0
0602:  GOTO   60A
0603:  GOTO   60D
0604:  MOVF   67,W
0605:  MOVWF  72
0606:  CALL   093
0607:  MOVF   68,W
0608:  MOVWF  72
0609:  CALL   093
060A:  MOVF   69,W
060B:  MOVWF  72
060C:  CALL   093
060D:  MOVF   6A,W
060E:  MOVWF  72
060F:  CALL   093
0610:  BSF    0A.3
0611:  BCF    0A.4
0612:  GOTO   466 (RETURN)
0613:  MOVF   66,W
0614:  MOVWF  6D
0615:  MOVF   6A,W
0616:  XORWF  6D,F
0617:  BTFSS  6D.7
0618:  GOTO   61E
0619:  BCF    03.2
061A:  BCF    03.0
061B:  BTFSC  66.7
061C:  BSF    03.0
061D:  GOTO   651
061E:  MOVF   66,W
061F:  MOVWF  6D
0620:  MOVF   69,W
0621:  MOVWF  6E
0622:  MOVF   65,W
0623:  SUBWF  6E,F
0624:  BTFSC  03.2
0625:  GOTO   62C
0626:  BTFSS  6D.7
0627:  GOTO   651
0628:  MOVF   03,W
0629:  XORLW  01
062A:  MOVWF  03
062B:  GOTO   651
062C:  MOVF   6A,W
062D:  MOVWF  6E
062E:  MOVF   66,W
062F:  SUBWF  6E,F
0630:  BTFSC  03.2
0631:  GOTO   638
0632:  BTFSS  6D.7
0633:  GOTO   651
0634:  MOVF   03,W
0635:  XORLW  01
0636:  MOVWF  03
0637:  GOTO   651
0638:  MOVF   6B,W
0639:  MOVWF  6E
063A:  MOVF   67,W
063B:  SUBWF  6E,F
063C:  BTFSC  03.2
063D:  GOTO   644
063E:  BTFSS  6D.7
063F:  GOTO   651
0640:  MOVF   03,W
0641:  XORLW  01
0642:  MOVWF  03
0643:  GOTO   651
0644:  MOVF   6C,W
0645:  MOVWF  6E
0646:  MOVF   68,W
0647:  SUBWF  6E,F
0648:  BTFSC  03.2
0649:  GOTO   650
064A:  BTFSS  6D.7
064B:  GOTO   651
064C:  MOVF   03,W
064D:  XORLW  01
064E:  MOVWF  03
064F:  GOTO   651
0650:  BCF    03.0
0651:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,BROWNOUT,NOWDT,NOLVP 
.................... #use delay(clock=20M) 
*
004C:  MOVLW  68
004D:  MOVWF  04
004E:  BCF    03.7
004F:  MOVF   00,W
0050:  BTFSC  03.2
0051:  GOTO   05F
0052:  MOVLW  06
0053:  MOVWF  78
0054:  CLRF   77
0055:  DECFSZ 77,F
0056:  GOTO   055
0057:  DECFSZ 78,F
0058:  GOTO   054
0059:  MOVLW  7B
005A:  MOVWF  77
005B:  DECFSZ 77,F
005C:  GOTO   05B
005D:  DECFSZ 00,F
005E:  GOTO   052
005F:  RETURN
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
081F:  BCF    03.5
0820:  CLRF   20
0821:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define lcd_rs pin_d0 
.................... #define lcd_en pin_d1 
....................  
....................  
.................... #define disp_clear 0b00000001 
.................... #define disp_control 0b00001110 
.................... #define func_set 0b00111000 
.................... #define lscrol 0b00011000 
.................... #define rscrol 0b00011100 
.................... #define line1 0b10000000 
.................... #define line2 0b11000000 
....................  
.................... float adc_value; 
.................... float Vsolar; 
.................... float Isolar; 
.................... float Psolar; 
.................... float Vbattery; 
.................... float Ibattery; 
.................... float Pbattery; 
.................... float PrevVsolar=0; 
.................... float PrevIsolar=0; 
.................... float PrevPsolar=0; 
.................... int dutycycle; 
.................... int pwm=10; 
.................... int pwm_min=6; 
.................... int pwm_max=14; 
.................... int delta=1; 
....................  
.................... void lcd_init (void); 
.................... void lcd_data (unsigned char); 
.................... void lcd_cmd (unsigned char); 
.................... void lcd_lscrol (unsigned char); 
.................... void lcd_rscrol (unsigned char); 
.................... void lcd_line1 (unsigned char); 
.................... void lcd_line2 (unsigned char); 
....................  
.................... void lcd_init (void) 
.................... { 
.................... delay_ms(300); 
*
0077:  MOVLW  02
0078:  MOVWF  65
0079:  MOVLW  96
007A:  MOVWF  68
007B:  CALL   04C
007C:  DECFSZ 65,F
007D:  GOTO   079
.................... lcd_cmd (func_set); 
007E:  MOVLW  38
007F:  MOVWF  67
0080:  CALL   060
.................... lcd_cmd (disp_control); 
0081:  MOVLW  0E
0082:  MOVWF  67
0083:  CALL   060
.................... lcd_cmd(disp_clear); 
0084:  MOVLW  01
0085:  MOVWF  67
0086:  CALL   060
....................  delay_ms(50); 
0087:  MOVLW  32
0088:  MOVWF  68
0089:  CALL   04C
008A:  BSF    0A.3
008B:  BCF    0A.4
008C:  GOTO   024 (RETURN)
.................... } 
....................  
.................... void lcd_cmd (unsigned char i) 
.................... { 
.................... output_low(lcd_rs); 
*
0060:  BSF    03.5
0061:  BCF    08.0
0062:  BCF    03.5
0063:  BCF    08.0
.................... output_b(i); 
0064:  BSF    03.5
0065:  CLRF   06
0066:  BCF    03.5
0067:  MOVF   67,W
0068:  MOVWF  06
.................... output_high(lcd_en); 
0069:  BSF    03.5
006A:  BCF    08.1
006B:  BCF    03.5
006C:  BSF    08.1
.................... delay_us(100); 
006D:  MOVLW  A6
006E:  MOVWF  77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  NOP
.................... output_low(lcd_en); 
0072:  BSF    03.5
0073:  BCF    08.1
0074:  BCF    03.5
0075:  BCF    08.1
0076:  RETURN
.................... } 
....................  
.................... void lcd_data (unsigned char i) 
.................... { 
.................... output_high(lcd_rs); 
*
0093:  BSF    03.5
0094:  BCF    08.0
0095:  BCF    03.5
0096:  BSF    08.0
.................... output_b(i); 
0097:  BSF    03.5
0098:  CLRF   06
0099:  MOVF   72,W
009A:  BCF    03.5
009B:  MOVWF  06
.................... output_high(lcd_en); 
009C:  BSF    03.5
009D:  BCF    08.1
009E:  BCF    03.5
009F:  BSF    08.1
.................... delay_us(100); 
00A0:  MOVLW  A6
00A1:  MOVWF  77
00A2:  DECFSZ 77,F
00A3:  GOTO   0A2
00A4:  NOP
.................... output_low(lcd_en); 
00A5:  BSF    03.5
00A6:  BCF    08.1
00A7:  BCF    03.5
00A8:  BCF    08.1
00A9:  RETURN
.................... } 
....................  
.................... void lcd_lscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
.................... { 
.................... lcd_cmd(lscrol); 
.................... delay_ms(300); 
.................... } 
.................... } 
....................  
.................... void lcd_rscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
*
0106:  CLRF   66
0107:  MOVF   65,W
0108:  SUBWF  66,W
0109:  BTFSC  03.0
010A:  GOTO   117
.................... { 
.................... lcd_cmd(rscrol); 
010B:  MOVLW  1C
010C:  MOVWF  67
010D:  CALL   060
.................... delay_ms(300); 
010E:  MOVLW  02
010F:  MOVWF  67
0110:  MOVLW  96
0111:  MOVWF  68
0112:  CALL   04C
0113:  DECFSZ 67,F
0114:  GOTO   110
0115:  INCF   66,F
0116:  GOTO   107
.................... } 
0117:  RETURN
.................... } 
....................  
.................... void lcd_line1 (unsigned char position) 
.................... { 
.................... lcd_cmd(line1 + position); 
*
008D:  MOVLW  80
008E:  ADDWF  65,W
008F:  MOVWF  66
0090:  MOVWF  67
0091:  CALL   060
0092:  RETURN
.................... } 
....................  
.................... void lcd_line2 (unsigned char position) 
.................... { 
.................... lcd_cmd(line2 + position); 
*
0100:  MOVLW  C0
0101:  ADDWF  65,W
0102:  MOVWF  66
0103:  MOVWF  67
0104:  CALL   060
0105:  RETURN
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   45
0804:  CLRF   44
0805:  CLRF   43
0806:  CLRF   42
0807:  CLRF   49
0808:  CLRF   48
0809:  CLRF   47
080A:  CLRF   46
080B:  CLRF   4D
080C:  CLRF   4C
080D:  CLRF   4B
080E:  CLRF   4A
080F:  MOVLW  0A
0810:  MOVWF  4F
0811:  MOVLW  06
0812:  MOVWF  50
0813:  MOVLW  0E
0814:  MOVWF  51
0815:  MOVLW  01
0816:  MOVWF  52
0817:  MOVLW  FF
0818:  MOVWF  53
0819:  BSF    03.5
081A:  BSF    1F.0
081B:  BSF    1F.1
081C:  BSF    1F.2
081D:  BCF    1F.3
081E:  BCF    03.7
.................... { 
.................... lcd_init(); 
*
0822:  BCF    0A.3
0823:  GOTO   077
0824:  BSF    0A.3
....................  
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
0825:  BSF    03.5
0826:  BCF    1F.0
0827:  BCF    1F.1
0828:  BCF    1F.2
0829:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_8); 
082A:  BCF    03.5
082B:  BSF    1F.6
082C:  BCF    1F.7
082D:  BSF    03.5
082E:  BSF    1F.7
082F:  BCF    03.5
0830:  BSF    1F.0
....................  
.................... output_low(PIN_C1);            
0831:  BCF    53.1
0832:  MOVF   53,W
0833:  BSF    03.5
0834:  MOVWF  07
0835:  BCF    03.5
0836:  BCF    07.1
....................  
.................... setup_ccp1(CCP_PWM);          
0837:  BCF    53.2
0838:  MOVF   53,W
0839:  BSF    03.5
083A:  MOVWF  07
083B:  BCF    03.5
083C:  BCF    07.2
083D:  MOVLW  0C
083E:  MOVWF  17
....................  
.................... setup_timer_2(T2_DIV_BY_1,19,1); 
083F:  MOVLW  00
0840:  MOVWF  78
0841:  IORLW  04
0842:  MOVWF  12
0843:  MOVLW  13
0844:  BSF    03.5
0845:  MOVWF  12
....................  
.................... int i=0; 
0846:  BCF    03.5
0847:  CLRF   54
....................  
.................... do 
.................... { 
.................... lcd_line1 (3); 
0848:  MOVLW  03
0849:  MOVWF  65
084A:  BCF    0A.3
084B:  CALL   08D
084C:  BSF    0A.3
.................... lcd_data ("Made by:"); 
084D:  MOVLW  04
084E:  BSF    03.6
084F:  MOVWF  0D
0850:  MOVLW  00
0851:  MOVWF  0F
0852:  BCF    0A.3
0853:  BCF    03.6
0854:  CALL   0AA
0855:  BSF    0A.3
.................... lcd_line2 (0); 
0856:  CLRF   65
0857:  BCF    0A.3
0858:  CALL   100
0859:  BSF    0A.3
.................... lcd_data ("Faizan,Shakir"); 
085A:  MOVLW  09
085B:  BSF    03.6
085C:  MOVWF  0D
085D:  MOVLW  00
085E:  MOVWF  0F
085F:  BCF    0A.3
0860:  BCF    03.6
0861:  CALL   0AA
0862:  BSF    0A.3
.................... delay_ms(1000); 
0863:  MOVLW  04
0864:  MOVWF  65
0865:  MOVLW  FA
0866:  MOVWF  68
0867:  BCF    0A.3
0868:  CALL   04C
0869:  BSF    0A.3
086A:  DECFSZ 65,F
086B:  GOTO   065
.................... lcd_rscrol(20); 
086C:  MOVLW  14
086D:  MOVWF  65
086E:  BCF    0A.3
086F:  CALL   106
0870:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0871:  MOVLW  01
0872:  MOVWF  67
0873:  BCF    0A.3
0874:  CALL   060
0875:  BSF    0A.3
....................  delay_ms(50); 
0876:  MOVLW  32
0877:  MOVWF  68
0878:  BCF    0A.3
0879:  CALL   04C
087A:  BSF    0A.3
....................  
.................... lcd_line1 (3); 
087B:  MOVLW  03
087C:  MOVWF  65
087D:  BCF    0A.3
087E:  CALL   08D
087F:  BSF    0A.3
.................... lcd_data ("Made by:"); 
0880:  MOVLW  10
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   0AA
0888:  BSF    0A.3
.................... lcd_line2 (2); 
0889:  MOVLW  02
088A:  MOVWF  65
088B:  BCF    0A.3
088C:  CALL   100
088D:  BSF    0A.3
.................... lcd_data ("And Hamza"); 
088E:  MOVLW  15
088F:  BSF    03.6
0890:  MOVWF  0D
0891:  MOVLW  00
0892:  MOVWF  0F
0893:  BCF    0A.3
0894:  BCF    03.6
0895:  CALL   0AA
0896:  BSF    0A.3
.................... delay_ms(1000); 
0897:  MOVLW  04
0898:  MOVWF  65
0899:  MOVLW  FA
089A:  MOVWF  68
089B:  BCF    0A.3
089C:  CALL   04C
089D:  BSF    0A.3
089E:  DECFSZ 65,F
089F:  GOTO   099
.................... lcd_rscrol(20); 
08A0:  MOVLW  14
08A1:  MOVWF  65
08A2:  BCF    0A.3
08A3:  CALL   106
08A4:  BSF    0A.3
.................... i++; 
08A5:  INCF   54,F
.................... } 
.................... while(i==0); 
08A6:  MOVF   54,F
08A7:  BTFSC  03.2
08A8:  GOTO   048
....................  
.................... lcd_cmd(disp_clear); 
08A9:  MOVLW  01
08AA:  MOVWF  67
08AB:  BCF    0A.3
08AC:  CALL   060
08AD:  BSF    0A.3
....................  delay_ms(50); 
08AE:  MOVLW  32
08AF:  MOVWF  68
08B0:  BCF    0A.3
08B1:  CALL   04C
08B2:  BSF    0A.3
....................   
.................... while(1) 
.................... { 
.................... set_adc_channel(0); 
08B3:  MOVLW  00
08B4:  MOVWF  78
08B5:  MOVF   1F,W
08B6:  ANDLW  C7
08B7:  IORWF  78,W
08B8:  MOVWF  1F
.................... delay_us(100); 
08B9:  MOVLW  A6
08BA:  MOVWF  77
08BB:  DECFSZ 77,F
08BC:  GOTO   0BB
08BD:  NOP
....................  
.................... adc_value = read_adc(); 
08BE:  BSF    1F.2
08BF:  BTFSC  1F.2
08C0:  GOTO   0BF
08C1:  MOVF   1E,W
08C2:  MOVWF  7A
08C3:  BSF    03.5
08C4:  MOVF   1E,W
08C5:  BCF    03.5
08C6:  MOVWF  65
08C7:  MOVF   1E,W
08C8:  MOVWF  66
08C9:  BCF    0A.3
08CA:  CALL   118
08CB:  BSF    0A.3
08CC:  MOVF   7A,W
08CD:  MOVWF  29
08CE:  MOVF   79,W
08CF:  MOVWF  28
08D0:  MOVF   78,W
08D1:  MOVWF  27
08D2:  MOVF   77,W
08D3:  MOVWF  26
....................  
.................... Vsolar = (5.0*adc_value/1023.0)/0.111; 
08D4:  CLRF   75
08D5:  CLRF   74
08D6:  MOVLW  20
08D7:  MOVWF  73
08D8:  MOVLW  81
08D9:  MOVWF  72
08DA:  MOVF   29,W
08DB:  MOVWF  7E
08DC:  MOVF   28,W
08DD:  MOVWF  7D
08DE:  MOVF   27,W
08DF:  MOVWF  7C
08E0:  MOVF   26,W
08E1:  MOVWF  7B
08E2:  BCF    0A.3
08E3:  CALL   135
08E4:  BSF    0A.3
08E5:  MOVF   7A,W
08E6:  MOVWF  68
08E7:  MOVF   79,W
08E8:  MOVWF  67
08E9:  MOVF   78,W
08EA:  MOVWF  66
08EB:  MOVF   77,W
08EC:  MOVWF  65
08ED:  MOVF   68,W
08EE:  MOVWF  6C
08EF:  MOVF   67,W
08F0:  MOVWF  6B
08F1:  MOVF   66,W
08F2:  MOVWF  6A
08F3:  MOVF   65,W
08F4:  MOVWF  69
08F5:  CLRF   70
08F6:  MOVLW  C0
08F7:  MOVWF  6F
08F8:  MOVLW  7F
08F9:  MOVWF  6E
08FA:  MOVLW  88
08FB:  MOVWF  6D
08FC:  BCF    0A.3
08FD:  CALL   1BB
08FE:  BSF    0A.3
08FF:  MOVF   7A,W
0900:  MOVWF  68
0901:  MOVF   79,W
0902:  MOVWF  67
0903:  MOVF   78,W
0904:  MOVWF  66
0905:  MOVF   77,W
0906:  MOVWF  65
0907:  MOVF   68,W
0908:  MOVWF  6C
0909:  MOVF   67,W
090A:  MOVWF  6B
090B:  MOVF   66,W
090C:  MOVWF  6A
090D:  MOVF   65,W
090E:  MOVWF  69
090F:  MOVLW  F8
0910:  MOVWF  70
0911:  MOVLW  53
0912:  MOVWF  6F
0913:  MOVLW  63
0914:  MOVWF  6E
0915:  MOVLW  7B
0916:  MOVWF  6D
0917:  BCF    0A.3
0918:  CALL   1BB
0919:  BSF    0A.3
091A:  MOVF   7A,W
091B:  MOVWF  2D
091C:  MOVF   79,W
091D:  MOVWF  2C
091E:  MOVF   78,W
091F:  MOVWF  2B
0920:  MOVF   77,W
0921:  MOVWF  2A
....................  
....................  set_adc_channel(1); 
0922:  MOVLW  08
0923:  MOVWF  78
0924:  MOVF   1F,W
0925:  ANDLW  C7
0926:  IORWF  78,W
0927:  MOVWF  1F
.................... delay_us(100); 
0928:  MOVLW  A6
0929:  MOVWF  77
092A:  DECFSZ 77,F
092B:  GOTO   12A
092C:  NOP
....................  
.................... adc_value = read_adc(); 
092D:  BSF    1F.2
092E:  BTFSC  1F.2
092F:  GOTO   12E
0930:  MOVF   1E,W
0931:  MOVWF  7A
0932:  BSF    03.5
0933:  MOVF   1E,W
0934:  BCF    03.5
0935:  MOVWF  65
0936:  MOVF   1E,W
0937:  MOVWF  66
0938:  BCF    0A.3
0939:  CALL   118
093A:  BSF    0A.3
093B:  MOVF   7A,W
093C:  MOVWF  29
093D:  MOVF   79,W
093E:  MOVWF  28
093F:  MOVF   78,W
0940:  MOVWF  27
0941:  MOVF   77,W
0942:  MOVWF  26
....................  
.................... Isolar = ((5.0/1023.0*adc_value)-2.45)/0.066; 
0943:  MOVLW  0A
0944:  MOVWF  75
0945:  MOVLW  28
0946:  MOVWF  74
0947:  MOVLW  20
0948:  MOVWF  73
0949:  MOVLW  77
094A:  MOVWF  72
094B:  MOVF   29,W
094C:  MOVWF  7E
094D:  MOVF   28,W
094E:  MOVWF  7D
094F:  MOVF   27,W
0950:  MOVWF  7C
0951:  MOVF   26,W
0952:  MOVWF  7B
0953:  BCF    0A.3
0954:  CALL   135
0955:  BSF    0A.3
0956:  MOVF   7A,W
0957:  MOVWF  68
0958:  MOVF   79,W
0959:  MOVWF  67
095A:  MOVF   78,W
095B:  MOVWF  66
095C:  MOVF   77,W
095D:  MOVWF  65
095E:  BSF    03.1
095F:  MOVF   68,W
0960:  MOVWF  6C
0961:  MOVF   67,W
0962:  MOVWF  6B
0963:  MOVF   66,W
0964:  MOVWF  6A
0965:  MOVF   65,W
0966:  MOVWF  69
0967:  MOVLW  CD
0968:  MOVWF  70
0969:  MOVLW  CC
096A:  MOVWF  6F
096B:  MOVLW  1C
096C:  MOVWF  6E
096D:  MOVLW  80
096E:  MOVWF  6D
096F:  BCF    0A.3
0970:  CALL   285
0971:  BSF    0A.3
0972:  MOVF   7A,W
0973:  MOVWF  68
0974:  MOVF   79,W
0975:  MOVWF  67
0976:  MOVF   78,W
0977:  MOVWF  66
0978:  MOVF   77,W
0979:  MOVWF  65
097A:  MOVF   68,W
097B:  MOVWF  6C
097C:  MOVF   67,W
097D:  MOVWF  6B
097E:  MOVF   66,W
097F:  MOVWF  6A
0980:  MOVF   65,W
0981:  MOVWF  69
0982:  MOVLW  02
0983:  MOVWF  70
0984:  MOVLW  2B
0985:  MOVWF  6F
0986:  MOVLW  07
0987:  MOVWF  6E
0988:  MOVLW  7B
0989:  MOVWF  6D
098A:  BCF    0A.3
098B:  CALL   1BB
098C:  BSF    0A.3
098D:  MOVF   7A,W
098E:  MOVWF  31
098F:  MOVF   79,W
0990:  MOVWF  30
0991:  MOVF   78,W
0992:  MOVWF  2F
0993:  MOVF   77,W
0994:  MOVWF  2E
....................  
.................... set_adc_channel(2); 
0995:  MOVLW  10
0996:  MOVWF  78
0997:  MOVF   1F,W
0998:  ANDLW  C7
0999:  IORWF  78,W
099A:  MOVWF  1F
.................... delay_us(100); 
099B:  MOVLW  A6
099C:  MOVWF  77
099D:  DECFSZ 77,F
099E:  GOTO   19D
099F:  NOP
....................  
.................... adc_value = read_adc(); 
09A0:  BSF    1F.2
09A1:  BTFSC  1F.2
09A2:  GOTO   1A1
09A3:  MOVF   1E,W
09A4:  MOVWF  7A
09A5:  BSF    03.5
09A6:  MOVF   1E,W
09A7:  BCF    03.5
09A8:  MOVWF  65
09A9:  MOVF   1E,W
09AA:  MOVWF  66
09AB:  BCF    0A.3
09AC:  CALL   118
09AD:  BSF    0A.3
09AE:  MOVF   7A,W
09AF:  MOVWF  29
09B0:  MOVF   79,W
09B1:  MOVWF  28
09B2:  MOVF   78,W
09B3:  MOVWF  27
09B4:  MOVF   77,W
09B5:  MOVWF  26
....................  
.................... Vbattery = (5.0*adc_value/1023.0)/0.333; 
09B6:  CLRF   75
09B7:  CLRF   74
09B8:  MOVLW  20
09B9:  MOVWF  73
09BA:  MOVLW  81
09BB:  MOVWF  72
09BC:  MOVF   29,W
09BD:  MOVWF  7E
09BE:  MOVF   28,W
09BF:  MOVWF  7D
09C0:  MOVF   27,W
09C1:  MOVWF  7C
09C2:  MOVF   26,W
09C3:  MOVWF  7B
09C4:  BCF    0A.3
09C5:  CALL   135
09C6:  BSF    0A.3
09C7:  MOVF   7A,W
09C8:  MOVWF  68
09C9:  MOVF   79,W
09CA:  MOVWF  67
09CB:  MOVF   78,W
09CC:  MOVWF  66
09CD:  MOVF   77,W
09CE:  MOVWF  65
09CF:  MOVF   68,W
09D0:  MOVWF  6C
09D1:  MOVF   67,W
09D2:  MOVWF  6B
09D3:  MOVF   66,W
09D4:  MOVWF  6A
09D5:  MOVF   65,W
09D6:  MOVWF  69
09D7:  CLRF   70
09D8:  MOVLW  C0
09D9:  MOVWF  6F
09DA:  MOVLW  7F
09DB:  MOVWF  6E
09DC:  MOVLW  88
09DD:  MOVWF  6D
09DE:  BCF    0A.3
09DF:  CALL   1BB
09E0:  BSF    0A.3
09E1:  MOVF   7A,W
09E2:  MOVWF  68
09E3:  MOVF   79,W
09E4:  MOVWF  67
09E5:  MOVF   78,W
09E6:  MOVWF  66
09E7:  MOVF   77,W
09E8:  MOVWF  65
09E9:  MOVF   68,W
09EA:  MOVWF  6C
09EB:  MOVF   67,W
09EC:  MOVWF  6B
09ED:  MOVF   66,W
09EE:  MOVWF  6A
09EF:  MOVF   65,W
09F0:  MOVWF  69
09F1:  MOVLW  FA
09F2:  MOVWF  70
09F3:  MOVLW  7E
09F4:  MOVWF  6F
09F5:  MOVLW  2A
09F6:  MOVWF  6E
09F7:  MOVLW  7D
09F8:  MOVWF  6D
09F9:  BCF    0A.3
09FA:  CALL   1BB
09FB:  BSF    0A.3
09FC:  MOVF   7A,W
09FD:  MOVWF  39
09FE:  MOVF   79,W
09FF:  MOVWF  38
0A00:  MOVF   78,W
0A01:  MOVWF  37
0A02:  MOVF   77,W
0A03:  MOVWF  36
....................  
.................... set_adc_channel(3); 
0A04:  MOVLW  18
0A05:  MOVWF  78
0A06:  MOVF   1F,W
0A07:  ANDLW  C7
0A08:  IORWF  78,W
0A09:  MOVWF  1F
.................... delay_us(100); 
0A0A:  MOVLW  A6
0A0B:  MOVWF  77
0A0C:  DECFSZ 77,F
0A0D:  GOTO   20C
0A0E:  NOP
....................  
.................... adc_value = read_adc(); 
0A0F:  BSF    1F.2
0A10:  BTFSC  1F.2
0A11:  GOTO   210
0A12:  MOVF   1E,W
0A13:  MOVWF  7A
0A14:  BSF    03.5
0A15:  MOVF   1E,W
0A16:  BCF    03.5
0A17:  MOVWF  65
0A18:  MOVF   1E,W
0A19:  MOVWF  66
0A1A:  BCF    0A.3
0A1B:  CALL   118
0A1C:  BSF    0A.3
0A1D:  MOVF   7A,W
0A1E:  MOVWF  29
0A1F:  MOVF   79,W
0A20:  MOVWF  28
0A21:  MOVF   78,W
0A22:  MOVWF  27
0A23:  MOVF   77,W
0A24:  MOVWF  26
....................  
.................... Ibattery = ((5.0/1023.0*adc_value)-1.92)/0.066; 
0A25:  MOVLW  0A
0A26:  MOVWF  75
0A27:  MOVLW  28
0A28:  MOVWF  74
0A29:  MOVLW  20
0A2A:  MOVWF  73
0A2B:  MOVLW  77
0A2C:  MOVWF  72
0A2D:  MOVF   29,W
0A2E:  MOVWF  7E
0A2F:  MOVF   28,W
0A30:  MOVWF  7D
0A31:  MOVF   27,W
0A32:  MOVWF  7C
0A33:  MOVF   26,W
0A34:  MOVWF  7B
0A35:  BCF    0A.3
0A36:  CALL   135
0A37:  BSF    0A.3
0A38:  MOVF   7A,W
0A39:  MOVWF  68
0A3A:  MOVF   79,W
0A3B:  MOVWF  67
0A3C:  MOVF   78,W
0A3D:  MOVWF  66
0A3E:  MOVF   77,W
0A3F:  MOVWF  65
0A40:  BSF    03.1
0A41:  MOVF   68,W
0A42:  MOVWF  6C
0A43:  MOVF   67,W
0A44:  MOVWF  6B
0A45:  MOVF   66,W
0A46:  MOVWF  6A
0A47:  MOVF   65,W
0A48:  MOVWF  69
0A49:  MOVLW  8F
0A4A:  MOVWF  70
0A4B:  MOVLW  C2
0A4C:  MOVWF  6F
0A4D:  MOVLW  75
0A4E:  MOVWF  6E
0A4F:  MOVLW  7F
0A50:  MOVWF  6D
0A51:  BCF    0A.3
0A52:  CALL   285
0A53:  BSF    0A.3
0A54:  MOVF   7A,W
0A55:  MOVWF  68
0A56:  MOVF   79,W
0A57:  MOVWF  67
0A58:  MOVF   78,W
0A59:  MOVWF  66
0A5A:  MOVF   77,W
0A5B:  MOVWF  65
0A5C:  MOVF   68,W
0A5D:  MOVWF  6C
0A5E:  MOVF   67,W
0A5F:  MOVWF  6B
0A60:  MOVF   66,W
0A61:  MOVWF  6A
0A62:  MOVF   65,W
0A63:  MOVWF  69
0A64:  MOVLW  02
0A65:  MOVWF  70
0A66:  MOVLW  2B
0A67:  MOVWF  6F
0A68:  MOVLW  07
0A69:  MOVWF  6E
0A6A:  MOVLW  7B
0A6B:  MOVWF  6D
0A6C:  BCF    0A.3
0A6D:  CALL   1BB
0A6E:  BSF    0A.3
0A6F:  MOVF   7A,W
0A70:  MOVWF  3D
0A71:  MOVF   79,W
0A72:  MOVWF  3C
0A73:  MOVF   78,W
0A74:  MOVWF  3B
0A75:  MOVF   77,W
0A76:  MOVWF  3A
....................  
.................... lcd_line1(0); 
0A77:  CLRF   65
0A78:  BCF    0A.3
0A79:  CALL   08D
0A7A:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE:%f V",Vsolar); 
0A7B:  MOVLW  1A
0A7C:  BSF    03.6
0A7D:  MOVWF  0D
0A7E:  MOVLW  00
0A7F:  MOVWF  0F
0A80:  BCF    03.0
0A81:  MOVLW  08
0A82:  BCF    03.6
0A83:  MOVWF  65
0A84:  BCF    0A.3
0A85:  CALL   3F6
0A86:  BSF    0A.3
0A87:  MOVLW  89
0A88:  MOVWF  04
0A89:  MOVF   2D,W
0A8A:  MOVWF  68
0A8B:  MOVF   2C,W
0A8C:  MOVWF  67
0A8D:  MOVF   2B,W
0A8E:  MOVWF  66
0A8F:  MOVF   2A,W
0A90:  MOVWF  65
0A91:  MOVLW  02
0A92:  MOVWF  69
0A93:  BCF    0A.3
0A94:  CALL   49E
0A95:  BSF    0A.3
0A96:  MOVLW  20
0A97:  MOVWF  72
0A98:  BCF    0A.3
0A99:  CALL   093
0A9A:  BSF    0A.3
0A9B:  MOVLW  56
0A9C:  MOVWF  72
0A9D:  BCF    0A.3
0A9E:  CALL   093
0A9F:  BSF    0A.3
.................... delay_ms(1000); 
0AA0:  MOVLW  04
0AA1:  MOVWF  65
0AA2:  MOVLW  FA
0AA3:  MOVWF  68
0AA4:  BCF    0A.3
0AA5:  CALL   04C
0AA6:  BSF    0A.3
0AA7:  DECFSZ 65,F
0AA8:  GOTO   2A2
.................... lcd_rscrol(20); 
0AA9:  MOVLW  14
0AAA:  MOVWF  65
0AAB:  BCF    0A.3
0AAC:  CALL   106
0AAD:  BSF    0A.3
.................... delay_ms(1000); 
0AAE:  MOVLW  04
0AAF:  MOVWF  65
0AB0:  MOVLW  FA
0AB1:  MOVWF  68
0AB2:  BCF    0A.3
0AB3:  CALL   04C
0AB4:  BSF    0A.3
0AB5:  DECFSZ 65,F
0AB6:  GOTO   2B0
....................  
.................... lcd_cmd(disp_clear); 
0AB7:  MOVLW  01
0AB8:  MOVWF  67
0AB9:  BCF    0A.3
0ABA:  CALL   060
0ABB:  BSF    0A.3
....................  delay_ms(50); 
0ABC:  MOVLW  32
0ABD:  MOVWF  68
0ABE:  BCF    0A.3
0ABF:  CALL   04C
0AC0:  BSF    0A.3
....................   
.................... lcd_line1(0); 
0AC1:  CLRF   65
0AC2:  BCF    0A.3
0AC3:  CALL   08D
0AC4:  BSF    0A.3
....................  
....................  printf(lcd_data,"CURRENT:%f A",Isolar); 
0AC5:  MOVLW  21
0AC6:  BSF    03.6
0AC7:  MOVWF  0D
0AC8:  MOVLW  00
0AC9:  MOVWF  0F
0ACA:  BCF    03.0
0ACB:  MOVLW  08
0ACC:  BCF    03.6
0ACD:  MOVWF  65
0ACE:  BCF    0A.3
0ACF:  CALL   3F6
0AD0:  BSF    0A.3
0AD1:  MOVLW  89
0AD2:  MOVWF  04
0AD3:  MOVF   31,W
0AD4:  MOVWF  68
0AD5:  MOVF   30,W
0AD6:  MOVWF  67
0AD7:  MOVF   2F,W
0AD8:  MOVWF  66
0AD9:  MOVF   2E,W
0ADA:  MOVWF  65
0ADB:  MOVLW  02
0ADC:  MOVWF  69
0ADD:  BCF    0A.3
0ADE:  CALL   49E
0ADF:  BSF    0A.3
0AE0:  MOVLW  20
0AE1:  MOVWF  72
0AE2:  BCF    0A.3
0AE3:  CALL   093
0AE4:  BSF    0A.3
0AE5:  MOVLW  41
0AE6:  MOVWF  72
0AE7:  BCF    0A.3
0AE8:  CALL   093
0AE9:  BSF    0A.3
.................... delay_ms(1000); 
0AEA:  MOVLW  04
0AEB:  MOVWF  65
0AEC:  MOVLW  FA
0AED:  MOVWF  68
0AEE:  BCF    0A.3
0AEF:  CALL   04C
0AF0:  BSF    0A.3
0AF1:  DECFSZ 65,F
0AF2:  GOTO   2EC
.................... lcd_rscrol(20); 
0AF3:  MOVLW  14
0AF4:  MOVWF  65
0AF5:  BCF    0A.3
0AF6:  CALL   106
0AF7:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0AF8:  MOVLW  01
0AF9:  MOVWF  67
0AFA:  BCF    0A.3
0AFB:  CALL   060
0AFC:  BSF    0A.3
....................  delay_ms(50); 
0AFD:  MOVLW  32
0AFE:  MOVWF  68
0AFF:  BCF    0A.3
0B00:  CALL   04C
0B01:  BSF    0A.3
....................   
....................  Psolar=Vsolar*Isolar; 
0B02:  MOVF   2D,W
0B03:  MOVWF  75
0B04:  MOVF   2C,W
0B05:  MOVWF  74
0B06:  MOVF   2B,W
0B07:  MOVWF  73
0B08:  MOVF   2A,W
0B09:  MOVWF  72
0B0A:  MOVF   31,W
0B0B:  MOVWF  7E
0B0C:  MOVF   30,W
0B0D:  MOVWF  7D
0B0E:  MOVF   2F,W
0B0F:  MOVWF  7C
0B10:  MOVF   2E,W
0B11:  MOVWF  7B
0B12:  BCF    0A.3
0B13:  CALL   135
0B14:  BSF    0A.3
0B15:  MOVF   7A,W
0B16:  MOVWF  35
0B17:  MOVF   79,W
0B18:  MOVWF  34
0B19:  MOVF   78,W
0B1A:  MOVWF  33
0B1B:  MOVF   77,W
0B1C:  MOVWF  32
....................  lcd_line1(0); 
0B1D:  CLRF   65
0B1E:  BCF    0A.3
0B1F:  CALL   08D
0B20:  BSF    0A.3
....................  lcd_data("INPUT POWER:"); 
0B21:  MOVLW  28
0B22:  BSF    03.6
0B23:  MOVWF  0D
0B24:  MOVLW  00
0B25:  MOVWF  0F
0B26:  BCF    0A.3
0B27:  BCF    03.6
0B28:  CALL   0AA
0B29:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0B2A:  MOVLW  03
0B2B:  MOVWF  65
0B2C:  BCF    0A.3
0B2D:  CALL   100
0B2E:  BSF    0A.3
....................  printf(lcd_data,"%f W",Psolar); 
0B2F:  MOVLW  89
0B30:  MOVWF  04
0B31:  MOVF   35,W
0B32:  MOVWF  68
0B33:  MOVF   34,W
0B34:  MOVWF  67
0B35:  MOVF   33,W
0B36:  MOVWF  66
0B37:  MOVF   32,W
0B38:  MOVWF  65
0B39:  MOVLW  02
0B3A:  MOVWF  69
0B3B:  BCF    0A.3
0B3C:  CALL   49E
0B3D:  BSF    0A.3
0B3E:  MOVLW  20
0B3F:  MOVWF  72
0B40:  BCF    0A.3
0B41:  CALL   093
0B42:  BSF    0A.3
0B43:  MOVLW  57
0B44:  MOVWF  72
0B45:  BCF    0A.3
0B46:  CALL   093
0B47:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0B48:  MOVLW  04
0B49:  MOVWF  65
0B4A:  MOVLW  FA
0B4B:  MOVWF  68
0B4C:  BCF    0A.3
0B4D:  CALL   04C
0B4E:  BSF    0A.3
0B4F:  DECFSZ 65,F
0B50:  GOTO   34A
.................... lcd_rscrol(20); 
0B51:  MOVLW  14
0B52:  MOVWF  65
0B53:  BCF    0A.3
0B54:  CALL   106
0B55:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B56:  MOVLW  01
0B57:  MOVWF  67
0B58:  BCF    0A.3
0B59:  CALL   060
0B5A:  BSF    0A.3
....................  delay_ms(50); 
0B5B:  MOVLW  32
0B5C:  MOVWF  68
0B5D:  BCF    0A.3
0B5E:  CALL   04C
0B5F:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0B60:  CLRF   65
0B61:  BCF    0A.3
0B62:  CALL   08D
0B63:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE: %f V",Vbattery); 
0B64:  MOVLW  2F
0B65:  BSF    03.6
0B66:  MOVWF  0D
0B67:  MOVLW  00
0B68:  MOVWF  0F
0B69:  BCF    03.0
0B6A:  MOVLW  09
0B6B:  BCF    03.6
0B6C:  MOVWF  65
0B6D:  BCF    0A.3
0B6E:  CALL   3F6
0B6F:  BSF    0A.3
0B70:  MOVLW  89
0B71:  MOVWF  04
0B72:  MOVF   39,W
0B73:  MOVWF  68
0B74:  MOVF   38,W
0B75:  MOVWF  67
0B76:  MOVF   37,W
0B77:  MOVWF  66
0B78:  MOVF   36,W
0B79:  MOVWF  65
0B7A:  MOVLW  02
0B7B:  MOVWF  69
0B7C:  BCF    0A.3
0B7D:  CALL   49E
0B7E:  BSF    0A.3
0B7F:  MOVLW  20
0B80:  MOVWF  72
0B81:  BCF    0A.3
0B82:  CALL   093
0B83:  BSF    0A.3
0B84:  MOVLW  56
0B85:  MOVWF  72
0B86:  BCF    0A.3
0B87:  CALL   093
0B88:  BSF    0A.3
.................... delay_ms(1000); 
0B89:  MOVLW  04
0B8A:  MOVWF  65
0B8B:  MOVLW  FA
0B8C:  MOVWF  68
0B8D:  BCF    0A.3
0B8E:  CALL   04C
0B8F:  BSF    0A.3
0B90:  DECFSZ 65,F
0B91:  GOTO   38B
.................... lcd_rscrol(20); 
0B92:  MOVLW  14
0B93:  MOVWF  65
0B94:  BCF    0A.3
0B95:  CALL   106
0B96:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B97:  MOVLW  01
0B98:  MOVWF  67
0B99:  BCF    0A.3
0B9A:  CALL   060
0B9B:  BSF    0A.3
....................  delay_ms(50); 
0B9C:  MOVLW  32
0B9D:  MOVWF  68
0B9E:  BCF    0A.3
0B9F:  CALL   04C
0BA0:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0BA1:  CLRF   65
0BA2:  BCF    0A.3
0BA3:  CALL   08D
0BA4:  BSF    0A.3
....................  
.................... printf(lcd_data,"CURRENT: %f A",Ibattery); 
0BA5:  MOVLW  36
0BA6:  BSF    03.6
0BA7:  MOVWF  0D
0BA8:  MOVLW  00
0BA9:  MOVWF  0F
0BAA:  BCF    03.0
0BAB:  MOVLW  09
0BAC:  BCF    03.6
0BAD:  MOVWF  65
0BAE:  BCF    0A.3
0BAF:  CALL   3F6
0BB0:  BSF    0A.3
0BB1:  MOVLW  89
0BB2:  MOVWF  04
0BB3:  MOVF   3D,W
0BB4:  MOVWF  68
0BB5:  MOVF   3C,W
0BB6:  MOVWF  67
0BB7:  MOVF   3B,W
0BB8:  MOVWF  66
0BB9:  MOVF   3A,W
0BBA:  MOVWF  65
0BBB:  MOVLW  02
0BBC:  MOVWF  69
0BBD:  BCF    0A.3
0BBE:  CALL   49E
0BBF:  BSF    0A.3
0BC0:  MOVLW  20
0BC1:  MOVWF  72
0BC2:  BCF    0A.3
0BC3:  CALL   093
0BC4:  BSF    0A.3
0BC5:  MOVLW  41
0BC6:  MOVWF  72
0BC7:  BCF    0A.3
0BC8:  CALL   093
0BC9:  BSF    0A.3
.................... delay_ms(1000); 
0BCA:  MOVLW  04
0BCB:  MOVWF  65
0BCC:  MOVLW  FA
0BCD:  MOVWF  68
0BCE:  BCF    0A.3
0BCF:  CALL   04C
0BD0:  BSF    0A.3
0BD1:  DECFSZ 65,F
0BD2:  GOTO   3CC
.................... lcd_rscrol(20); 
0BD3:  MOVLW  14
0BD4:  MOVWF  65
0BD5:  BCF    0A.3
0BD6:  CALL   106
0BD7:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0BD8:  MOVLW  01
0BD9:  MOVWF  67
0BDA:  BCF    0A.3
0BDB:  CALL   060
0BDC:  BSF    0A.3
....................  delay_ms(50); 
0BDD:  MOVLW  32
0BDE:  MOVWF  68
0BDF:  BCF    0A.3
0BE0:  CALL   04C
0BE1:  BSF    0A.3
....................   
....................   Pbattery=Vbattery*Ibattery; 
0BE2:  MOVF   39,W
0BE3:  MOVWF  75
0BE4:  MOVF   38,W
0BE5:  MOVWF  74
0BE6:  MOVF   37,W
0BE7:  MOVWF  73
0BE8:  MOVF   36,W
0BE9:  MOVWF  72
0BEA:  MOVF   3D,W
0BEB:  MOVWF  7E
0BEC:  MOVF   3C,W
0BED:  MOVWF  7D
0BEE:  MOVF   3B,W
0BEF:  MOVWF  7C
0BF0:  MOVF   3A,W
0BF1:  MOVWF  7B
0BF2:  BCF    0A.3
0BF3:  CALL   135
0BF4:  BSF    0A.3
0BF5:  MOVF   7A,W
0BF6:  MOVWF  41
0BF7:  MOVF   79,W
0BF8:  MOVWF  40
0BF9:  MOVF   78,W
0BFA:  MOVWF  3F
0BFB:  MOVF   77,W
0BFC:  MOVWF  3E
....................  lcd_line1(0); 
0BFD:  CLRF   65
0BFE:  BCF    0A.3
0BFF:  CALL   08D
0C00:  BSF    0A.3
....................  lcd_data("OUTPUT POWER:"); 
0C01:  MOVLW  3D
0C02:  BSF    03.6
0C03:  MOVWF  0D
0C04:  MOVLW  00
0C05:  MOVWF  0F
0C06:  BCF    0A.3
0C07:  BCF    03.6
0C08:  CALL   0AA
0C09:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0C0A:  MOVLW  03
0C0B:  MOVWF  65
0C0C:  BCF    0A.3
0C0D:  CALL   100
0C0E:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pbattery); 
0C0F:  MOVLW  89
0C10:  MOVWF  04
0C11:  MOVF   41,W
0C12:  MOVWF  68
0C13:  MOVF   40,W
0C14:  MOVWF  67
0C15:  MOVF   3F,W
0C16:  MOVWF  66
0C17:  MOVF   3E,W
0C18:  MOVWF  65
0C19:  MOVLW  02
0C1A:  MOVWF  69
0C1B:  BCF    0A.3
0C1C:  CALL   49E
0C1D:  BSF    0A.3
0C1E:  MOVLW  20
0C1F:  MOVWF  72
0C20:  BCF    0A.3
0C21:  CALL   093
0C22:  BSF    0A.3
0C23:  MOVLW  57
0C24:  MOVWF  72
0C25:  BCF    0A.3
0C26:  CALL   093
0C27:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0C28:  MOVLW  04
0C29:  MOVWF  65
0C2A:  MOVLW  FA
0C2B:  MOVWF  68
0C2C:  BCF    0A.3
0C2D:  CALL   04C
0C2E:  BSF    0A.3
0C2F:  DECFSZ 65,F
0C30:  GOTO   42A
.................... lcd_rscrol(20); 
0C31:  MOVLW  14
0C32:  MOVWF  65
0C33:  BCF    0A.3
0C34:  CALL   106
0C35:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0C36:  MOVLW  01
0C37:  MOVWF  67
0C38:  BCF    0A.3
0C39:  CALL   060
0C3A:  BSF    0A.3
....................  delay_ms(50); 
0C3B:  MOVLW  32
0C3C:  MOVWF  68
0C3D:  BCF    0A.3
0C3E:  CALL   04C
0C3F:  BSF    0A.3
....................  
.................... dutycycle=(pwm/20)*100; 
0C40:  MOVF   4F,W
0C41:  MOVWF  6B
0C42:  MOVLW  14
0C43:  MOVWF  6C
0C44:  BCF    0A.3
0C45:  CALL   57E
0C46:  BSF    0A.3
0C47:  MOVF   78,W
0C48:  MOVWF  66
0C49:  MOVLW  64
0C4A:  MOVWF  67
0C4B:  BCF    0A.3
0C4C:  GOTO   593
0C4D:  BSF    0A.3
0C4E:  MOVF   78,W
0C4F:  MOVWF  4E
....................  
.................... lcd_line1(0); 
0C50:  CLRF   65
0C51:  BCF    0A.3
0C52:  CALL   08D
0C53:  BSF    0A.3
.................... printf(lcd_data,"DUTY CYCLE: %d ",dutycycle); 
0C54:  MOVLW  44
0C55:  BSF    03.6
0C56:  MOVWF  0D
0C57:  MOVLW  00
0C58:  MOVWF  0F
0C59:  BCF    03.0
0C5A:  MOVLW  0C
0C5B:  BCF    03.6
0C5C:  MOVWF  65
0C5D:  BCF    0A.3
0C5E:  CALL   3F6
0C5F:  BSF    0A.3
0C60:  MOVF   4E,W
0C61:  MOVWF  65
0C62:  MOVLW  18
0C63:  MOVWF  66
0C64:  BCF    0A.3
0C65:  GOTO   5BA
0C66:  BSF    0A.3
0C67:  MOVLW  20
0C68:  MOVWF  72
0C69:  BCF    0A.3
0C6A:  CALL   093
0C6B:  BSF    0A.3
....................  
.................... delay_ms(1000); 
0C6C:  MOVLW  04
0C6D:  MOVWF  65
0C6E:  MOVLW  FA
0C6F:  MOVWF  68
0C70:  BCF    0A.3
0C71:  CALL   04C
0C72:  BSF    0A.3
0C73:  DECFSZ 65,F
0C74:  GOTO   46E
.................... lcd_rscrol(20); 
0C75:  MOVLW  14
0C76:  MOVWF  65
0C77:  BCF    0A.3
0C78:  CALL   106
0C79:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0C7A:  MOVLW  01
0C7B:  MOVWF  67
0C7C:  BCF    0A.3
0C7D:  CALL   060
0C7E:  BSF    0A.3
....................  delay_ms(50); 
0C7F:  MOVLW  32
0C80:  MOVWF  68
0C81:  BCF    0A.3
0C82:  CALL   04C
0C83:  BSF    0A.3
....................  
.................... float delta_P=Psolar-PrevPsolar;  
.................... float delta_V=Vsolar-PrevVsolar;  
.................... float delta_I=Isolar-PrevIsolar; 
.................... float gradient=delta_P/delta_V;  
0C84:  BSF    03.1
0C85:  MOVF   35,W
0C86:  MOVWF  6C
0C87:  MOVF   34,W
0C88:  MOVWF  6B
0C89:  MOVF   33,W
0C8A:  MOVWF  6A
0C8B:  MOVF   32,W
0C8C:  MOVWF  69
0C8D:  MOVF   4D,W
0C8E:  MOVWF  70
0C8F:  MOVF   4C,W
0C90:  MOVWF  6F
0C91:  MOVF   4B,W
0C92:  MOVWF  6E
0C93:  MOVF   4A,W
0C94:  MOVWF  6D
0C95:  BCF    0A.3
0C96:  CALL   285
0C97:  BSF    0A.3
0C98:  MOVF   7A,W
0C99:  MOVWF  58
0C9A:  MOVF   79,W
0C9B:  MOVWF  57
0C9C:  MOVF   78,W
0C9D:  MOVWF  56
0C9E:  MOVF   77,W
0C9F:  MOVWF  55
0CA0:  BSF    03.1
0CA1:  MOVF   2D,W
0CA2:  MOVWF  6C
0CA3:  MOVF   2C,W
0CA4:  MOVWF  6B
0CA5:  MOVF   2B,W
0CA6:  MOVWF  6A
0CA7:  MOVF   2A,W
0CA8:  MOVWF  69
0CA9:  MOVF   45,W
0CAA:  MOVWF  70
0CAB:  MOVF   44,W
0CAC:  MOVWF  6F
0CAD:  MOVF   43,W
0CAE:  MOVWF  6E
0CAF:  MOVF   42,W
0CB0:  MOVWF  6D
0CB1:  BCF    0A.3
0CB2:  CALL   285
0CB3:  BSF    0A.3
0CB4:  MOVF   7A,W
0CB5:  MOVWF  5C
0CB6:  MOVF   79,W
0CB7:  MOVWF  5B
0CB8:  MOVF   78,W
0CB9:  MOVWF  5A
0CBA:  MOVF   77,W
0CBB:  MOVWF  59
0CBC:  BSF    03.1
0CBD:  MOVF   31,W
0CBE:  MOVWF  6C
0CBF:  MOVF   30,W
0CC0:  MOVWF  6B
0CC1:  MOVF   2F,W
0CC2:  MOVWF  6A
0CC3:  MOVF   2E,W
0CC4:  MOVWF  69
0CC5:  MOVF   49,W
0CC6:  MOVWF  70
0CC7:  MOVF   48,W
0CC8:  MOVWF  6F
0CC9:  MOVF   47,W
0CCA:  MOVWF  6E
0CCB:  MOVF   46,W
0CCC:  MOVWF  6D
0CCD:  BCF    0A.3
0CCE:  CALL   285
0CCF:  BSF    0A.3
0CD0:  MOVF   7A,W
0CD1:  MOVWF  60
0CD2:  MOVF   79,W
0CD3:  MOVWF  5F
0CD4:  MOVF   78,W
0CD5:  MOVWF  5E
0CD6:  MOVF   77,W
0CD7:  MOVWF  5D
0CD8:  MOVF   58,W
0CD9:  MOVWF  6C
0CDA:  MOVF   57,W
0CDB:  MOVWF  6B
0CDC:  MOVF   56,W
0CDD:  MOVWF  6A
0CDE:  MOVF   55,W
0CDF:  MOVWF  69
0CE0:  MOVF   5C,W
0CE1:  MOVWF  70
0CE2:  MOVF   5B,W
0CE3:  MOVWF  6F
0CE4:  MOVF   5A,W
0CE5:  MOVWF  6E
0CE6:  MOVF   59,W
0CE7:  MOVWF  6D
0CE8:  BCF    0A.3
0CE9:  CALL   1BB
0CEA:  BSF    0A.3
0CEB:  MOVF   7A,W
0CEC:  MOVWF  64
0CED:  MOVF   79,W
0CEE:  MOVWF  63
0CEF:  MOVF   78,W
0CF0:  MOVWF  62
0CF1:  MOVF   77,W
0CF2:  MOVWF  61
....................  
.................... if(delta_V!=0) 
0CF3:  MOVF   5C,W
0CF4:  MOVWF  68
0CF5:  MOVF   5B,W
0CF6:  MOVWF  67
0CF7:  MOVF   5A,W
0CF8:  MOVWF  66
0CF9:  MOVF   59,W
0CFA:  MOVWF  65
0CFB:  CLRF   6C
0CFC:  CLRF   6B
0CFD:  CLRF   6A
0CFE:  CLRF   69
0CFF:  BCF    0A.3
0D00:  CALL   613
0D01:  BSF    0A.3
0D02:  BTFSC  03.2
0D03:  GOTO   633
.................... {  
.................... if(gradient>0) 
0D04:  CLRF   68
0D05:  CLRF   67
0D06:  CLRF   66
0D07:  CLRF   65
0D08:  MOVF   64,W
0D09:  MOVWF  6C
0D0A:  MOVF   63,W
0D0B:  MOVWF  6B
0D0C:  MOVF   62,W
0D0D:  MOVWF  6A
0D0E:  MOVF   61,W
0D0F:  MOVWF  69
0D10:  BCF    0A.3
0D11:  CALL   613
0D12:  BSF    0A.3
0D13:  BTFSS  03.0
0D14:  GOTO   550
.................... {  
.................... pwm+=delta;  
0D15:  MOVF   52,W
0D16:  ADDWF  4F,F
.................... PrevPsolar=Psolar; 
0D17:  MOVF   35,W
0D18:  MOVWF  4D
0D19:  MOVF   34,W
0D1A:  MOVWF  4C
0D1B:  MOVF   33,W
0D1C:  MOVWF  4B
0D1D:  MOVF   32,W
0D1E:  MOVWF  4A
.................... PrevVsolar=Vsolar;  
0D1F:  MOVF   2D,W
0D20:  MOVWF  45
0D21:  MOVF   2C,W
0D22:  MOVWF  44
0D23:  MOVF   2B,W
0D24:  MOVWF  43
0D25:  MOVF   2A,W
0D26:  MOVWF  42
.................... PrevIsolar=Isolar;  
0D27:  MOVF   31,W
0D28:  MOVWF  49
0D29:  MOVF   30,W
0D2A:  MOVWF  48
0D2B:  MOVF   2F,W
0D2C:  MOVWF  47
0D2D:  MOVF   2E,W
0D2E:  MOVWF  46
.................... if (pwm<pwm_min) 
0D2F:  MOVF   50,W
0D30:  SUBWF  4F,W
0D31:  BTFSC  03.0
0D32:  GOTO   538
.................... { 
.................... pwm=pwm_min; 
0D33:  MOVF   50,W
0D34:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0D35:  MOVF   4F,W
0D36:  MOVWF  15
.................... } 
0D37:  GOTO   54F
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0D38:  MOVF   4F,W
0D39:  SUBWF  51,W
0D3A:  BTFSS  03.0
0D3B:  GOTO   540
0D3C:  MOVF   51,W
0D3D:  SUBWF  4F,W
0D3E:  BTFSS  03.2
0D3F:  GOTO   545
.................... { 
.................... pwm=pwm_max; 
0D40:  MOVF   51,W
0D41:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0D42:  MOVF   4F,W
0D43:  MOVWF  15
.................... } 
0D44:  GOTO   54F
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0D45:  MOVF   51,W
0D46:  SUBWF  4F,W
0D47:  BTFSC  03.0
0D48:  GOTO   54F
0D49:  MOVF   4F,W
0D4A:  SUBWF  50,W
0D4B:  BTFSC  03.0
0D4C:  GOTO   54F
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0D4D:  MOVF   4F,W
0D4E:  MOVWF  15
.................... } 
.................... } 
0D4F:  GOTO   633
.................... else if(gradient<0) 
0D50:  MOVF   64,W
0D51:  MOVWF  68
0D52:  MOVF   63,W
0D53:  MOVWF  67
0D54:  MOVF   62,W
0D55:  MOVWF  66
0D56:  MOVF   61,W
0D57:  MOVWF  65
0D58:  CLRF   6C
0D59:  CLRF   6B
0D5A:  CLRF   6A
0D5B:  CLRF   69
0D5C:  BCF    0A.3
0D5D:  CALL   613
0D5E:  BSF    0A.3
0D5F:  BTFSS  03.0
0D60:  GOTO   59C
.................... {  
.................... pwm-=delta;  
0D61:  MOVF   52,W
0D62:  SUBWF  4F,F
.................... PrevPsolar=Psolar;  
0D63:  MOVF   35,W
0D64:  MOVWF  4D
0D65:  MOVF   34,W
0D66:  MOVWF  4C
0D67:  MOVF   33,W
0D68:  MOVWF  4B
0D69:  MOVF   32,W
0D6A:  MOVWF  4A
.................... PrevVsolar=Vsolar;  
0D6B:  MOVF   2D,W
0D6C:  MOVWF  45
0D6D:  MOVF   2C,W
0D6E:  MOVWF  44
0D6F:  MOVF   2B,W
0D70:  MOVWF  43
0D71:  MOVF   2A,W
0D72:  MOVWF  42
.................... PrevIsolar=Isolar;  
0D73:  MOVF   31,W
0D74:  MOVWF  49
0D75:  MOVF   30,W
0D76:  MOVWF  48
0D77:  MOVF   2F,W
0D78:  MOVWF  47
0D79:  MOVF   2E,W
0D7A:  MOVWF  46
.................... if (pwm<pwm_min) 
0D7B:  MOVF   50,W
0D7C:  SUBWF  4F,W
0D7D:  BTFSC  03.0
0D7E:  GOTO   584
.................... { 
.................... pwm=pwm_min; 
0D7F:  MOVF   50,W
0D80:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0D81:  MOVF   4F,W
0D82:  MOVWF  15
.................... } 
0D83:  GOTO   59B
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0D84:  MOVF   4F,W
0D85:  SUBWF  51,W
0D86:  BTFSS  03.0
0D87:  GOTO   58C
0D88:  MOVF   51,W
0D89:  SUBWF  4F,W
0D8A:  BTFSS  03.2
0D8B:  GOTO   591
.................... { 
.................... pwm=pwm_max; 
0D8C:  MOVF   51,W
0D8D:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0D8E:  MOVF   4F,W
0D8F:  MOVWF  15
.................... } 
0D90:  GOTO   59B
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0D91:  MOVF   51,W
0D92:  SUBWF  4F,W
0D93:  BTFSC  03.0
0D94:  GOTO   59B
0D95:  MOVF   4F,W
0D96:  SUBWF  50,W
0D97:  BTFSC  03.0
0D98:  GOTO   59B
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0D99:  MOVF   4F,W
0D9A:  MOVWF  15
.................... } 
.................... }  
0D9B:  GOTO   633
....................  
.................... else  
.................... { 
.................... if(delta_I>0) 
0D9C:  CLRF   68
0D9D:  CLRF   67
0D9E:  CLRF   66
0D9F:  CLRF   65
0DA0:  MOVF   60,W
0DA1:  MOVWF  6C
0DA2:  MOVF   5F,W
0DA3:  MOVWF  6B
0DA4:  MOVF   5E,W
0DA5:  MOVWF  6A
0DA6:  MOVF   5D,W
0DA7:  MOVWF  69
0DA8:  BCF    0A.3
0DA9:  CALL   613
0DAA:  BSF    0A.3
0DAB:  BTFSS  03.0
0DAC:  GOTO   5E8
.................... {  
.................... pwm+=delta;  
0DAD:  MOVF   52,W
0DAE:  ADDWF  4F,F
.................... PrevPsolar=Psolar;  
0DAF:  MOVF   35,W
0DB0:  MOVWF  4D
0DB1:  MOVF   34,W
0DB2:  MOVWF  4C
0DB3:  MOVF   33,W
0DB4:  MOVWF  4B
0DB5:  MOVF   32,W
0DB6:  MOVWF  4A
.................... PrevVsolar=Vsolar;  
0DB7:  MOVF   2D,W
0DB8:  MOVWF  45
0DB9:  MOVF   2C,W
0DBA:  MOVWF  44
0DBB:  MOVF   2B,W
0DBC:  MOVWF  43
0DBD:  MOVF   2A,W
0DBE:  MOVWF  42
.................... PrevIsolar=Isolar; 
0DBF:  MOVF   31,W
0DC0:  MOVWF  49
0DC1:  MOVF   30,W
0DC2:  MOVWF  48
0DC3:  MOVF   2F,W
0DC4:  MOVWF  47
0DC5:  MOVF   2E,W
0DC6:  MOVWF  46
.................... if (pwm<pwm_min) 
0DC7:  MOVF   50,W
0DC8:  SUBWF  4F,W
0DC9:  BTFSC  03.0
0DCA:  GOTO   5D0
.................... { 
.................... pwm=pwm_min; 
0DCB:  MOVF   50,W
0DCC:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0DCD:  MOVF   4F,W
0DCE:  MOVWF  15
.................... } 
0DCF:  GOTO   5E7
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0DD0:  MOVF   4F,W
0DD1:  SUBWF  51,W
0DD2:  BTFSS  03.0
0DD3:  GOTO   5D8
0DD4:  MOVF   51,W
0DD5:  SUBWF  4F,W
0DD6:  BTFSS  03.2
0DD7:  GOTO   5DD
.................... { 
.................... pwm=pwm_max; 
0DD8:  MOVF   51,W
0DD9:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0DDA:  MOVF   4F,W
0DDB:  MOVWF  15
.................... } 
0DDC:  GOTO   5E7
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0DDD:  MOVF   51,W
0DDE:  SUBWF  4F,W
0DDF:  BTFSC  03.0
0DE0:  GOTO   5E7
0DE1:  MOVF   4F,W
0DE2:  SUBWF  50,W
0DE3:  BTFSC  03.0
0DE4:  GOTO   5E7
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0DE5:  MOVF   4F,W
0DE6:  MOVWF  15
.................... } 
.................... } 
0DE7:  GOTO   633
....................  
.................... else if(delta_I<0) 
0DE8:  MOVF   60,W
0DE9:  MOVWF  68
0DEA:  MOVF   5F,W
0DEB:  MOVWF  67
0DEC:  MOVF   5E,W
0DED:  MOVWF  66
0DEE:  MOVF   5D,W
0DEF:  MOVWF  65
0DF0:  CLRF   6C
0DF1:  CLRF   6B
0DF2:  CLRF   6A
0DF3:  CLRF   69
0DF4:  BCF    0A.3
0DF5:  CALL   613
0DF6:  BSF    0A.3
0DF7:  BTFSS  03.0
0DF8:  GOTO   633
.................... {  
.................... pwm-=delta;  
0DF9:  MOVF   52,W
0DFA:  SUBWF  4F,F
.................... PrevPsolar=Psolar;  
0DFB:  MOVF   35,W
0DFC:  MOVWF  4D
0DFD:  MOVF   34,W
0DFE:  MOVWF  4C
0DFF:  MOVF   33,W
0E00:  MOVWF  4B
0E01:  MOVF   32,W
0E02:  MOVWF  4A
.................... PrevVsolar=Vsolar;  
0E03:  MOVF   2D,W
0E04:  MOVWF  45
0E05:  MOVF   2C,W
0E06:  MOVWF  44
0E07:  MOVF   2B,W
0E08:  MOVWF  43
0E09:  MOVF   2A,W
0E0A:  MOVWF  42
.................... PrevIsolar=Isolar; 
0E0B:  MOVF   31,W
0E0C:  MOVWF  49
0E0D:  MOVF   30,W
0E0E:  MOVWF  48
0E0F:  MOVF   2F,W
0E10:  MOVWF  47
0E11:  MOVF   2E,W
0E12:  MOVWF  46
.................... if (pwm<pwm_min) 
0E13:  MOVF   50,W
0E14:  SUBWF  4F,W
0E15:  BTFSC  03.0
0E16:  GOTO   61C
.................... { 
.................... pwm=pwm_min; 
0E17:  MOVF   50,W
0E18:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0E19:  MOVF   4F,W
0E1A:  MOVWF  15
.................... } 
0E1B:  GOTO   633
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0E1C:  MOVF   4F,W
0E1D:  SUBWF  51,W
0E1E:  BTFSS  03.0
0E1F:  GOTO   624
0E20:  MOVF   51,W
0E21:  SUBWF  4F,W
0E22:  BTFSS  03.2
0E23:  GOTO   629
.................... { 
.................... pwm=pwm_max; 
0E24:  MOVF   51,W
0E25:  MOVWF  4F
.................... set_pwm1_duty(pwm); 
0E26:  MOVF   4F,W
0E27:  MOVWF  15
.................... } 
0E28:  GOTO   633
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0E29:  MOVF   51,W
0E2A:  SUBWF  4F,W
0E2B:  BTFSC  03.0
0E2C:  GOTO   633
0E2D:  MOVF   4F,W
0E2E:  SUBWF  50,W
0E2F:  BTFSC  03.0
0E30:  GOTO   633
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0E31:  MOVF   4F,W
0E32:  MOVWF  15
.................... } 
.................... } 
.................... } 
.................... } 
0E33:  GOTO   0B3
.................... } 
.................... } 
0E34:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
