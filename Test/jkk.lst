CCS PCM C Compiler, Version 5.015, 5967               08-May-19 16:18

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\Test\jkk.lst

               ROM used:   2609 words (32%)
                           Largest free fragment is 2048
               RAM used:   44 (12%) at main() level
                           67 (18%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include<16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  DATA 50,2B
0005:  DATA 20,23
0006:  DATA 65,32
0007:  DATA 20,00
0008:  DATA C3,37
0009:  DATA 6E,3B
000A:  DATA 65,39
000B:  DATA F3,34
000C:  DATA 6F,37
000D:  DATA A0,2B
000E:  DATA 69,3A
000F:  DATA 68,00
0010:  DATA 45,3C
0011:  DATA E9,39
0012:  DATA F4,34
0013:  DATA EE,33
0014:  DATA A0,2A
0015:  DATA D0,29
0016:  DATA 00,01
0017:  DATA CD,30
0018:  DATA E4,32
0019:  DATA 20,31
001A:  DATA 79,1D
001B:  DATA 00,01
001C:  DATA C6,30
001D:  DATA 69,3D
001E:  DATA 61,37
001F:  DATA AC,29
0020:  DATA E8,30
0021:  DATA EB,34
0022:  DATA 72,00
0023:  DATA CD,30
0024:  DATA E4,32
0025:  DATA 20,31
0026:  DATA 79,1D
0027:  DATA 00,01
0028:  DATA 41,37
0029:  DATA 64,10
002A:  DATA C8,30
002B:  DATA 6D,3D
002C:  DATA 61,00
002D:  DATA D6,27
002E:  DATA 4C,2A
002F:  DATA C1,23
0030:  DATA 45,1D
0031:  DATA 25,33
0032:  DATA 20,2B
0033:  DATA 00,00
0034:  DATA C3,2A
0035:  DATA 52,29
0036:  DATA 45,27
0037:  DATA 54,1D
0038:  DATA A0,12
0039:  DATA 66,10
003A:  DATA 41,00
003B:  DATA 49,27
003C:  DATA D0,2A
003D:  DATA 54,10
003E:  DATA D0,27
003F:  DATA D7,22
0040:  DATA 52,1D
0041:  DATA 00,01
0042:  DATA D6,27
0043:  DATA 4C,2A
0044:  DATA C1,23
0045:  DATA 45,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 56,00
0049:  DATA C3,2A
004A:  DATA 52,29
004B:  DATA 45,27
004C:  DATA 54,1D
004D:  DATA A0,12
004E:  DATA 66,10
004F:  DATA 41,00
0050:  DATA CF,2A
0051:  DATA 54,28
0052:  DATA 55,2A
0053:  DATA 20,28
0054:  DATA CF,2B
0055:  DATA 45,29
0056:  DATA 3A,00
*
00B5:  MOVF   0B,W
00B6:  MOVWF  44
00B7:  BCF    0B.7
00B8:  BSF    03.5
00B9:  BSF    03.6
00BA:  BSF    0C.7
00BB:  BSF    0C.0
00BC:  NOP
00BD:  NOP
00BE:  BCF    03.5
00BF:  BCF    03.6
00C0:  BTFSC  44.7
00C1:  BSF    0B.7
00C2:  BSF    03.6
00C3:  MOVF   0C,W
00C4:  ANDLW  7F
00C5:  BTFSC  03.2
00C6:  GOTO   109
00C7:  BCF    03.6
00C8:  MOVWF  44
00C9:  BSF    03.6
00CA:  MOVF   0D,W
00CB:  BCF    03.6
00CC:  MOVWF  45
00CD:  BSF    03.6
00CE:  MOVF   0F,W
00CF:  BCF    03.6
00D0:  MOVWF  46
00D1:  MOVF   44,W
00D2:  MOVWF  51
00D3:  CALL   09E
00D4:  MOVF   45,W
00D5:  BSF    03.6
00D6:  MOVWF  0D
00D7:  BCF    03.6
00D8:  MOVF   46,W
00D9:  BSF    03.6
00DA:  MOVWF  0F
00DB:  BCF    03.6
00DC:  MOVF   0B,W
00DD:  MOVWF  47
00DE:  BCF    0B.7
00DF:  BSF    03.5
00E0:  BSF    03.6
00E1:  BSF    0C.7
00E2:  BSF    0C.0
00E3:  NOP
00E4:  NOP
00E5:  BCF    03.5
00E6:  BCF    03.6
00E7:  BTFSC  47.7
00E8:  BSF    0B.7
00E9:  BSF    03.6
00EA:  RLF    0C,W
00EB:  RLF    0E,W
00EC:  ANDLW  7F
00ED:  BTFSC  03.2
00EE:  GOTO   109
00EF:  BCF    03.6
00F0:  MOVWF  44
00F1:  BSF    03.6
00F2:  MOVF   0D,W
00F3:  BCF    03.6
00F4:  MOVWF  45
00F5:  BSF    03.6
00F6:  MOVF   0F,W
00F7:  BCF    03.6
00F8:  MOVWF  46
00F9:  MOVF   44,W
00FA:  MOVWF  51
00FB:  CALL   09E
00FC:  MOVF   45,W
00FD:  BSF    03.6
00FE:  MOVWF  0D
00FF:  BCF    03.6
0100:  MOVF   46,W
0101:  BSF    03.6
0102:  MOVWF  0F
0103:  INCF   0D,F
0104:  BTFSC  03.2
0105:  INCF   0F,F
0106:  BCF    03.6
0107:  GOTO   0B5
0108:  BSF    03.6
0109:  BCF    03.6
010A:  RETURN
*
0123:  MOVLW  8E
0124:  MOVWF  77
0125:  MOVF   45,W
0126:  MOVWF  78
0127:  MOVF   44,W
0128:  MOVWF  79
0129:  CLRF   7A
012A:  MOVF   78,F
012B:  BTFSS  03.2
012C:  GOTO   137
012D:  MOVF   79,W
012E:  MOVWF  78
012F:  CLRF   79
0130:  MOVLW  08
0131:  SUBWF  77,F
0132:  MOVF   78,F
0133:  BTFSS  03.2
0134:  GOTO   137
0135:  CLRF   77
0136:  GOTO   13F
0137:  BCF    03.0
0138:  BTFSC  78.7
0139:  GOTO   13E
013A:  RLF    79,F
013B:  RLF    78,F
013C:  DECF   77,F
013D:  GOTO   137
013E:  BCF    78.7
013F:  RETURN
0140:  MOVF   51,W
0141:  BTFSC  03.2
0142:  GOTO   1B0
0143:  MOVWF  59
0144:  MOVF   55,W
0145:  BTFSC  03.2
0146:  GOTO   1B0
0147:  ADDWF  59,F
0148:  BTFSC  03.0
0149:  GOTO   151
014A:  MOVLW  7F
014B:  SUBWF  59,F
014C:  BTFSS  03.0
014D:  GOTO   1B0
014E:  BTFSC  03.2
014F:  GOTO   1B0
0150:  GOTO   155
0151:  MOVLW  81
0152:  ADDWF  59,F
0153:  BTFSC  03.0
0154:  GOTO   1B0
0155:  MOVF   59,W
0156:  MOVWF  77
0157:  CLRF   78
0158:  CLRF   79
0159:  CLRF   7A
015A:  MOVF   52,W
015B:  MOVWF  5D
015C:  BSF    5D.7
015D:  MOVF   53,W
015E:  MOVWF  5C
015F:  MOVF   54,W
0160:  MOVWF  5B
0161:  MOVLW  18
0162:  MOVWF  59
0163:  CLRF   5A
0164:  BTFSS  5B.0
0165:  GOTO   17E
0166:  MOVF   58,W
0167:  ADDWF  7A,F
0168:  BTFSS  03.0
0169:  GOTO   170
016A:  INCF   79,F
016B:  BTFSS  03.2
016C:  GOTO   170
016D:  INCF   78,F
016E:  BTFSC  03.2
016F:  BSF    5A.7
0170:  MOVF   57,W
0171:  ADDWF  79,F
0172:  BTFSS  03.0
0173:  GOTO   177
0174:  INCF   78,F
0175:  BTFSC  03.2
0176:  BSF    5A.7
0177:  MOVF   56,W
0178:  MOVWF  53
0179:  BSF    53.7
017A:  MOVF   53,W
017B:  ADDWF  78,F
017C:  BTFSC  03.0
017D:  BSF    5A.7
017E:  RLF    5A,F
017F:  RRF    78,F
0180:  RRF    79,F
0181:  RRF    7A,F
0182:  RRF    5D,F
0183:  RRF    5C,F
0184:  RRF    5B,F
0185:  BCF    03.0
0186:  DECFSZ 59,F
0187:  GOTO   163
0188:  MOVLW  01
0189:  ADDWF  77,F
018A:  BTFSC  03.0
018B:  GOTO   1B0
018C:  BTFSC  78.7
018D:  GOTO   195
018E:  RLF    5D,F
018F:  RLF    7A,F
0190:  RLF    79,F
0191:  RLF    78,F
0192:  DECF   77,F
0193:  BTFSC  03.2
0194:  GOTO   1B0
0195:  BTFSS  5D.7
0196:  GOTO   1A6
0197:  INCF   7A,F
0198:  BTFSS  03.2
0199:  GOTO   1A6
019A:  INCF   79,F
019B:  BTFSS  03.2
019C:  GOTO   1A6
019D:  INCF   78,F
019E:  BTFSS  03.2
019F:  GOTO   1A6
01A0:  RRF    78,F
01A1:  RRF    79,F
01A2:  RRF    7A,F
01A3:  INCF   77,F
01A4:  BTFSC  03.2
01A5:  GOTO   1B0
01A6:  MOVF   52,W
01A7:  MOVWF  5A
01A8:  MOVF   56,W
01A9:  XORWF  5A,F
01AA:  BTFSS  5A.7
01AB:  GOTO   1AE
01AC:  BSF    78.7
01AD:  GOTO   1B4
01AE:  BCF    78.7
01AF:  GOTO   1B4
01B0:  CLRF   77
01B1:  CLRF   78
01B2:  CLRF   79
01B3:  CLRF   7A
01B4:  RETURN
01B5:  MOVF   48,W
01B6:  BTFSC  03.2
01B7:  GOTO   27A
01B8:  MOVWF  54
01B9:  MOVF   4C,W
01BA:  BTFSC  03.2
01BB:  GOTO   27A
01BC:  SUBWF  54,F
01BD:  BTFSS  03.0
01BE:  GOTO   1C4
01BF:  MOVLW  7F
01C0:  ADDWF  54,F
01C1:  BTFSC  03.0
01C2:  GOTO   27A
01C3:  GOTO   1CA
01C4:  MOVLW  81
01C5:  SUBWF  54,F
01C6:  BTFSS  03.0
01C7:  GOTO   27A
01C8:  BTFSC  03.2
01C9:  GOTO   27A
01CA:  MOVF   54,W
01CB:  MOVWF  77
01CC:  CLRF   78
01CD:  CLRF   79
01CE:  CLRF   7A
01CF:  CLRF   53
01D0:  MOVF   49,W
01D1:  MOVWF  52
01D2:  BSF    52.7
01D3:  MOVF   4A,W
01D4:  MOVWF  51
01D5:  MOVF   4B,W
01D6:  MOVWF  50
01D7:  MOVLW  19
01D8:  MOVWF  54
01D9:  MOVF   4F,W
01DA:  SUBWF  50,F
01DB:  BTFSC  03.0
01DC:  GOTO   1ED
01DD:  MOVLW  01
01DE:  SUBWF  51,F
01DF:  BTFSC  03.0
01E0:  GOTO   1ED
01E1:  SUBWF  52,F
01E2:  BTFSC  03.0
01E3:  GOTO   1ED
01E4:  SUBWF  53,F
01E5:  BTFSC  03.0
01E6:  GOTO   1ED
01E7:  INCF   53,F
01E8:  INCF   52,F
01E9:  INCF   51,F
01EA:  MOVF   4F,W
01EB:  ADDWF  50,F
01EC:  GOTO   21F
01ED:  MOVF   4E,W
01EE:  SUBWF  51,F
01EF:  BTFSC  03.0
01F0:  GOTO   208
01F1:  MOVLW  01
01F2:  SUBWF  52,F
01F3:  BTFSC  03.0
01F4:  GOTO   208
01F5:  SUBWF  53,F
01F6:  BTFSC  03.0
01F7:  GOTO   208
01F8:  INCF   53,F
01F9:  INCF   52,F
01FA:  MOVF   4E,W
01FB:  ADDWF  51,F
01FC:  MOVF   4F,W
01FD:  ADDWF  50,F
01FE:  BTFSS  03.0
01FF:  GOTO   21F
0200:  INCF   51,F
0201:  BTFSS  03.2
0202:  GOTO   21F
0203:  INCF   52,F
0204:  BTFSS  03.2
0205:  GOTO   21F
0206:  INCF   53,F
0207:  GOTO   21F
0208:  MOVF   4D,W
0209:  IORLW  80
020A:  SUBWF  52,F
020B:  BTFSC  03.0
020C:  GOTO   21E
020D:  MOVLW  01
020E:  SUBWF  53,F
020F:  BTFSC  03.0
0210:  GOTO   21E
0211:  INCF   53,F
0212:  MOVF   4D,W
0213:  IORLW  80
0214:  ADDWF  52,F
0215:  MOVF   4E,W
0216:  ADDWF  51,F
0217:  BTFSS  03.0
0218:  GOTO   1FC
0219:  INCF   52,F
021A:  BTFSS  03.2
021B:  GOTO   1FC
021C:  INCF   53,F
021D:  GOTO   1FC
021E:  BSF    7A.0
021F:  DECFSZ 54,F
0220:  GOTO   222
0221:  GOTO   22D
0222:  BCF    03.0
0223:  RLF    50,F
0224:  RLF    51,F
0225:  RLF    52,F
0226:  RLF    53,F
0227:  BCF    03.0
0228:  RLF    7A,F
0229:  RLF    79,F
022A:  RLF    78,F
022B:  RLF    55,F
022C:  GOTO   1D9
022D:  BTFSS  55.0
022E:  GOTO   235
022F:  BCF    03.0
0230:  RRF    78,F
0231:  RRF    79,F
0232:  RRF    7A,F
0233:  RRF    55,F
0234:  GOTO   238
0235:  DECF   77,F
0236:  BTFSC  03.2
0237:  GOTO   27A
0238:  BTFSC  55.7
0239:  GOTO   261
023A:  BCF    03.0
023B:  RLF    50,F
023C:  RLF    51,F
023D:  RLF    52,F
023E:  RLF    53,F
023F:  MOVF   4F,W
0240:  SUBWF  50,F
0241:  BTFSC  03.0
0242:  GOTO   24D
0243:  MOVLW  01
0244:  SUBWF  51,F
0245:  BTFSC  03.0
0246:  GOTO   24D
0247:  SUBWF  52,F
0248:  BTFSC  03.0
0249:  GOTO   24D
024A:  SUBWF  53,F
024B:  BTFSS  03.0
024C:  GOTO   270
024D:  MOVF   4E,W
024E:  SUBWF  51,F
024F:  BTFSC  03.0
0250:  GOTO   258
0251:  MOVLW  01
0252:  SUBWF  52,F
0253:  BTFSC  03.0
0254:  GOTO   258
0255:  SUBWF  53,F
0256:  BTFSS  03.0
0257:  GOTO   270
0258:  MOVF   4D,W
0259:  IORLW  80
025A:  SUBWF  52,F
025B:  BTFSC  03.0
025C:  GOTO   261
025D:  MOVLW  01
025E:  SUBWF  53,F
025F:  BTFSS  03.0
0260:  GOTO   270
0261:  INCF   7A,F
0262:  BTFSS  03.2
0263:  GOTO   270
0264:  INCF   79,F
0265:  BTFSS  03.2
0266:  GOTO   270
0267:  INCF   78,F
0268:  BTFSS  03.2
0269:  GOTO   270
026A:  INCF   77,F
026B:  BTFSC  03.2
026C:  GOTO   27A
026D:  RRF    78,F
026E:  RRF    79,F
026F:  RRF    7A,F
0270:  MOVF   49,W
0271:  MOVWF  54
0272:  MOVF   4D,W
0273:  XORWF  54,F
0274:  BTFSS  54.7
0275:  GOTO   278
0276:  BSF    78.7
0277:  GOTO   27E
0278:  BCF    78.7
0279:  GOTO   27E
027A:  CLRF   77
027B:  CLRF   78
027C:  CLRF   79
027D:  CLRF   7A
027E:  RETURN
027F:  MOVLW  80
0280:  BTFSC  03.1
0281:  XORWF  4D,F
0282:  CLRF   52
0283:  CLRF   53
0284:  MOVF   49,W
0285:  MOVWF  51
0286:  MOVF   4D,W
0287:  XORWF  51,F
0288:  MOVF   48,W
0289:  BTFSC  03.2
028A:  GOTO   36F
028B:  MOVWF  50
028C:  MOVWF  77
028D:  MOVF   4C,W
028E:  BTFSC  03.2
028F:  GOTO   378
0290:  SUBWF  50,F
0291:  BTFSC  03.2
0292:  GOTO   314
0293:  BTFSS  03.0
0294:  GOTO   2D2
0295:  MOVF   4D,W
0296:  MOVWF  56
0297:  BSF    56.7
0298:  MOVF   4E,W
0299:  MOVWF  55
029A:  MOVF   4F,W
029B:  MOVWF  54
029C:  CLRF   53
029D:  BCF    03.0
029E:  RRF    56,F
029F:  RRF    55,F
02A0:  RRF    54,F
02A1:  RRF    53,F
02A2:  DECFSZ 50,F
02A3:  GOTO   29C
02A4:  BTFSS  51.7
02A5:  GOTO   2A9
02A6:  BSF    52.0
02A7:  GOTO   38C
02A8:  BCF    52.0
02A9:  BCF    50.0
02AA:  BSF    52.4
02AB:  MOVLW  4B
02AC:  MOVWF  04
02AD:  BCF    03.7
02AE:  GOTO   3A1
02AF:  BCF    52.4
02B0:  BTFSC  51.7
02B1:  GOTO   2BC
02B2:  BTFSS  50.0
02B3:  GOTO   2C7
02B4:  RRF    56,F
02B5:  RRF    55,F
02B6:  RRF    54,F
02B7:  RRF    53,F
02B8:  INCF   77,F
02B9:  BTFSC  03.2
02BA:  GOTO   387
02BB:  GOTO   2C7
02BC:  BTFSC  56.7
02BD:  GOTO   2CA
02BE:  BCF    03.0
02BF:  RLF    53,F
02C0:  RLF    54,F
02C1:  RLF    55,F
02C2:  RLF    56,F
02C3:  DECF   77,F
02C4:  BTFSC  03.2
02C5:  GOTO   387
02C6:  GOTO   2BC
02C7:  BSF    52.6
02C8:  GOTO   334
02C9:  BCF    52.6
02CA:  MOVF   49,W
02CB:  MOVWF  51
02CC:  BTFSS  51.7
02CD:  GOTO   2D0
02CE:  BSF    56.7
02CF:  GOTO   380
02D0:  BCF    56.7
02D1:  GOTO   380
02D2:  MOVF   4C,W
02D3:  MOVWF  50
02D4:  MOVWF  77
02D5:  MOVF   48,W
02D6:  SUBWF  50,F
02D7:  MOVF   49,W
02D8:  MOVWF  56
02D9:  BSF    56.7
02DA:  MOVF   4A,W
02DB:  MOVWF  55
02DC:  MOVF   4B,W
02DD:  MOVWF  54
02DE:  CLRF   53
02DF:  BCF    03.0
02E0:  RRF    56,F
02E1:  RRF    55,F
02E2:  RRF    54,F
02E3:  RRF    53,F
02E4:  DECFSZ 50,F
02E5:  GOTO   2DE
02E6:  BTFSS  51.7
02E7:  GOTO   2EB
02E8:  BSF    52.1
02E9:  GOTO   38C
02EA:  BCF    52.1
02EB:  BCF    50.0
02EC:  BSF    52.5
02ED:  MOVLW  4F
02EE:  MOVWF  04
02EF:  BCF    03.7
02F0:  GOTO   3A1
02F1:  BCF    52.5
02F2:  BTFSC  51.7
02F3:  GOTO   2FE
02F4:  BTFSS  50.0
02F5:  GOTO   309
02F6:  RRF    56,F
02F7:  RRF    55,F
02F8:  RRF    54,F
02F9:  RRF    53,F
02FA:  INCF   77,F
02FB:  BTFSC  03.2
02FC:  GOTO   387
02FD:  GOTO   309
02FE:  BTFSC  56.7
02FF:  GOTO   30C
0300:  BCF    03.0
0301:  RLF    53,F
0302:  RLF    54,F
0303:  RLF    55,F
0304:  RLF    56,F
0305:  DECF   77,F
0306:  BTFSC  03.2
0307:  GOTO   387
0308:  GOTO   2FE
0309:  BSF    52.7
030A:  GOTO   334
030B:  BCF    52.7
030C:  MOVF   4D,W
030D:  MOVWF  51
030E:  BTFSS  51.7
030F:  GOTO   312
0310:  BSF    56.7
0311:  GOTO   380
0312:  BCF    56.7
0313:  GOTO   380
0314:  MOVF   4D,W
0315:  MOVWF  56
0316:  BSF    56.7
0317:  MOVF   4E,W
0318:  MOVWF  55
0319:  MOVF   4F,W
031A:  MOVWF  54
031B:  BTFSS  51.7
031C:  GOTO   321
031D:  BCF    56.7
031E:  BSF    52.2
031F:  GOTO   38C
0320:  BCF    52.2
0321:  CLRF   53
0322:  BCF    50.0
0323:  MOVLW  4B
0324:  MOVWF  04
0325:  BCF    03.7
0326:  GOTO   3A1
0327:  BTFSC  51.7
0328:  GOTO   34A
0329:  MOVF   49,W
032A:  MOVWF  51
032B:  BTFSS  50.0
032C:  GOTO   334
032D:  RRF    56,F
032E:  RRF    55,F
032F:  RRF    54,F
0330:  RRF    53,F
0331:  INCF   77,F
0332:  BTFSC  03.2
0333:  GOTO   387
0334:  BTFSS  53.7
0335:  GOTO   345
0336:  INCF   54,F
0337:  BTFSS  03.2
0338:  GOTO   345
0339:  INCF   55,F
033A:  BTFSS  03.2
033B:  GOTO   345
033C:  INCF   56,F
033D:  BTFSS  03.2
033E:  GOTO   345
033F:  RRF    56,F
0340:  RRF    55,F
0341:  RRF    54,F
0342:  INCF   77,F
0343:  BTFSC  03.2
0344:  GOTO   387
0345:  BTFSC  52.6
0346:  GOTO   2C9
0347:  BTFSC  52.7
0348:  GOTO   30B
0349:  GOTO   369
034A:  MOVLW  80
034B:  XORWF  56,F
034C:  BTFSS  56.7
034D:  GOTO   352
034E:  GOTO   38C
034F:  MOVF   4D,W
0350:  MOVWF  51
0351:  GOTO   35F
0352:  MOVF   49,W
0353:  MOVWF  51
0354:  MOVF   56,F
0355:  BTFSS  03.2
0356:  GOTO   35F
0357:  MOVF   55,F
0358:  BTFSS  03.2
0359:  GOTO   35F
035A:  MOVF   54,F
035B:  BTFSS  03.2
035C:  GOTO   35F
035D:  CLRF   77
035E:  GOTO   380
035F:  BTFSC  56.7
0360:  GOTO   369
0361:  BCF    03.0
0362:  RLF    53,F
0363:  RLF    54,F
0364:  RLF    55,F
0365:  RLF    56,F
0366:  DECFSZ 77,F
0367:  GOTO   35F
0368:  GOTO   387
0369:  BTFSS  51.7
036A:  GOTO   36D
036B:  BSF    56.7
036C:  GOTO   380
036D:  BCF    56.7
036E:  GOTO   380
036F:  MOVF   4C,W
0370:  MOVWF  77
0371:  MOVF   4D,W
0372:  MOVWF  56
0373:  MOVF   4E,W
0374:  MOVWF  55
0375:  MOVF   4F,W
0376:  MOVWF  54
0377:  GOTO   380
0378:  MOVF   48,W
0379:  MOVWF  77
037A:  MOVF   49,W
037B:  MOVWF  56
037C:  MOVF   4A,W
037D:  MOVWF  55
037E:  MOVF   4B,W
037F:  MOVWF  54
0380:  MOVF   56,W
0381:  MOVWF  78
0382:  MOVF   55,W
0383:  MOVWF  79
0384:  MOVF   54,W
0385:  MOVWF  7A
0386:  GOTO   3BF
0387:  CLRF   77
0388:  CLRF   78
0389:  CLRF   79
038A:  CLRF   7A
038B:  GOTO   3BF
038C:  CLRF   53
038D:  COMF   54,F
038E:  COMF   55,F
038F:  COMF   56,F
0390:  COMF   53,F
0391:  INCF   53,F
0392:  BTFSS  03.2
0393:  GOTO   39A
0394:  INCF   54,F
0395:  BTFSS  03.2
0396:  GOTO   39A
0397:  INCF   55,F
0398:  BTFSC  03.2
0399:  INCF   56,F
039A:  BTFSC  52.0
039B:  GOTO   2A8
039C:  BTFSC  52.1
039D:  GOTO   2EA
039E:  BTFSC  52.2
039F:  GOTO   320
03A0:  GOTO   34F
03A1:  MOVF   00,W
03A2:  ADDWF  54,F
03A3:  BTFSS  03.0
03A4:  GOTO   3AB
03A5:  INCF   55,F
03A6:  BTFSS  03.2
03A7:  GOTO   3AB
03A8:  INCF   56,F
03A9:  BTFSC  03.2
03AA:  BSF    50.0
03AB:  DECF   04,F
03AC:  MOVF   00,W
03AD:  ADDWF  55,F
03AE:  BTFSS  03.0
03AF:  GOTO   3B3
03B0:  INCF   56,F
03B1:  BTFSC  03.2
03B2:  BSF    50.0
03B3:  DECF   04,F
03B4:  MOVF   00,W
03B5:  BTFSS  00.7
03B6:  XORLW  80
03B7:  ADDWF  56,F
03B8:  BTFSC  03.0
03B9:  BSF    50.0
03BA:  BTFSC  52.4
03BB:  GOTO   2AF
03BC:  BTFSC  52.5
03BD:  GOTO   2F1
03BE:  GOTO   327
03BF:  RETURN
03C0:  MOVF   45,W
03C1:  MOVWF  4C
03C2:  MOVF   49,W
03C3:  XORWF  4C,F
03C4:  BTFSS  4C.7
03C5:  GOTO   3CB
03C6:  BCF    03.2
03C7:  BCF    03.0
03C8:  BTFSC  45.7
03C9:  BSF    03.0
03CA:  GOTO   3FE
03CB:  MOVF   45,W
03CC:  MOVWF  4C
03CD:  MOVF   48,W
03CE:  MOVWF  4D
03CF:  MOVF   44,W
03D0:  SUBWF  4D,F
03D1:  BTFSC  03.2
03D2:  GOTO   3D9
03D3:  BTFSS  4C.7
03D4:  GOTO   3FE
03D5:  MOVF   03,W
03D6:  XORLW  01
03D7:  MOVWF  03
03D8:  GOTO   3FE
03D9:  MOVF   49,W
03DA:  MOVWF  4D
03DB:  MOVF   45,W
03DC:  SUBWF  4D,F
03DD:  BTFSC  03.2
03DE:  GOTO   3E5
03DF:  BTFSS  4C.7
03E0:  GOTO   3FE
03E1:  MOVF   03,W
03E2:  XORLW  01
03E3:  MOVWF  03
03E4:  GOTO   3FE
03E5:  MOVF   4A,W
03E6:  MOVWF  4D
03E7:  MOVF   46,W
03E8:  SUBWF  4D,F
03E9:  BTFSC  03.2
03EA:  GOTO   3F1
03EB:  BTFSS  4C.7
03EC:  GOTO   3FE
03ED:  MOVF   03,W
03EE:  XORLW  01
03EF:  MOVWF  03
03F0:  GOTO   3FE
03F1:  MOVF   4B,W
03F2:  MOVWF  4D
03F3:  MOVF   47,W
03F4:  SUBWF  4D,F
03F5:  BTFSC  03.2
03F6:  GOTO   3FD
03F7:  BTFSS  4C.7
03F8:  GOTO   3FE
03F9:  MOVF   03,W
03FA:  XORLW  01
03FB:  MOVWF  03
03FC:  GOTO   3FE
03FD:  BCF    03.0
03FE:  BSF    0A.3
03FF:  BCF    0A.4
0400:  GOTO   2D7 (RETURN)
0401:  MOVF   0B,W
0402:  MOVWF  45
0403:  BCF    0B.7
0404:  BSF    03.5
0405:  BSF    03.6
0406:  BSF    0C.7
0407:  BSF    0C.0
0408:  NOP
0409:  NOP
040A:  BCF    03.5
040B:  BCF    03.6
040C:  BTFSC  45.7
040D:  BSF    0B.7
040E:  BTFSC  03.0
040F:  GOTO   438
0410:  BSF    03.6
0411:  MOVF   0C,W
0412:  ANDLW  7F
0413:  BCF    03.6
0414:  MOVWF  45
0415:  BSF    03.6
0416:  MOVF   0D,W
0417:  BCF    03.6
0418:  MOVWF  46
0419:  BSF    03.6
041A:  MOVF   0F,W
041B:  BCF    03.6
041C:  MOVWF  47
041D:  MOVF   45,W
041E:  MOVWF  51
041F:  CALL   09E
0420:  MOVF   46,W
0421:  BSF    03.6
0422:  MOVWF  0D
0423:  BCF    03.6
0424:  MOVF   47,W
0425:  BSF    03.6
0426:  MOVWF  0F
0427:  BCF    03.6
0428:  MOVF   0B,W
0429:  MOVWF  48
042A:  BCF    0B.7
042B:  BSF    03.5
042C:  BSF    03.6
042D:  BSF    0C.7
042E:  BSF    0C.0
042F:  NOP
0430:  NOP
0431:  BCF    03.5
0432:  BCF    03.6
0433:  BTFSC  48.7
0434:  BSF    0B.7
0435:  DECFSZ 44,F
0436:  GOTO   438
0437:  GOTO   457
0438:  BSF    03.6
0439:  RLF    0C,W
043A:  RLF    0E,W
043B:  ANDLW  7F
043C:  BCF    03.6
043D:  MOVWF  45
043E:  BSF    03.6
043F:  MOVF   0D,W
0440:  BCF    03.6
0441:  MOVWF  46
0442:  BSF    03.6
0443:  MOVF   0F,W
0444:  BCF    03.6
0445:  MOVWF  47
0446:  MOVF   45,W
0447:  MOVWF  51
0448:  CALL   09E
0449:  MOVF   46,W
044A:  BSF    03.6
044B:  MOVWF  0D
044C:  BCF    03.6
044D:  MOVF   47,W
044E:  BSF    03.6
044F:  MOVWF  0F
0450:  INCF   0D,F
0451:  BTFSC  03.2
0452:  INCF   0F,F
0453:  BCF    03.0
0454:  BCF    03.6
0455:  DECFSZ 44,F
0456:  GOTO   401
0457:  RETURN
0458:  BTFSC  03.1
0459:  GOTO   45D
045A:  MOVLW  59
045B:  MOVWF  04
045C:  BCF    03.7
045D:  CLRF   77
045E:  CLRF   78
045F:  CLRF   79
0460:  CLRF   7A
0461:  CLRF   59
0462:  CLRF   5A
0463:  CLRF   5B
0464:  CLRF   5C
0465:  MOVF   58,W
0466:  IORWF  57,W
0467:  IORWF  56,W
0468:  IORWF  55,W
0469:  BTFSC  03.2
046A:  GOTO   49B
046B:  MOVLW  20
046C:  MOVWF  5D
046D:  BCF    03.0
046E:  RLF    51,F
046F:  RLF    52,F
0470:  RLF    53,F
0471:  RLF    54,F
0472:  RLF    59,F
0473:  RLF    5A,F
0474:  RLF    5B,F
0475:  RLF    5C,F
0476:  MOVF   58,W
0477:  SUBWF  5C,W
0478:  BTFSS  03.2
0479:  GOTO   484
047A:  MOVF   57,W
047B:  SUBWF  5B,W
047C:  BTFSS  03.2
047D:  GOTO   484
047E:  MOVF   56,W
047F:  SUBWF  5A,W
0480:  BTFSS  03.2
0481:  GOTO   484
0482:  MOVF   55,W
0483:  SUBWF  59,W
0484:  BTFSS  03.0
0485:  GOTO   495
0486:  MOVF   55,W
0487:  SUBWF  59,F
0488:  MOVF   56,W
0489:  BTFSS  03.0
048A:  INCFSZ 56,W
048B:  SUBWF  5A,F
048C:  MOVF   57,W
048D:  BTFSS  03.0
048E:  INCFSZ 57,W
048F:  SUBWF  5B,F
0490:  MOVF   58,W
0491:  BTFSS  03.0
0492:  INCFSZ 58,W
0493:  SUBWF  5C,F
0494:  BSF    03.0
0495:  RLF    77,F
0496:  RLF    78,F
0497:  RLF    79,F
0498:  RLF    7A,F
0499:  DECFSZ 5D,F
049A:  GOTO   46D
049B:  MOVF   59,W
049C:  MOVWF  00
049D:  INCF   04,F
049E:  MOVF   5A,W
049F:  MOVWF  00
04A0:  INCF   04,F
04A1:  MOVF   5B,W
04A2:  MOVWF  00
04A3:  INCF   04,F
04A4:  MOVF   5C,W
04A5:  MOVWF  00
04A6:  RETURN
04A7:  MOVF   04,W
04A8:  MOVWF  49
04A9:  MOVF   48,W
04AA:  MOVWF  4B
04AB:  BTFSC  03.2
04AC:  GOTO   4C6
04AD:  MOVF   47,W
04AE:  MOVWF  54
04AF:  MOVF   46,W
04B0:  MOVWF  53
04B1:  MOVF   45,W
04B2:  MOVWF  52
04B3:  MOVF   44,W
04B4:  MOVWF  51
04B5:  CLRF   58
04B6:  CLRF   57
04B7:  MOVLW  20
04B8:  MOVWF  56
04B9:  MOVLW  82
04BA:  MOVWF  55
04BB:  CALL   140
04BC:  MOVF   7A,W
04BD:  MOVWF  47
04BE:  MOVF   79,W
04BF:  MOVWF  46
04C0:  MOVF   78,W
04C1:  MOVWF  45
04C2:  MOVF   77,W
04C3:  MOVWF  44
04C4:  DECFSZ 4B,F
04C5:  GOTO   4AD
04C6:  MOVF   47,W
04C7:  MOVWF  54
04C8:  MOVF   46,W
04C9:  MOVWF  53
04CA:  MOVF   45,W
04CB:  MOVWF  52
04CC:  MOVF   44,W
04CD:  MOVWF  51
04CE:  MOVF   51,W
04CF:  SUBLW  B6
04D0:  MOVWF  51
04D1:  CLRF   7A
04D2:  MOVF   52,W
04D3:  MOVWF  55
04D4:  BSF    52.7
04D5:  BCF    03.0
04D6:  RRF    52,F
04D7:  RRF    53,F
04D8:  RRF    54,F
04D9:  RRF    7A,F
04DA:  RRF    79,F
04DB:  RRF    78,F
04DC:  RRF    77,F
04DD:  DECFSZ 51,F
04DE:  GOTO   4D5
04DF:  BTFSS  55.7
04E0:  GOTO   4EC
04E1:  COMF   77,F
04E2:  COMF   78,F
04E3:  COMF   79,F
04E4:  COMF   7A,F
04E5:  INCF   77,F
04E6:  BTFSC  03.2
04E7:  INCF   78,F
04E8:  BTFSC  03.2
04E9:  INCF   79,F
04EA:  BTFSC  03.2
04EB:  INCF   7A,F
04EC:  MOVF   7A,W
04ED:  MOVWF  47
04EE:  MOVF   79,W
04EF:  MOVWF  46
04F0:  MOVF   78,W
04F1:  MOVWF  45
04F2:  MOVF   77,W
04F3:  MOVWF  44
04F4:  BTFSS  47.7
04F5:  GOTO   503
04F6:  DECF   49,F
04F7:  BSF    49.5
04F8:  COMF   44,F
04F9:  COMF   45,F
04FA:  COMF   46,F
04FB:  COMF   47,F
04FC:  INCF   44,F
04FD:  BTFSC  03.2
04FE:  INCF   45,F
04FF:  BTFSC  03.2
0500:  INCF   46,F
0501:  BTFSC  03.2
0502:  INCF   47,F
0503:  MOVLW  3B
0504:  MOVWF  50
0505:  MOVLW  9A
0506:  MOVWF  4F
0507:  MOVLW  CA
0508:  MOVWF  4E
0509:  CLRF   4D
050A:  MOVLW  0A
050B:  MOVWF  4B
050C:  MOVF   48,W
050D:  BTFSC  03.2
050E:  INCF   49,F
050F:  BSF    03.1
0510:  MOVLW  44
0511:  MOVWF  04
0512:  BCF    03.7
0513:  MOVF   47,W
0514:  MOVWF  54
0515:  MOVF   46,W
0516:  MOVWF  53
0517:  MOVF   45,W
0518:  MOVWF  52
0519:  MOVF   44,W
051A:  MOVWF  51
051B:  MOVF   50,W
051C:  MOVWF  58
051D:  MOVF   4F,W
051E:  MOVWF  57
051F:  MOVF   4E,W
0520:  MOVWF  56
0521:  MOVF   4D,W
0522:  MOVWF  55
0523:  CALL   458
0524:  MOVF   78,W
0525:  MOVF   77,F
0526:  BTFSS  03.2
0527:  GOTO   53B
0528:  INCF   48,W
0529:  SUBWF  4B,W
052A:  BTFSC  03.2
052B:  GOTO   53B
052C:  MOVF   49,W
052D:  BTFSC  03.2
052E:  GOTO   53D
052F:  ANDLW  0F
0530:  SUBWF  4B,W
0531:  BTFSC  03.2
0532:  GOTO   535
0533:  BTFSC  03.0
0534:  GOTO   56D
0535:  BTFSC  49.7
0536:  GOTO   56D
0537:  BTFSC  49.6
0538:  GOTO   53D
0539:  MOVLW  20
053A:  GOTO   569
053B:  MOVLW  20
053C:  ANDWF  49,F
053D:  BTFSS  49.5
053E:  GOTO   54B
053F:  BCF    49.5
0540:  MOVF   48,W
0541:  BTFSS  03.2
0542:  DECF   49,F
0543:  MOVF   77,W
0544:  MOVWF  49
0545:  MOVLW  2D
0546:  MOVWF  51
0547:  CALL   09E
0548:  MOVF   49,W
0549:  MOVWF  77
054A:  CLRF   49
054B:  MOVF   48,W
054C:  SUBWF  4B,W
054D:  BTFSS  03.2
054E:  GOTO   559
054F:  MOVF   77,W
0550:  MOVWF  49
0551:  MOVLW  2E
0552:  MOVWF  51
0553:  CALL   09E
0554:  MOVF   49,W
0555:  MOVWF  77
0556:  MOVLW  20
0557:  ANDWF  49,F
0558:  MOVLW  00
0559:  MOVLW  30
055A:  BTFSS  49.5
055B:  GOTO   569
055C:  BCF    49.5
055D:  MOVF   48,W
055E:  BTFSS  03.2
055F:  DECF   49,F
0560:  MOVF   77,W
0561:  MOVWF  49
0562:  MOVLW  2D
0563:  MOVWF  51
0564:  CALL   09E
0565:  MOVF   49,W
0566:  MOVWF  77
0567:  CLRF   49
0568:  MOVLW  30
0569:  ADDWF  77,F
056A:  MOVF   77,W
056B:  MOVWF  51
056C:  CALL   09E
056D:  BCF    03.1
056E:  MOVF   50,W
056F:  MOVWF  54
0570:  MOVF   4F,W
0571:  MOVWF  53
0572:  MOVF   4E,W
0573:  MOVWF  52
0574:  MOVF   4D,W
0575:  MOVWF  51
0576:  CLRF   58
0577:  CLRF   57
0578:  CLRF   56
0579:  MOVLW  0A
057A:  MOVWF  55
057B:  CALL   458
057C:  MOVF   7A,W
057D:  MOVWF  50
057E:  MOVF   79,W
057F:  MOVWF  4F
0580:  MOVF   78,W
0581:  MOVWF  4E
0582:  MOVF   77,W
0583:  MOVWF  4D
0584:  DECFSZ 4B,F
0585:  GOTO   50F
0586:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,BROWNOUT,NOWDT 
.................... #use delay(clock=20M) 
*
0057:  MOVLW  47
0058:  MOVWF  04
0059:  BCF    03.7
005A:  MOVF   00,W
005B:  BTFSC  03.2
005C:  GOTO   06A
005D:  MOVLW  06
005E:  MOVWF  78
005F:  CLRF   77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  DECFSZ 78,F
0063:  GOTO   05F
0064:  MOVLW  7B
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 00,F
0069:  GOTO   05D
006A:  RETURN
.................... #endif 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
080B:  BCF    03.5
080C:  CLRF   20
080D:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define lcd_rs pin_d0 
.................... #define lcd_en pin_d1 
.................... #define fan pin_d7 
.................... #define sd pin_d5 
.................... #define relay pin_d6 
.................... #define on output_high 
.................... #define off output_low 
....................  
.................... #define disp_clear 0b00000001 
.................... #define disp_control 0b00001110 
.................... #define func_set 0b00111000 
.................... #define lscrol 0b00011000 
.................... #define rscrol 0b00011100 
.................... #define line1 0b10000000 
.................... #define line2 0b11000000 
....................  
.................... float adc_value; 
.................... float voltmeter1,voltmeter2; 
.................... float ammeter1,ammeter2; 
.................... float Pin,Pout; 
....................  
.................... void lcd_init (void); 
.................... void lcd_data (unsigned char); 
.................... void lcd_cmd (unsigned char); 
.................... void lcd_lscrol (unsigned char); 
.................... void lcd_rscrol (unsigned char); 
.................... void lcd_line1 (unsigned char); 
.................... void lcd_line2 (unsigned char); 
....................  
.................... void lcd_init (void) 
.................... { 
.................... delay_ms(300); 
*
0082:  MOVLW  02
0083:  MOVWF  44
0084:  MOVLW  96
0085:  MOVWF  47
0086:  CALL   057
0087:  DECFSZ 44,F
0088:  GOTO   084
.................... lcd_cmd (func_set); 
0089:  MOVLW  38
008A:  MOVWF  46
008B:  CALL   06B
.................... lcd_cmd (disp_control); 
008C:  MOVLW  0E
008D:  MOVWF  46
008E:  CALL   06B
.................... lcd_cmd(disp_clear); 
008F:  MOVLW  01
0090:  MOVWF  46
0091:  CALL   06B
....................  delay_ms(50); 
0092:  MOVLW  32
0093:  MOVWF  47
0094:  CALL   057
0095:  BSF    0A.3
0096:  BCF    0A.4
0097:  GOTO   010 (RETURN)
.................... } 
....................  
.................... void lcd_cmd (unsigned char i) 
.................... { 
.................... output_low(lcd_rs); 
*
006B:  BSF    03.5
006C:  BCF    08.0
006D:  BCF    03.5
006E:  BCF    08.0
.................... output_b(i); 
006F:  BSF    03.5
0070:  CLRF   06
0071:  BCF    03.5
0072:  MOVF   46,W
0073:  MOVWF  06
.................... output_high(lcd_en); 
0074:  BSF    03.5
0075:  BCF    08.1
0076:  BCF    03.5
0077:  BSF    08.1
.................... delay_us(100); 
0078:  MOVLW  A6
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  NOP
.................... output_low(lcd_en); 
007D:  BSF    03.5
007E:  BCF    08.1
007F:  BCF    03.5
0080:  BCF    08.1
0081:  RETURN
.................... } 
....................  
.................... void lcd_data (unsigned char i) 
.................... { 
.................... output_high(lcd_rs); 
*
009E:  BSF    03.5
009F:  BCF    08.0
00A0:  BCF    03.5
00A1:  BSF    08.0
.................... output_b(i); 
00A2:  BSF    03.5
00A3:  CLRF   06
00A4:  BCF    03.5
00A5:  MOVF   51,W
00A6:  MOVWF  06
.................... output_high(lcd_en); 
00A7:  BSF    03.5
00A8:  BCF    08.1
00A9:  BCF    03.5
00AA:  BSF    08.1
.................... delay_us(100); 
00AB:  MOVLW  A6
00AC:  MOVWF  77
00AD:  DECFSZ 77,F
00AE:  GOTO   0AD
00AF:  NOP
.................... output_low(lcd_en); 
00B0:  BSF    03.5
00B1:  BCF    08.1
00B2:  BCF    03.5
00B3:  BCF    08.1
00B4:  RETURN
.................... } 
....................  
.................... void lcd_lscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
.................... { 
.................... lcd_cmd(lscrol); 
.................... delay_ms(300); 
.................... } 
.................... } 
....................  
.................... void lcd_rscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
*
0111:  CLRF   45
0112:  MOVF   44,W
0113:  SUBWF  45,W
0114:  BTFSC  03.0
0115:  GOTO   122
.................... { 
.................... lcd_cmd(rscrol); 
0116:  MOVLW  1C
0117:  MOVWF  46
0118:  CALL   06B
.................... delay_ms(300); 
0119:  MOVLW  02
011A:  MOVWF  46
011B:  MOVLW  96
011C:  MOVWF  47
011D:  CALL   057
011E:  DECFSZ 46,F
011F:  GOTO   11B
0120:  INCF   45,F
0121:  GOTO   112
.................... } 
0122:  RETURN
.................... } 
....................  
.................... void lcd_line1 (unsigned char position) 
.................... { 
.................... lcd_cmd(line1 + position); 
*
0098:  MOVLW  80
0099:  ADDWF  44,W
009A:  MOVWF  45
009B:  MOVWF  46
009C:  CALL   06B
009D:  RETURN
.................... } 
....................  
.................... void lcd_line2 (unsigned char position) 
.................... { 
.................... lcd_cmd(line2 + position); 
*
010B:  MOVLW  C0
010C:  ADDWF  44,W
010D:  MOVWF  45
010E:  MOVWF  46
010F:  CALL   06B
0110:  RETURN
.................... } 
....................  
.................... void main(void) 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  42
0805:  BSF    03.5
0806:  BSF    1F.0
0807:  BSF    1F.1
0808:  BSF    1F.2
0809:  BCF    1F.3
080A:  BCF    03.7
.................... { 
....................  
.................... lcd_init(); 
*
080E:  BCF    0A.3
080F:  GOTO   082
0810:  BSF    0A.3
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
0811:  BSF    03.5
0812:  BCF    1F.0
0813:  BCF    1F.1
0814:  BCF    1F.2
0815:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_8); 
0816:  BCF    03.5
0817:  BSF    1F.6
0818:  BCF    1F.7
0819:  BSF    03.5
081A:  BSF    1F.7
081B:  BCF    03.5
081C:  BSF    1F.0
....................  
.................... output_low(PIN_C1);           /* set CCP1 output low */ 
081D:  BCF    42.1
081E:  MOVF   42,W
081F:  BSF    03.5
0820:  MOVWF  07
0821:  BCF    03.5
0822:  BCF    07.1
....................  
.................... setup_ccp1(CCP_PWM);          /* setup pin CCP1 (RC2) to do PWM */ 
0823:  BCF    42.2
0824:  MOVF   42,W
0825:  BSF    03.5
0826:  MOVWF  07
0827:  BCF    03.5
0828:  BCF    07.2
0829:  MOVLW  0C
082A:  MOVWF  17
....................  
.................... setup_timer_2(T2_DIV_BY_1,49,1);  /* 100 KHZ */ 
082B:  MOVLW  00
082C:  MOVWF  78
082D:  IORLW  04
082E:  MOVWF  12
082F:  MOVLW  31
0830:  BSF    03.5
0831:  MOVWF  12
....................  
.................... int i=0; 
0832:  BCF    03.5
0833:  CLRF   43
....................  
.................... do 
.................... { 
.................... lcd_line1 (3); 
0834:  MOVLW  03
0835:  MOVWF  44
0836:  BCF    0A.3
0837:  CALL   098
0838:  BSF    0A.3
.................... lcd_data ("PV Fed "); 
0839:  MOVLW  04
083A:  BSF    03.6
083B:  MOVWF  0D
083C:  MOVLW  00
083D:  MOVWF  0F
083E:  BCF    0A.3
083F:  BCF    03.6
0840:  CALL   0B5
0841:  BSF    0A.3
.................... lcd_line2 (0); 
0842:  CLRF   44
0843:  BCF    0A.3
0844:  CALL   10B
0845:  BSF    0A.3
.................... lcd_data ("Conversion With"); 
0846:  MOVLW  08
0847:  BSF    03.6
0848:  MOVWF  0D
0849:  MOVLW  00
084A:  MOVWF  0F
084B:  BCF    0A.3
084C:  BCF    03.6
084D:  CALL   0B5
084E:  BSF    0A.3
.................... delay_ms(1000); 
084F:  MOVLW  04
0850:  MOVWF  44
0851:  MOVLW  FA
0852:  MOVWF  47
0853:  BCF    0A.3
0854:  CALL   057
0855:  BSF    0A.3
0856:  DECFSZ 44,F
0857:  GOTO   051
.................... lcd_rscrol(20); 
0858:  MOVLW  14
0859:  MOVWF  44
085A:  BCF    0A.3
085B:  CALL   111
085C:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
085D:  MOVLW  01
085E:  MOVWF  46
085F:  BCF    0A.3
0860:  CALL   06B
0861:  BSF    0A.3
....................  delay_ms(50); 
0862:  MOVLW  32
0863:  MOVWF  47
0864:  BCF    0A.3
0865:  CALL   057
0866:  BSF    0A.3
....................  lcd_line1 (0); 
0867:  CLRF   44
0868:  BCF    0A.3
0869:  CALL   098
086A:  BSF    0A.3
.................... lcd_data ("Existing UPS"); 
086B:  MOVLW  10
086C:  BSF    03.6
086D:  MOVWF  0D
086E:  MOVLW  00
086F:  MOVWF  0F
0870:  BCF    0A.3
0871:  BCF    03.6
0872:  CALL   0B5
0873:  BSF    0A.3
.................... delay_ms(1000); 
0874:  MOVLW  04
0875:  MOVWF  44
0876:  MOVLW  FA
0877:  MOVWF  47
0878:  BCF    0A.3
0879:  CALL   057
087A:  BSF    0A.3
087B:  DECFSZ 44,F
087C:  GOTO   076
.................... lcd_rscrol(20); 
087D:  MOVLW  14
087E:  MOVWF  44
087F:  BCF    0A.3
0880:  CALL   111
0881:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0882:  MOVLW  01
0883:  MOVWF  46
0884:  BCF    0A.3
0885:  CALL   06B
0886:  BSF    0A.3
....................  delay_ms(50); 
0887:  MOVLW  32
0888:  MOVWF  47
0889:  BCF    0A.3
088A:  CALL   057
088B:  BSF    0A.3
....................   
.................... lcd_line1 (3); 
088C:  MOVLW  03
088D:  MOVWF  44
088E:  BCF    0A.3
088F:  CALL   098
0890:  BSF    0A.3
.................... lcd_data ("Made by:"); 
0891:  MOVLW  17
0892:  BSF    03.6
0893:  MOVWF  0D
0894:  MOVLW  00
0895:  MOVWF  0F
0896:  BCF    0A.3
0897:  BCF    03.6
0898:  CALL   0B5
0899:  BSF    0A.3
.................... lcd_line2 (0); 
089A:  CLRF   44
089B:  BCF    0A.3
089C:  CALL   10B
089D:  BSF    0A.3
.................... lcd_data ("Faizan,Shakir"); 
089E:  MOVLW  1C
089F:  BSF    03.6
08A0:  MOVWF  0D
08A1:  MOVLW  00
08A2:  MOVWF  0F
08A3:  BCF    0A.3
08A4:  BCF    03.6
08A5:  CALL   0B5
08A6:  BSF    0A.3
.................... delay_ms(1000); 
08A7:  MOVLW  04
08A8:  MOVWF  44
08A9:  MOVLW  FA
08AA:  MOVWF  47
08AB:  BCF    0A.3
08AC:  CALL   057
08AD:  BSF    0A.3
08AE:  DECFSZ 44,F
08AF:  GOTO   0A9
.................... lcd_rscrol(20); 
08B0:  MOVLW  14
08B1:  MOVWF  44
08B2:  BCF    0A.3
08B3:  CALL   111
08B4:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
08B5:  MOVLW  01
08B6:  MOVWF  46
08B7:  BCF    0A.3
08B8:  CALL   06B
08B9:  BSF    0A.3
....................  delay_ms(50); 
08BA:  MOVLW  32
08BB:  MOVWF  47
08BC:  BCF    0A.3
08BD:  CALL   057
08BE:  BSF    0A.3
....................  
.................... lcd_line1 (3); 
08BF:  MOVLW  03
08C0:  MOVWF  44
08C1:  BCF    0A.3
08C2:  CALL   098
08C3:  BSF    0A.3
.................... lcd_data ("Made by:"); 
08C4:  MOVLW  23
08C5:  BSF    03.6
08C6:  MOVWF  0D
08C7:  MOVLW  00
08C8:  MOVWF  0F
08C9:  BCF    0A.3
08CA:  BCF    03.6
08CB:  CALL   0B5
08CC:  BSF    0A.3
.................... lcd_line2 (2); 
08CD:  MOVLW  02
08CE:  MOVWF  44
08CF:  BCF    0A.3
08D0:  CALL   10B
08D1:  BSF    0A.3
.................... lcd_data ("And Hamza"); 
08D2:  MOVLW  28
08D3:  BSF    03.6
08D4:  MOVWF  0D
08D5:  MOVLW  00
08D6:  MOVWF  0F
08D7:  BCF    0A.3
08D8:  BCF    03.6
08D9:  CALL   0B5
08DA:  BSF    0A.3
.................... delay_ms(1000); 
08DB:  MOVLW  04
08DC:  MOVWF  44
08DD:  MOVLW  FA
08DE:  MOVWF  47
08DF:  BCF    0A.3
08E0:  CALL   057
08E1:  BSF    0A.3
08E2:  DECFSZ 44,F
08E3:  GOTO   0DD
.................... lcd_rscrol(20); 
08E4:  MOVLW  14
08E5:  MOVWF  44
08E6:  BCF    0A.3
08E7:  CALL   111
08E8:  BSF    0A.3
.................... i++; 
08E9:  INCF   43,F
.................... } 
.................... while(i==0); 
08EA:  MOVF   43,F
08EB:  BTFSC  03.2
08EC:  GOTO   034
....................  
.................... lcd_cmd(disp_clear); 
08ED:  MOVLW  01
08EE:  MOVWF  46
08EF:  BCF    0A.3
08F0:  CALL   06B
08F1:  BSF    0A.3
....................  delay_ms(50); 
08F2:  MOVLW  32
08F3:  MOVWF  47
08F4:  BCF    0A.3
08F5:  CALL   057
08F6:  BSF    0A.3
....................   
.................... while(1) 
.................... { 
.................... on(sd); 
08F7:  BSF    03.5
08F8:  BCF    08.5
08F9:  BCF    03.5
08FA:  BSF    08.5
.................... on(fan); 
08FB:  BSF    03.5
08FC:  BCF    08.7
08FD:  BCF    03.5
08FE:  BSF    08.7
.................... on(relay); 
08FF:  BSF    03.5
0900:  BCF    08.6
0901:  BCF    03.5
0902:  BSF    08.6
....................  
.................... set_adc_channel(0); 
0903:  MOVLW  00
0904:  MOVWF  78
0905:  MOVF   1F,W
0906:  ANDLW  C7
0907:  IORWF  78,W
0908:  MOVWF  1F
.................... delay_us(100); 
0909:  MOVLW  A6
090A:  MOVWF  77
090B:  DECFSZ 77,F
090C:  GOTO   10B
090D:  NOP
....................  
.................... adc_value = read_adc(); 
090E:  BSF    1F.2
090F:  BTFSC  1F.2
0910:  GOTO   10F
0911:  MOVF   1E,W
0912:  MOVWF  7A
0913:  BSF    03.5
0914:  MOVF   1E,W
0915:  BCF    03.5
0916:  MOVWF  44
0917:  MOVF   1E,W
0918:  MOVWF  45
0919:  BCF    0A.3
091A:  CALL   123
091B:  BSF    0A.3
091C:  MOVF   7A,W
091D:  MOVWF  29
091E:  MOVF   79,W
091F:  MOVWF  28
0920:  MOVF   78,W
0921:  MOVWF  27
0922:  MOVF   77,W
0923:  MOVWF  26
....................  
.................... voltmeter1= (5.0*adc_value/1023.0)/0.1803; 
0924:  CLRF   54
0925:  CLRF   53
0926:  MOVLW  20
0927:  MOVWF  52
0928:  MOVLW  81
0929:  MOVWF  51
092A:  MOVF   29,W
092B:  MOVWF  58
092C:  MOVF   28,W
092D:  MOVWF  57
092E:  MOVF   27,W
092F:  MOVWF  56
0930:  MOVF   26,W
0931:  MOVWF  55
0932:  BCF    0A.3
0933:  CALL   140
0934:  BSF    0A.3
0935:  MOVF   7A,W
0936:  MOVWF  47
0937:  MOVF   79,W
0938:  MOVWF  46
0939:  MOVF   78,W
093A:  MOVWF  45
093B:  MOVF   77,W
093C:  MOVWF  44
093D:  MOVF   47,W
093E:  MOVWF  4B
093F:  MOVF   46,W
0940:  MOVWF  4A
0941:  MOVF   45,W
0942:  MOVWF  49
0943:  MOVF   44,W
0944:  MOVWF  48
0945:  CLRF   4F
0946:  MOVLW  C0
0947:  MOVWF  4E
0948:  MOVLW  7F
0949:  MOVWF  4D
094A:  MOVLW  88
094B:  MOVWF  4C
094C:  BCF    0A.3
094D:  CALL   1B5
094E:  BSF    0A.3
094F:  MOVF   7A,W
0950:  MOVWF  47
0951:  MOVF   79,W
0952:  MOVWF  46
0953:  MOVF   78,W
0954:  MOVWF  45
0955:  MOVF   77,W
0956:  MOVWF  44
0957:  MOVF   47,W
0958:  MOVWF  4B
0959:  MOVF   46,W
095A:  MOVWF  4A
095B:  MOVF   45,W
095C:  MOVWF  49
095D:  MOVF   44,W
095E:  MOVWF  48
095F:  MOVLW  90
0960:  MOVWF  4F
0961:  MOVLW  A0
0962:  MOVWF  4E
0963:  MOVLW  38
0964:  MOVWF  4D
0965:  MOVLW  7C
0966:  MOVWF  4C
0967:  BCF    0A.3
0968:  CALL   1B5
0969:  BSF    0A.3
096A:  MOVF   7A,W
096B:  MOVWF  2D
096C:  MOVF   79,W
096D:  MOVWF  2C
096E:  MOVF   78,W
096F:  MOVWF  2B
0970:  MOVF   77,W
0971:  MOVWF  2A
....................  
....................  set_adc_channel(1); 
0972:  MOVLW  08
0973:  MOVWF  78
0974:  MOVF   1F,W
0975:  ANDLW  C7
0976:  IORWF  78,W
0977:  MOVWF  1F
.................... delay_ms(100); 
0978:  MOVLW  64
0979:  MOVWF  47
097A:  BCF    0A.3
097B:  CALL   057
097C:  BSF    0A.3
....................  
.................... adc_value = read_adc(); 
097D:  BSF    1F.2
097E:  BTFSC  1F.2
097F:  GOTO   17E
0980:  MOVF   1E,W
0981:  MOVWF  7A
0982:  BSF    03.5
0983:  MOVF   1E,W
0984:  BCF    03.5
0985:  MOVWF  44
0986:  MOVF   1E,W
0987:  MOVWF  45
0988:  BCF    0A.3
0989:  CALL   123
098A:  BSF    0A.3
098B:  MOVF   7A,W
098C:  MOVWF  29
098D:  MOVF   79,W
098E:  MOVWF  28
098F:  MOVF   78,W
0990:  MOVWF  27
0991:  MOVF   77,W
0992:  MOVWF  26
....................  
.................... ammeter1= ((5.0/1023.0*adc_value)-1.87)/0.034; 
0993:  MOVLW  0A
0994:  MOVWF  54
0995:  MOVLW  28
0996:  MOVWF  53
0997:  MOVLW  20
0998:  MOVWF  52
0999:  MOVLW  77
099A:  MOVWF  51
099B:  MOVF   29,W
099C:  MOVWF  58
099D:  MOVF   28,W
099E:  MOVWF  57
099F:  MOVF   27,W
09A0:  MOVWF  56
09A1:  MOVF   26,W
09A2:  MOVWF  55
09A3:  BCF    0A.3
09A4:  CALL   140
09A5:  BSF    0A.3
09A6:  MOVF   7A,W
09A7:  MOVWF  47
09A8:  MOVF   79,W
09A9:  MOVWF  46
09AA:  MOVF   78,W
09AB:  MOVWF  45
09AC:  MOVF   77,W
09AD:  MOVWF  44
09AE:  BSF    03.1
09AF:  MOVF   47,W
09B0:  MOVWF  4B
09B1:  MOVF   46,W
09B2:  MOVWF  4A
09B3:  MOVF   45,W
09B4:  MOVWF  49
09B5:  MOVF   44,W
09B6:  MOVWF  48
09B7:  MOVLW  29
09B8:  MOVWF  4F
09B9:  MOVLW  5C
09BA:  MOVWF  4E
09BB:  MOVLW  6F
09BC:  MOVWF  4D
09BD:  MOVLW  7F
09BE:  MOVWF  4C
09BF:  BCF    0A.3
09C0:  CALL   27F
09C1:  BSF    0A.3
09C2:  MOVF   7A,W
09C3:  MOVWF  47
09C4:  MOVF   79,W
09C5:  MOVWF  46
09C6:  MOVF   78,W
09C7:  MOVWF  45
09C8:  MOVF   77,W
09C9:  MOVWF  44
09CA:  MOVF   47,W
09CB:  MOVWF  4B
09CC:  MOVF   46,W
09CD:  MOVWF  4A
09CE:  MOVF   45,W
09CF:  MOVWF  49
09D0:  MOVF   44,W
09D1:  MOVWF  48
09D2:  MOVLW  96
09D3:  MOVWF  4F
09D4:  MOVLW  43
09D5:  MOVWF  4E
09D6:  MOVLW  0B
09D7:  MOVWF  4D
09D8:  MOVLW  7A
09D9:  MOVWF  4C
09DA:  BCF    0A.3
09DB:  CALL   1B5
09DC:  BSF    0A.3
09DD:  MOVF   7A,W
09DE:  MOVWF  35
09DF:  MOVF   79,W
09E0:  MOVWF  34
09E1:  MOVF   78,W
09E2:  MOVWF  33
09E3:  MOVF   77,W
09E4:  MOVWF  32
....................  
.................... set_adc_channel(2); 
09E5:  MOVLW  10
09E6:  MOVWF  78
09E7:  MOVF   1F,W
09E8:  ANDLW  C7
09E9:  IORWF  78,W
09EA:  MOVWF  1F
.................... delay_us(100); 
09EB:  MOVLW  A6
09EC:  MOVWF  77
09ED:  DECFSZ 77,F
09EE:  GOTO   1ED
09EF:  NOP
....................  
.................... adc_value = read_adc(); 
09F0:  BSF    1F.2
09F1:  BTFSC  1F.2
09F2:  GOTO   1F1
09F3:  MOVF   1E,W
09F4:  MOVWF  7A
09F5:  BSF    03.5
09F6:  MOVF   1E,W
09F7:  BCF    03.5
09F8:  MOVWF  44
09F9:  MOVF   1E,W
09FA:  MOVWF  45
09FB:  BCF    0A.3
09FC:  CALL   123
09FD:  BSF    0A.3
09FE:  MOVF   7A,W
09FF:  MOVWF  29
0A00:  MOVF   79,W
0A01:  MOVWF  28
0A02:  MOVF   78,W
0A03:  MOVWF  27
0A04:  MOVF   77,W
0A05:  MOVWF  26
....................  
.................... voltmeter2= (5.0*adc_value/1023.0)/0.333; 
0A06:  CLRF   54
0A07:  CLRF   53
0A08:  MOVLW  20
0A09:  MOVWF  52
0A0A:  MOVLW  81
0A0B:  MOVWF  51
0A0C:  MOVF   29,W
0A0D:  MOVWF  58
0A0E:  MOVF   28,W
0A0F:  MOVWF  57
0A10:  MOVF   27,W
0A11:  MOVWF  56
0A12:  MOVF   26,W
0A13:  MOVWF  55
0A14:  BCF    0A.3
0A15:  CALL   140
0A16:  BSF    0A.3
0A17:  MOVF   7A,W
0A18:  MOVWF  47
0A19:  MOVF   79,W
0A1A:  MOVWF  46
0A1B:  MOVF   78,W
0A1C:  MOVWF  45
0A1D:  MOVF   77,W
0A1E:  MOVWF  44
0A1F:  MOVF   47,W
0A20:  MOVWF  4B
0A21:  MOVF   46,W
0A22:  MOVWF  4A
0A23:  MOVF   45,W
0A24:  MOVWF  49
0A25:  MOVF   44,W
0A26:  MOVWF  48
0A27:  CLRF   4F
0A28:  MOVLW  C0
0A29:  MOVWF  4E
0A2A:  MOVLW  7F
0A2B:  MOVWF  4D
0A2C:  MOVLW  88
0A2D:  MOVWF  4C
0A2E:  BCF    0A.3
0A2F:  CALL   1B5
0A30:  BSF    0A.3
0A31:  MOVF   7A,W
0A32:  MOVWF  47
0A33:  MOVF   79,W
0A34:  MOVWF  46
0A35:  MOVF   78,W
0A36:  MOVWF  45
0A37:  MOVF   77,W
0A38:  MOVWF  44
0A39:  MOVF   47,W
0A3A:  MOVWF  4B
0A3B:  MOVF   46,W
0A3C:  MOVWF  4A
0A3D:  MOVF   45,W
0A3E:  MOVWF  49
0A3F:  MOVF   44,W
0A40:  MOVWF  48
0A41:  MOVLW  FA
0A42:  MOVWF  4F
0A43:  MOVLW  7E
0A44:  MOVWF  4E
0A45:  MOVLW  2A
0A46:  MOVWF  4D
0A47:  MOVLW  7D
0A48:  MOVWF  4C
0A49:  BCF    0A.3
0A4A:  CALL   1B5
0A4B:  BSF    0A.3
0A4C:  MOVF   7A,W
0A4D:  MOVWF  31
0A4E:  MOVF   79,W
0A4F:  MOVWF  30
0A50:  MOVF   78,W
0A51:  MOVWF  2F
0A52:  MOVF   77,W
0A53:  MOVWF  2E
....................  
....................  set_adc_channel(3); 
0A54:  MOVLW  18
0A55:  MOVWF  78
0A56:  MOVF   1F,W
0A57:  ANDLW  C7
0A58:  IORWF  78,W
0A59:  MOVWF  1F
.................... delay_ms(100); 
0A5A:  MOVLW  64
0A5B:  MOVWF  47
0A5C:  BCF    0A.3
0A5D:  CALL   057
0A5E:  BSF    0A.3
....................  
.................... adc_value = read_adc(); 
0A5F:  BSF    1F.2
0A60:  BTFSC  1F.2
0A61:  GOTO   260
0A62:  MOVF   1E,W
0A63:  MOVWF  7A
0A64:  BSF    03.5
0A65:  MOVF   1E,W
0A66:  BCF    03.5
0A67:  MOVWF  44
0A68:  MOVF   1E,W
0A69:  MOVWF  45
0A6A:  BCF    0A.3
0A6B:  CALL   123
0A6C:  BSF    0A.3
0A6D:  MOVF   7A,W
0A6E:  MOVWF  29
0A6F:  MOVF   79,W
0A70:  MOVWF  28
0A71:  MOVF   78,W
0A72:  MOVWF  27
0A73:  MOVF   77,W
0A74:  MOVWF  26
....................  
.................... ammeter2= ((5.0/1023.0*adc_value)-2.47)/0.064; 
0A75:  MOVLW  0A
0A76:  MOVWF  54
0A77:  MOVLW  28
0A78:  MOVWF  53
0A79:  MOVLW  20
0A7A:  MOVWF  52
0A7B:  MOVLW  77
0A7C:  MOVWF  51
0A7D:  MOVF   29,W
0A7E:  MOVWF  58
0A7F:  MOVF   28,W
0A80:  MOVWF  57
0A81:  MOVF   27,W
0A82:  MOVWF  56
0A83:  MOVF   26,W
0A84:  MOVWF  55
0A85:  BCF    0A.3
0A86:  CALL   140
0A87:  BSF    0A.3
0A88:  MOVF   7A,W
0A89:  MOVWF  47
0A8A:  MOVF   79,W
0A8B:  MOVWF  46
0A8C:  MOVF   78,W
0A8D:  MOVWF  45
0A8E:  MOVF   77,W
0A8F:  MOVWF  44
0A90:  BSF    03.1
0A91:  MOVF   47,W
0A92:  MOVWF  4B
0A93:  MOVF   46,W
0A94:  MOVWF  4A
0A95:  MOVF   45,W
0A96:  MOVWF  49
0A97:  MOVF   44,W
0A98:  MOVWF  48
0A99:  MOVLW  7B
0A9A:  MOVWF  4F
0A9B:  MOVLW  14
0A9C:  MOVWF  4E
0A9D:  MOVLW  1E
0A9E:  MOVWF  4D
0A9F:  MOVLW  80
0AA0:  MOVWF  4C
0AA1:  BCF    0A.3
0AA2:  CALL   27F
0AA3:  BSF    0A.3
0AA4:  MOVF   7A,W
0AA5:  MOVWF  47
0AA6:  MOVF   79,W
0AA7:  MOVWF  46
0AA8:  MOVF   78,W
0AA9:  MOVWF  45
0AAA:  MOVF   77,W
0AAB:  MOVWF  44
0AAC:  MOVF   47,W
0AAD:  MOVWF  4B
0AAE:  MOVF   46,W
0AAF:  MOVWF  4A
0AB0:  MOVF   45,W
0AB1:  MOVWF  49
0AB2:  MOVF   44,W
0AB3:  MOVWF  48
0AB4:  MOVLW  6F
0AB5:  MOVWF  4F
0AB6:  MOVLW  12
0AB7:  MOVWF  4E
0AB8:  MOVLW  03
0AB9:  MOVWF  4D
0ABA:  MOVLW  7B
0ABB:  MOVWF  4C
0ABC:  BCF    0A.3
0ABD:  CALL   1B5
0ABE:  BSF    0A.3
0ABF:  MOVF   7A,W
0AC0:  MOVWF  39
0AC1:  MOVF   79,W
0AC2:  MOVWF  38
0AC3:  MOVF   78,W
0AC4:  MOVWF  37
0AC5:  MOVF   77,W
0AC6:  MOVWF  36
....................  
.................... if (voltmeter1<=14) 
0AC7:  MOVF   2D,W
0AC8:  MOVWF  47
0AC9:  MOVF   2C,W
0ACA:  MOVWF  46
0ACB:  MOVF   2B,W
0ACC:  MOVWF  45
0ACD:  MOVF   2A,W
0ACE:  MOVWF  44
0ACF:  CLRF   4B
0AD0:  CLRF   4A
0AD1:  MOVLW  60
0AD2:  MOVWF  49
0AD3:  MOVLW  82
0AD4:  MOVWF  48
0AD5:  BCF    0A.3
0AD6:  GOTO   3C0
0AD7:  BSF    0A.3
0AD8:  BTFSC  03.0
0AD9:  GOTO   2DC
0ADA:  BTFSS  03.2
0ADB:  GOTO   2E8
.................... { 
....................  
.................... off(relay); 
0ADC:  BSF    03.5
0ADD:  BCF    08.6
0ADE:  BCF    03.5
0ADF:  BCF    08.6
.................... off(fan); 
0AE0:  BSF    03.5
0AE1:  BCF    08.7
0AE2:  BCF    03.5
0AE3:  BCF    08.7
.................... off(sd); 
0AE4:  BSF    03.5
0AE5:  BCF    08.5
0AE6:  BCF    03.5
0AE7:  BCF    08.5
....................  
.................... } 
.................... set_pwm1_duty(40); 
0AE8:  MOVLW  28
0AE9:  MOVWF  15
....................   
....................  lcd_line1(0); 
0AEA:  CLRF   44
0AEB:  BCF    0A.3
0AEC:  CALL   098
0AED:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE:%f V",voltmeter1); 
0AEE:  MOVLW  2D
0AEF:  BSF    03.6
0AF0:  MOVWF  0D
0AF1:  MOVLW  00
0AF2:  MOVWF  0F
0AF3:  BCF    03.0
0AF4:  MOVLW  08
0AF5:  BCF    03.6
0AF6:  MOVWF  44
0AF7:  BCF    0A.3
0AF8:  CALL   401
0AF9:  BSF    0A.3
0AFA:  MOVLW  89
0AFB:  MOVWF  04
0AFC:  MOVF   2D,W
0AFD:  MOVWF  47
0AFE:  MOVF   2C,W
0AFF:  MOVWF  46
0B00:  MOVF   2B,W
0B01:  MOVWF  45
0B02:  MOVF   2A,W
0B03:  MOVWF  44
0B04:  MOVLW  02
0B05:  MOVWF  48
0B06:  BCF    0A.3
0B07:  CALL   4A7
0B08:  BSF    0A.3
0B09:  MOVLW  20
0B0A:  MOVWF  51
0B0B:  BCF    0A.3
0B0C:  CALL   09E
0B0D:  BSF    0A.3
0B0E:  MOVLW  56
0B0F:  MOVWF  51
0B10:  BCF    0A.3
0B11:  CALL   09E
0B12:  BSF    0A.3
....................  
.................... delay_ms(1000); 
0B13:  MOVLW  04
0B14:  MOVWF  44
0B15:  MOVLW  FA
0B16:  MOVWF  47
0B17:  BCF    0A.3
0B18:  CALL   057
0B19:  BSF    0A.3
0B1A:  DECFSZ 44,F
0B1B:  GOTO   315
.................... lcd_rscrol(20); 
0B1C:  MOVLW  14
0B1D:  MOVWF  44
0B1E:  BCF    0A.3
0B1F:  CALL   111
0B20:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B21:  MOVLW  01
0B22:  MOVWF  46
0B23:  BCF    0A.3
0B24:  CALL   06B
0B25:  BSF    0A.3
....................  delay_ms(50); 
0B26:  MOVLW  32
0B27:  MOVWF  47
0B28:  BCF    0A.3
0B29:  CALL   057
0B2A:  BSF    0A.3
....................   
.................... lcd_line1(0); 
0B2B:  CLRF   44
0B2C:  BCF    0A.3
0B2D:  CALL   098
0B2E:  BSF    0A.3
....................  
....................  printf(lcd_data,"CURRENT: %f A",ammeter1); 
0B2F:  MOVLW  34
0B30:  BSF    03.6
0B31:  MOVWF  0D
0B32:  MOVLW  00
0B33:  MOVWF  0F
0B34:  BCF    03.0
0B35:  MOVLW  09
0B36:  BCF    03.6
0B37:  MOVWF  44
0B38:  BCF    0A.3
0B39:  CALL   401
0B3A:  BSF    0A.3
0B3B:  MOVLW  89
0B3C:  MOVWF  04
0B3D:  MOVF   35,W
0B3E:  MOVWF  47
0B3F:  MOVF   34,W
0B40:  MOVWF  46
0B41:  MOVF   33,W
0B42:  MOVWF  45
0B43:  MOVF   32,W
0B44:  MOVWF  44
0B45:  MOVLW  02
0B46:  MOVWF  48
0B47:  BCF    0A.3
0B48:  CALL   4A7
0B49:  BSF    0A.3
0B4A:  MOVLW  20
0B4B:  MOVWF  51
0B4C:  BCF    0A.3
0B4D:  CALL   09E
0B4E:  BSF    0A.3
0B4F:  MOVLW  41
0B50:  MOVWF  51
0B51:  BCF    0A.3
0B52:  CALL   09E
0B53:  BSF    0A.3
.................... delay_ms(1000); 
0B54:  MOVLW  04
0B55:  MOVWF  44
0B56:  MOVLW  FA
0B57:  MOVWF  47
0B58:  BCF    0A.3
0B59:  CALL   057
0B5A:  BSF    0A.3
0B5B:  DECFSZ 44,F
0B5C:  GOTO   356
.................... lcd_rscrol(20); 
0B5D:  MOVLW  14
0B5E:  MOVWF  44
0B5F:  BCF    0A.3
0B60:  CALL   111
0B61:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B62:  MOVLW  01
0B63:  MOVWF  46
0B64:  BCF    0A.3
0B65:  CALL   06B
0B66:  BSF    0A.3
....................  delay_ms(50); 
0B67:  MOVLW  32
0B68:  MOVWF  47
0B69:  BCF    0A.3
0B6A:  CALL   057
0B6B:  BSF    0A.3
....................   
....................  Pin=voltmeter1*0.9; 
0B6C:  MOVF   2D,W
0B6D:  MOVWF  54
0B6E:  MOVF   2C,W
0B6F:  MOVWF  53
0B70:  MOVF   2B,W
0B71:  MOVWF  52
0B72:  MOVF   2A,W
0B73:  MOVWF  51
0B74:  MOVLW  66
0B75:  MOVWF  58
0B76:  MOVWF  57
0B77:  MOVWF  56
0B78:  MOVLW  7E
0B79:  MOVWF  55
0B7A:  BCF    0A.3
0B7B:  CALL   140
0B7C:  BSF    0A.3
0B7D:  MOVF   7A,W
0B7E:  MOVWF  3D
0B7F:  MOVF   79,W
0B80:  MOVWF  3C
0B81:  MOVF   78,W
0B82:  MOVWF  3B
0B83:  MOVF   77,W
0B84:  MOVWF  3A
....................  lcd_line1(0); 
0B85:  CLRF   44
0B86:  BCF    0A.3
0B87:  CALL   098
0B88:  BSF    0A.3
....................  lcd_data("INPUT POWER:"); 
0B89:  MOVLW  3B
0B8A:  BSF    03.6
0B8B:  MOVWF  0D
0B8C:  MOVLW  00
0B8D:  MOVWF  0F
0B8E:  BCF    0A.3
0B8F:  BCF    03.6
0B90:  CALL   0B5
0B91:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0B92:  MOVLW  03
0B93:  MOVWF  44
0B94:  BCF    0A.3
0B95:  CALL   10B
0B96:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pin); 
0B97:  MOVLW  89
0B98:  MOVWF  04
0B99:  MOVF   3D,W
0B9A:  MOVWF  47
0B9B:  MOVF   3C,W
0B9C:  MOVWF  46
0B9D:  MOVF   3B,W
0B9E:  MOVWF  45
0B9F:  MOVF   3A,W
0BA0:  MOVWF  44
0BA1:  MOVLW  02
0BA2:  MOVWF  48
0BA3:  BCF    0A.3
0BA4:  CALL   4A7
0BA5:  BSF    0A.3
0BA6:  MOVLW  20
0BA7:  MOVWF  51
0BA8:  BCF    0A.3
0BA9:  CALL   09E
0BAA:  BSF    0A.3
0BAB:  MOVLW  57
0BAC:  MOVWF  51
0BAD:  BCF    0A.3
0BAE:  CALL   09E
0BAF:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0BB0:  MOVLW  04
0BB1:  MOVWF  44
0BB2:  MOVLW  FA
0BB3:  MOVWF  47
0BB4:  BCF    0A.3
0BB5:  CALL   057
0BB6:  BSF    0A.3
0BB7:  DECFSZ 44,F
0BB8:  GOTO   3B2
.................... lcd_rscrol(20); 
0BB9:  MOVLW  14
0BBA:  MOVWF  44
0BBB:  BCF    0A.3
0BBC:  CALL   111
0BBD:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0BBE:  MOVLW  01
0BBF:  MOVWF  46
0BC0:  BCF    0A.3
0BC1:  CALL   06B
0BC2:  BSF    0A.3
....................  delay_ms(50); 
0BC3:  MOVLW  32
0BC4:  MOVWF  47
0BC5:  BCF    0A.3
0BC6:  CALL   057
0BC7:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0BC8:  CLRF   44
0BC9:  BCF    0A.3
0BCA:  CALL   098
0BCB:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE: %f V",voltmeter2); 
0BCC:  MOVLW  42
0BCD:  BSF    03.6
0BCE:  MOVWF  0D
0BCF:  MOVLW  00
0BD0:  MOVWF  0F
0BD1:  BCF    03.0
0BD2:  MOVLW  09
0BD3:  BCF    03.6
0BD4:  MOVWF  44
0BD5:  BCF    0A.3
0BD6:  CALL   401
0BD7:  BSF    0A.3
0BD8:  MOVLW  89
0BD9:  MOVWF  04
0BDA:  MOVF   31,W
0BDB:  MOVWF  47
0BDC:  MOVF   30,W
0BDD:  MOVWF  46
0BDE:  MOVF   2F,W
0BDF:  MOVWF  45
0BE0:  MOVF   2E,W
0BE1:  MOVWF  44
0BE2:  MOVLW  02
0BE3:  MOVWF  48
0BE4:  BCF    0A.3
0BE5:  CALL   4A7
0BE6:  BSF    0A.3
0BE7:  MOVLW  20
0BE8:  MOVWF  51
0BE9:  BCF    0A.3
0BEA:  CALL   09E
0BEB:  BSF    0A.3
0BEC:  MOVLW  56
0BED:  MOVWF  51
0BEE:  BCF    0A.3
0BEF:  CALL   09E
0BF0:  BSF    0A.3
.................... delay_ms(1000); 
0BF1:  MOVLW  04
0BF2:  MOVWF  44
0BF3:  MOVLW  FA
0BF4:  MOVWF  47
0BF5:  BCF    0A.3
0BF6:  CALL   057
0BF7:  BSF    0A.3
0BF8:  DECFSZ 44,F
0BF9:  GOTO   3F3
.................... lcd_rscrol(20); 
0BFA:  MOVLW  14
0BFB:  MOVWF  44
0BFC:  BCF    0A.3
0BFD:  CALL   111
0BFE:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0BFF:  MOVLW  01
0C00:  MOVWF  46
0C01:  BCF    0A.3
0C02:  CALL   06B
0C03:  BSF    0A.3
....................  delay_ms(50); 
0C04:  MOVLW  32
0C05:  MOVWF  47
0C06:  BCF    0A.3
0C07:  CALL   057
0C08:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0C09:  CLRF   44
0C0A:  BCF    0A.3
0C0B:  CALL   098
0C0C:  BSF    0A.3
....................  
.................... printf(lcd_data,"CURRENT: %f A",ammeter2); 
0C0D:  MOVLW  49
0C0E:  BSF    03.6
0C0F:  MOVWF  0D
0C10:  MOVLW  00
0C11:  MOVWF  0F
0C12:  BCF    03.0
0C13:  MOVLW  09
0C14:  BCF    03.6
0C15:  MOVWF  44
0C16:  BCF    0A.3
0C17:  CALL   401
0C18:  BSF    0A.3
0C19:  MOVLW  89
0C1A:  MOVWF  04
0C1B:  MOVF   39,W
0C1C:  MOVWF  47
0C1D:  MOVF   38,W
0C1E:  MOVWF  46
0C1F:  MOVF   37,W
0C20:  MOVWF  45
0C21:  MOVF   36,W
0C22:  MOVWF  44
0C23:  MOVLW  02
0C24:  MOVWF  48
0C25:  BCF    0A.3
0C26:  CALL   4A7
0C27:  BSF    0A.3
0C28:  MOVLW  20
0C29:  MOVWF  51
0C2A:  BCF    0A.3
0C2B:  CALL   09E
0C2C:  BSF    0A.3
0C2D:  MOVLW  41
0C2E:  MOVWF  51
0C2F:  BCF    0A.3
0C30:  CALL   09E
0C31:  BSF    0A.3
.................... delay_ms(1000); 
0C32:  MOVLW  04
0C33:  MOVWF  44
0C34:  MOVLW  FA
0C35:  MOVWF  47
0C36:  BCF    0A.3
0C37:  CALL   057
0C38:  BSF    0A.3
0C39:  DECFSZ 44,F
0C3A:  GOTO   434
.................... lcd_rscrol(20); 
0C3B:  MOVLW  14
0C3C:  MOVWF  44
0C3D:  BCF    0A.3
0C3E:  CALL   111
0C3F:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0C40:  MOVLW  01
0C41:  MOVWF  46
0C42:  BCF    0A.3
0C43:  CALL   06B
0C44:  BSF    0A.3
....................  delay_ms(50); 
0C45:  MOVLW  32
0C46:  MOVWF  47
0C47:  BCF    0A.3
0C48:  CALL   057
0C49:  BSF    0A.3
....................   
....................   Pout=voltmeter2*1.20; 
0C4A:  MOVF   31,W
0C4B:  MOVWF  54
0C4C:  MOVF   30,W
0C4D:  MOVWF  53
0C4E:  MOVF   2F,W
0C4F:  MOVWF  52
0C50:  MOVF   2E,W
0C51:  MOVWF  51
0C52:  MOVLW  9A
0C53:  MOVWF  58
0C54:  MOVLW  99
0C55:  MOVWF  57
0C56:  MOVLW  19
0C57:  MOVWF  56
0C58:  MOVLW  7F
0C59:  MOVWF  55
0C5A:  BCF    0A.3
0C5B:  CALL   140
0C5C:  BSF    0A.3
0C5D:  MOVF   7A,W
0C5E:  MOVWF  41
0C5F:  MOVF   79,W
0C60:  MOVWF  40
0C61:  MOVF   78,W
0C62:  MOVWF  3F
0C63:  MOVF   77,W
0C64:  MOVWF  3E
....................  lcd_line1(0); 
0C65:  CLRF   44
0C66:  BCF    0A.3
0C67:  CALL   098
0C68:  BSF    0A.3
....................  lcd_data("OUTPUT POWER:"); 
0C69:  MOVLW  50
0C6A:  BSF    03.6
0C6B:  MOVWF  0D
0C6C:  MOVLW  00
0C6D:  MOVWF  0F
0C6E:  BCF    0A.3
0C6F:  BCF    03.6
0C70:  CALL   0B5
0C71:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0C72:  MOVLW  03
0C73:  MOVWF  44
0C74:  BCF    0A.3
0C75:  CALL   10B
0C76:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pout); 
0C77:  MOVLW  89
0C78:  MOVWF  04
0C79:  MOVF   41,W
0C7A:  MOVWF  47
0C7B:  MOVF   40,W
0C7C:  MOVWF  46
0C7D:  MOVF   3F,W
0C7E:  MOVWF  45
0C7F:  MOVF   3E,W
0C80:  MOVWF  44
0C81:  MOVLW  02
0C82:  MOVWF  48
0C83:  BCF    0A.3
0C84:  CALL   4A7
0C85:  BSF    0A.3
0C86:  MOVLW  20
0C87:  MOVWF  51
0C88:  BCF    0A.3
0C89:  CALL   09E
0C8A:  BSF    0A.3
0C8B:  MOVLW  57
0C8C:  MOVWF  51
0C8D:  BCF    0A.3
0C8E:  CALL   09E
0C8F:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0C90:  MOVLW  04
0C91:  MOVWF  44
0C92:  MOVLW  FA
0C93:  MOVWF  47
0C94:  BCF    0A.3
0C95:  CALL   057
0C96:  BSF    0A.3
0C97:  DECFSZ 44,F
0C98:  GOTO   492
.................... lcd_rscrol(20); 
0C99:  MOVLW  14
0C9A:  MOVWF  44
0C9B:  BCF    0A.3
0C9C:  CALL   111
0C9D:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0C9E:  MOVLW  01
0C9F:  MOVWF  46
0CA0:  BCF    0A.3
0CA1:  CALL   06B
0CA2:  BSF    0A.3
....................  delay_ms(50); 
0CA3:  MOVLW  32
0CA4:  MOVWF  47
0CA5:  BCF    0A.3
0CA6:  CALL   057
0CA7:  BSF    0A.3
0CA8:  GOTO   0F7
....................   
.................... } 
.................... } 
....................  
0CA9:  SLEEP
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
