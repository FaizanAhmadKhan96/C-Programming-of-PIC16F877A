CCS PCM C Compiler, Version 5.015, 5967               01-May-19 13:35

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\Final code\hfk.lst

               ROM used:   3505 words (43%)
                           Largest free fragment is 2048
               RAM used:   73 (20%) at main() level
                           117 (32%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include<16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  DATA 50,2B
0005:  DATA 20,23
0006:  DATA 65,32
0007:  DATA 20,00
0008:  DATA C3,37
0009:  DATA 6E,3B
000A:  DATA 65,39
000B:  DATA F3,34
000C:  DATA 6F,37
000D:  DATA A0,2B
000E:  DATA 69,3A
000F:  DATA 68,00
0010:  DATA 45,3C
0011:  DATA E9,39
0012:  DATA F4,34
0013:  DATA EE,33
0014:  DATA A0,2A
0015:  DATA D0,29
0016:  DATA 00,01
0017:  DATA CD,30
0018:  DATA E4,32
0019:  DATA 20,31
001A:  DATA 79,1D
001B:  DATA 00,01
001C:  DATA C6,30
001D:  DATA 69,3D
001E:  DATA 61,37
001F:  DATA AC,29
0020:  DATA E8,30
0021:  DATA EB,34
0022:  DATA 72,00
0023:  DATA CD,30
0024:  DATA E4,32
0025:  DATA 20,31
0026:  DATA 79,1D
0027:  DATA 00,01
0028:  DATA 41,37
0029:  DATA 64,10
002A:  DATA C8,30
002B:  DATA 6D,3D
002C:  DATA 61,00
002D:  DATA D6,27
002E:  DATA 4C,2A
002F:  DATA C1,23
0030:  DATA 45,1D
0031:  DATA 25,33
0032:  DATA 20,2B
0033:  DATA 00,00
0034:  DATA C3,2A
0035:  DATA 52,29
0036:  DATA 45,27
0037:  DATA 54,1D
0038:  DATA 25,33
0039:  DATA A0,20
003A:  DATA 00,01
003B:  DATA 49,27
003C:  DATA D0,2A
003D:  DATA 54,10
003E:  DATA D0,27
003F:  DATA D7,22
0040:  DATA 52,1D
0041:  DATA 00,01
0042:  DATA D6,27
0043:  DATA 4C,2A
0044:  DATA C1,23
0045:  DATA 45,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 56,00
0049:  DATA C3,2A
004A:  DATA 52,29
004B:  DATA 45,27
004C:  DATA 54,1D
004D:  DATA A0,12
004E:  DATA 66,10
004F:  DATA 41,00
0050:  DATA CF,2A
0051:  DATA 54,28
0052:  DATA 55,2A
0053:  DATA 20,28
0054:  DATA CF,2B
0055:  DATA 45,29
0056:  DATA 3A,00
*
00B5:  MOVF   0B,W
00B6:  MOVWF  72
00B7:  BCF    0B.7
00B8:  BSF    03.5
00B9:  BSF    03.6
00BA:  BSF    0C.7
00BB:  BSF    0C.0
00BC:  NOP
00BD:  NOP
00BE:  BTFSS  72.7
00BF:  GOTO   0C5
00C0:  BCF    03.5
00C1:  BCF    03.6
00C2:  BSF    0B.7
00C3:  BSF    03.5
00C4:  BSF    03.6
00C5:  BCF    03.5
00C6:  MOVF   0C,W
00C7:  ANDLW  7F
00C8:  BTFSC  03.2
00C9:  GOTO   107
00CA:  MOVWF  72
00CB:  MOVF   0D,W
00CC:  MOVWF  73
00CD:  MOVF   0F,W
00CE:  MOVWF  74
00CF:  MOVF   72,W
00D0:  BSF    03.5
00D1:  BCF    03.6
00D2:  MOVWF  28
00D3:  BCF    03.5
00D4:  CALL   09E
00D5:  MOVF   73,W
00D6:  BSF    03.6
00D7:  MOVWF  0D
00D8:  MOVF   74,W
00D9:  MOVWF  0F
00DA:  BCF    03.6
00DB:  MOVF   0B,W
00DC:  MOVWF  75
00DD:  BCF    0B.7
00DE:  BSF    03.5
00DF:  BSF    03.6
00E0:  BSF    0C.7
00E1:  BSF    0C.0
00E2:  NOP
00E3:  NOP
00E4:  BTFSS  75.7
00E5:  GOTO   0EB
00E6:  BCF    03.5
00E7:  BCF    03.6
00E8:  BSF    0B.7
00E9:  BSF    03.5
00EA:  BSF    03.6
00EB:  BCF    03.5
00EC:  RLF    0C,W
00ED:  RLF    0E,W
00EE:  ANDLW  7F
00EF:  BTFSC  03.2
00F0:  GOTO   107
00F1:  MOVWF  72
00F2:  MOVF   0D,W
00F3:  MOVWF  73
00F4:  MOVF   0F,W
00F5:  MOVWF  74
00F6:  MOVF   72,W
00F7:  BSF    03.5
00F8:  BCF    03.6
00F9:  MOVWF  28
00FA:  BCF    03.5
00FB:  CALL   09E
00FC:  MOVF   73,W
00FD:  BSF    03.6
00FE:  MOVWF  0D
00FF:  MOVF   74,W
0100:  MOVWF  0F
0101:  INCF   0D,F
0102:  BTFSC  03.2
0103:  INCF   0F,F
0104:  BCF    03.6
0105:  GOTO   0B5
0106:  BSF    03.6
0107:  BCF    03.6
0108:  RETURN
*
0121:  MOVLW  8E
0122:  MOVWF  77
0123:  MOVF   74,W
0124:  MOVWF  78
0125:  MOVF   73,W
0126:  MOVWF  79
0127:  CLRF   7A
0128:  MOVF   78,F
0129:  BTFSS  03.2
012A:  GOTO   135
012B:  MOVF   79,W
012C:  MOVWF  78
012D:  CLRF   79
012E:  MOVLW  08
012F:  SUBWF  77,F
0130:  MOVF   78,F
0131:  BTFSS  03.2
0132:  GOTO   135
0133:  CLRF   77
0134:  GOTO   13D
0135:  BCF    03.0
0136:  BTFSC  78.7
0137:  GOTO   13C
0138:  RLF    79,F
0139:  RLF    78,F
013A:  DECF   77,F
013B:  GOTO   135
013C:  BCF    78.7
013D:  RETURN
013E:  BSF    03.5
013F:  MOVF   28,W
0140:  BTFSC  03.2
0141:  GOTO   1AF
0142:  MOVWF  30
0143:  MOVF   2C,W
0144:  BTFSC  03.2
0145:  GOTO   1AF
0146:  ADDWF  30,F
0147:  BTFSC  03.0
0148:  GOTO   150
0149:  MOVLW  7F
014A:  SUBWF  30,F
014B:  BTFSS  03.0
014C:  GOTO   1AF
014D:  BTFSC  03.2
014E:  GOTO   1AF
014F:  GOTO   154
0150:  MOVLW  81
0151:  ADDWF  30,F
0152:  BTFSC  03.0
0153:  GOTO   1AF
0154:  MOVF   30,W
0155:  MOVWF  77
0156:  CLRF   78
0157:  CLRF   79
0158:  CLRF   7A
0159:  MOVF   29,W
015A:  MOVWF  34
015B:  BSF    34.7
015C:  MOVF   2A,W
015D:  MOVWF  33
015E:  MOVF   2B,W
015F:  MOVWF  32
0160:  MOVLW  18
0161:  MOVWF  30
0162:  CLRF   31
0163:  BTFSS  32.0
0164:  GOTO   17D
0165:  MOVF   2F,W
0166:  ADDWF  7A,F
0167:  BTFSS  03.0
0168:  GOTO   16F
0169:  INCF   79,F
016A:  BTFSS  03.2
016B:  GOTO   16F
016C:  INCF   78,F
016D:  BTFSC  03.2
016E:  BSF    31.7
016F:  MOVF   2E,W
0170:  ADDWF  79,F
0171:  BTFSS  03.0
0172:  GOTO   176
0173:  INCF   78,F
0174:  BTFSC  03.2
0175:  BSF    31.7
0176:  MOVF   2D,W
0177:  MOVWF  2A
0178:  BSF    2A.7
0179:  MOVF   2A,W
017A:  ADDWF  78,F
017B:  BTFSC  03.0
017C:  BSF    31.7
017D:  RLF    31,F
017E:  RRF    78,F
017F:  RRF    79,F
0180:  RRF    7A,F
0181:  RRF    34,F
0182:  RRF    33,F
0183:  RRF    32,F
0184:  BCF    03.0
0185:  DECFSZ 30,F
0186:  GOTO   162
0187:  MOVLW  01
0188:  ADDWF  77,F
0189:  BTFSC  03.0
018A:  GOTO   1AF
018B:  BTFSC  78.7
018C:  GOTO   194
018D:  RLF    34,F
018E:  RLF    7A,F
018F:  RLF    79,F
0190:  RLF    78,F
0191:  DECF   77,F
0192:  BTFSC  03.2
0193:  GOTO   1AF
0194:  BTFSS  34.7
0195:  GOTO   1A5
0196:  INCF   7A,F
0197:  BTFSS  03.2
0198:  GOTO   1A5
0199:  INCF   79,F
019A:  BTFSS  03.2
019B:  GOTO   1A5
019C:  INCF   78,F
019D:  BTFSS  03.2
019E:  GOTO   1A5
019F:  RRF    78,F
01A0:  RRF    79,F
01A1:  RRF    7A,F
01A2:  INCF   77,F
01A3:  BTFSC  03.2
01A4:  GOTO   1AF
01A5:  MOVF   29,W
01A6:  MOVWF  31
01A7:  MOVF   2D,W
01A8:  XORWF  31,F
01A9:  BTFSS  31.7
01AA:  GOTO   1AD
01AB:  BSF    78.7
01AC:  GOTO   1B3
01AD:  BCF    78.7
01AE:  GOTO   1B3
01AF:  CLRF   77
01B0:  CLRF   78
01B1:  CLRF   79
01B2:  CLRF   7A
01B3:  BCF    03.5
01B4:  RETURN
01B5:  MOVF   7B,W
01B6:  BTFSC  03.2
01B7:  GOTO   287
01B8:  BSF    03.5
01B9:  MOVWF  28
01BA:  MOVF   20,W
01BB:  BTFSS  03.2
01BC:  GOTO   1BF
01BD:  BCF    03.5
01BE:  GOTO   287
01BF:  SUBWF  28,F
01C0:  BTFSS  03.0
01C1:  GOTO   1C9
01C2:  MOVLW  7F
01C3:  ADDWF  28,F
01C4:  BTFSS  03.0
01C5:  GOTO   1C8
01C6:  BCF    03.5
01C7:  GOTO   287
01C8:  GOTO   1D3
01C9:  MOVLW  81
01CA:  SUBWF  28,F
01CB:  BTFSC  03.0
01CC:  GOTO   1CF
01CD:  BCF    03.5
01CE:  GOTO   287
01CF:  BTFSS  03.2
01D0:  GOTO   1D3
01D1:  BCF    03.5
01D2:  GOTO   287
01D3:  MOVF   28,W
01D4:  MOVWF  77
01D5:  CLRF   78
01D6:  CLRF   79
01D7:  CLRF   7A
01D8:  CLRF   27
01D9:  MOVF   7C,W
01DA:  MOVWF  26
01DB:  BSF    26.7
01DC:  MOVF   7D,W
01DD:  MOVWF  25
01DE:  MOVF   7E,W
01DF:  MOVWF  24
01E0:  MOVLW  19
01E1:  MOVWF  28
01E2:  MOVF   23,W
01E3:  SUBWF  24,F
01E4:  BTFSC  03.0
01E5:  GOTO   1F6
01E6:  MOVLW  01
01E7:  SUBWF  25,F
01E8:  BTFSC  03.0
01E9:  GOTO   1F6
01EA:  SUBWF  26,F
01EB:  BTFSC  03.0
01EC:  GOTO   1F6
01ED:  SUBWF  27,F
01EE:  BTFSC  03.0
01EF:  GOTO   1F6
01F0:  INCF   27,F
01F1:  INCF   26,F
01F2:  INCF   25,F
01F3:  MOVF   23,W
01F4:  ADDWF  24,F
01F5:  GOTO   228
01F6:  MOVF   22,W
01F7:  SUBWF  25,F
01F8:  BTFSC  03.0
01F9:  GOTO   211
01FA:  MOVLW  01
01FB:  SUBWF  26,F
01FC:  BTFSC  03.0
01FD:  GOTO   211
01FE:  SUBWF  27,F
01FF:  BTFSC  03.0
0200:  GOTO   211
0201:  INCF   27,F
0202:  INCF   26,F
0203:  MOVF   22,W
0204:  ADDWF  25,F
0205:  MOVF   23,W
0206:  ADDWF  24,F
0207:  BTFSS  03.0
0208:  GOTO   228
0209:  INCF   25,F
020A:  BTFSS  03.2
020B:  GOTO   228
020C:  INCF   26,F
020D:  BTFSS  03.2
020E:  GOTO   228
020F:  INCF   27,F
0210:  GOTO   228
0211:  MOVF   21,W
0212:  IORLW  80
0213:  SUBWF  26,F
0214:  BTFSC  03.0
0215:  GOTO   227
0216:  MOVLW  01
0217:  SUBWF  27,F
0218:  BTFSC  03.0
0219:  GOTO   227
021A:  INCF   27,F
021B:  MOVF   21,W
021C:  IORLW  80
021D:  ADDWF  26,F
021E:  MOVF   22,W
021F:  ADDWF  25,F
0220:  BTFSS  03.0
0221:  GOTO   205
0222:  INCF   26,F
0223:  BTFSS  03.2
0224:  GOTO   205
0225:  INCF   27,F
0226:  GOTO   205
0227:  BSF    7A.0
0228:  DECFSZ 28,F
0229:  GOTO   22B
022A:  GOTO   236
022B:  BCF    03.0
022C:  RLF    24,F
022D:  RLF    25,F
022E:  RLF    26,F
022F:  RLF    27,F
0230:  BCF    03.0
0231:  RLF    7A,F
0232:  RLF    79,F
0233:  RLF    78,F
0234:  RLF    29,F
0235:  GOTO   1E2
0236:  BTFSS  29.0
0237:  GOTO   23E
0238:  BCF    03.0
0239:  RRF    78,F
023A:  RRF    79,F
023B:  RRF    7A,F
023C:  RRF    29,F
023D:  GOTO   242
023E:  DECFSZ 77,F
023F:  GOTO   242
0240:  BCF    03.5
0241:  GOTO   287
0242:  BTFSC  29.7
0243:  GOTO   26B
0244:  BCF    03.0
0245:  RLF    24,F
0246:  RLF    25,F
0247:  RLF    26,F
0248:  RLF    27,F
0249:  MOVF   23,W
024A:  SUBWF  24,F
024B:  BTFSC  03.0
024C:  GOTO   257
024D:  MOVLW  01
024E:  SUBWF  25,F
024F:  BTFSC  03.0
0250:  GOTO   257
0251:  SUBWF  26,F
0252:  BTFSC  03.0
0253:  GOTO   257
0254:  SUBWF  27,F
0255:  BTFSS  03.0
0256:  GOTO   27C
0257:  MOVF   22,W
0258:  SUBWF  25,F
0259:  BTFSC  03.0
025A:  GOTO   262
025B:  MOVLW  01
025C:  SUBWF  26,F
025D:  BTFSC  03.0
025E:  GOTO   262
025F:  SUBWF  27,F
0260:  BTFSS  03.0
0261:  GOTO   27C
0262:  MOVF   21,W
0263:  IORLW  80
0264:  SUBWF  26,F
0265:  BTFSC  03.0
0266:  GOTO   26B
0267:  MOVLW  01
0268:  SUBWF  27,F
0269:  BTFSS  03.0
026A:  GOTO   27C
026B:  INCF   7A,F
026C:  BTFSS  03.2
026D:  GOTO   27C
026E:  INCF   79,F
026F:  BTFSS  03.2
0270:  GOTO   27C
0271:  INCF   78,F
0272:  BTFSS  03.2
0273:  GOTO   27C
0274:  INCF   77,F
0275:  BTFSS  03.2
0276:  GOTO   279
0277:  BCF    03.5
0278:  GOTO   287
0279:  RRF    78,F
027A:  RRF    79,F
027B:  RRF    7A,F
027C:  MOVF   7C,W
027D:  MOVWF  28
027E:  MOVF   21,W
027F:  XORWF  28,F
0280:  BTFSS  28.7
0281:  GOTO   284
0282:  BSF    78.7
0283:  GOTO   28C
0284:  BCF    78.7
0285:  GOTO   28C
0286:  BCF    03.5
0287:  CLRF   77
0288:  CLRF   78
0289:  CLRF   79
028A:  CLRF   7A
028B:  BSF    03.5
028C:  BCF    03.5
028D:  RETURN
028E:  MOVLW  80
028F:  BTFSS  03.1
0290:  GOTO   294
0291:  BSF    03.5
0292:  XORWF  21,F
0293:  BCF    03.5
0294:  BSF    03.5
0295:  CLRF   26
0296:  CLRF   27
0297:  MOVF   7C,W
0298:  MOVWF  25
0299:  MOVF   21,W
029A:  XORWF  25,F
029B:  MOVF   7B,W
029C:  BTFSC  03.2
029D:  GOTO   382
029E:  MOVWF  24
029F:  MOVWF  77
02A0:  MOVF   20,W
02A1:  BTFSC  03.2
02A2:  GOTO   38B
02A3:  SUBWF  24,F
02A4:  BTFSC  03.2
02A5:  GOTO   327
02A6:  BTFSS  03.0
02A7:  GOTO   2E5
02A8:  MOVF   21,W
02A9:  MOVWF  2A
02AA:  BSF    2A.7
02AB:  MOVF   22,W
02AC:  MOVWF  29
02AD:  MOVF   23,W
02AE:  MOVWF  28
02AF:  CLRF   27
02B0:  BCF    03.0
02B1:  RRF    2A,F
02B2:  RRF    29,F
02B3:  RRF    28,F
02B4:  RRF    27,F
02B5:  DECFSZ 24,F
02B6:  GOTO   2AF
02B7:  BTFSS  25.7
02B8:  GOTO   2BC
02B9:  BSF    26.0
02BA:  GOTO   39F
02BB:  BCF    26.0
02BC:  BCF    24.0
02BD:  BSF    26.4
02BE:  MOVLW  7E
02BF:  MOVWF  04
02C0:  BCF    03.7
02C1:  GOTO   3B4
02C2:  BCF    26.4
02C3:  BTFSC  25.7
02C4:  GOTO   2CF
02C5:  BTFSS  24.0
02C6:  GOTO   2DA
02C7:  RRF    2A,F
02C8:  RRF    29,F
02C9:  RRF    28,F
02CA:  RRF    27,F
02CB:  INCF   77,F
02CC:  BTFSC  03.2
02CD:  GOTO   39A
02CE:  GOTO   2DA
02CF:  BTFSC  2A.7
02D0:  GOTO   2DD
02D1:  BCF    03.0
02D2:  RLF    27,F
02D3:  RLF    28,F
02D4:  RLF    29,F
02D5:  RLF    2A,F
02D6:  DECF   77,F
02D7:  BTFSC  03.2
02D8:  GOTO   39A
02D9:  GOTO   2CF
02DA:  BSF    26.6
02DB:  GOTO   347
02DC:  BCF    26.6
02DD:  MOVF   7C,W
02DE:  MOVWF  25
02DF:  BTFSS  25.7
02E0:  GOTO   2E3
02E1:  BSF    2A.7
02E2:  GOTO   393
02E3:  BCF    2A.7
02E4:  GOTO   393
02E5:  MOVF   20,W
02E6:  MOVWF  24
02E7:  MOVWF  77
02E8:  MOVF   7B,W
02E9:  SUBWF  24,F
02EA:  MOVF   7C,W
02EB:  MOVWF  2A
02EC:  BSF    2A.7
02ED:  MOVF   7D,W
02EE:  MOVWF  29
02EF:  MOVF   7E,W
02F0:  MOVWF  28
02F1:  CLRF   27
02F2:  BCF    03.0
02F3:  RRF    2A,F
02F4:  RRF    29,F
02F5:  RRF    28,F
02F6:  RRF    27,F
02F7:  DECFSZ 24,F
02F8:  GOTO   2F1
02F9:  BTFSS  25.7
02FA:  GOTO   2FE
02FB:  BSF    26.1
02FC:  GOTO   39F
02FD:  BCF    26.1
02FE:  BCF    24.0
02FF:  BSF    26.5
0300:  MOVLW  A3
0301:  MOVWF  04
0302:  BCF    03.7
0303:  GOTO   3B4
0304:  BCF    26.5
0305:  BTFSC  25.7
0306:  GOTO   311
0307:  BTFSS  24.0
0308:  GOTO   31C
0309:  RRF    2A,F
030A:  RRF    29,F
030B:  RRF    28,F
030C:  RRF    27,F
030D:  INCF   77,F
030E:  BTFSC  03.2
030F:  GOTO   39A
0310:  GOTO   31C
0311:  BTFSC  2A.7
0312:  GOTO   31F
0313:  BCF    03.0
0314:  RLF    27,F
0315:  RLF    28,F
0316:  RLF    29,F
0317:  RLF    2A,F
0318:  DECF   77,F
0319:  BTFSC  03.2
031A:  GOTO   39A
031B:  GOTO   311
031C:  BSF    26.7
031D:  GOTO   347
031E:  BCF    26.7
031F:  MOVF   21,W
0320:  MOVWF  25
0321:  BTFSS  25.7
0322:  GOTO   325
0323:  BSF    2A.7
0324:  GOTO   393
0325:  BCF    2A.7
0326:  GOTO   393
0327:  MOVF   21,W
0328:  MOVWF  2A
0329:  BSF    2A.7
032A:  MOVF   22,W
032B:  MOVWF  29
032C:  MOVF   23,W
032D:  MOVWF  28
032E:  BTFSS  25.7
032F:  GOTO   334
0330:  BCF    2A.7
0331:  BSF    26.2
0332:  GOTO   39F
0333:  BCF    26.2
0334:  CLRF   27
0335:  BCF    24.0
0336:  MOVLW  7E
0337:  MOVWF  04
0338:  BCF    03.7
0339:  GOTO   3B4
033A:  BTFSC  25.7
033B:  GOTO   35D
033C:  MOVF   7C,W
033D:  MOVWF  25
033E:  BTFSS  24.0
033F:  GOTO   347
0340:  RRF    2A,F
0341:  RRF    29,F
0342:  RRF    28,F
0343:  RRF    27,F
0344:  INCF   77,F
0345:  BTFSC  03.2
0346:  GOTO   39A
0347:  BTFSS  27.7
0348:  GOTO   358
0349:  INCF   28,F
034A:  BTFSS  03.2
034B:  GOTO   358
034C:  INCF   29,F
034D:  BTFSS  03.2
034E:  GOTO   358
034F:  INCF   2A,F
0350:  BTFSS  03.2
0351:  GOTO   358
0352:  RRF    2A,F
0353:  RRF    29,F
0354:  RRF    28,F
0355:  INCF   77,F
0356:  BTFSC  03.2
0357:  GOTO   39A
0358:  BTFSC  26.6
0359:  GOTO   2DC
035A:  BTFSC  26.7
035B:  GOTO   31E
035C:  GOTO   37C
035D:  MOVLW  80
035E:  XORWF  2A,F
035F:  BTFSS  2A.7
0360:  GOTO   365
0361:  GOTO   39F
0362:  MOVF   21,W
0363:  MOVWF  25
0364:  GOTO   372
0365:  MOVF   7C,W
0366:  MOVWF  25
0367:  MOVF   2A,F
0368:  BTFSS  03.2
0369:  GOTO   372
036A:  MOVF   29,F
036B:  BTFSS  03.2
036C:  GOTO   372
036D:  MOVF   28,F
036E:  BTFSS  03.2
036F:  GOTO   372
0370:  CLRF   77
0371:  GOTO   393
0372:  BTFSC  2A.7
0373:  GOTO   37C
0374:  BCF    03.0
0375:  RLF    27,F
0376:  RLF    28,F
0377:  RLF    29,F
0378:  RLF    2A,F
0379:  DECFSZ 77,F
037A:  GOTO   372
037B:  GOTO   39A
037C:  BTFSS  25.7
037D:  GOTO   380
037E:  BSF    2A.7
037F:  GOTO   393
0380:  BCF    2A.7
0381:  GOTO   393
0382:  MOVF   20,W
0383:  MOVWF  77
0384:  MOVF   21,W
0385:  MOVWF  2A
0386:  MOVF   22,W
0387:  MOVWF  29
0388:  MOVF   23,W
0389:  MOVWF  28
038A:  GOTO   393
038B:  MOVF   7B,W
038C:  MOVWF  77
038D:  MOVF   7C,W
038E:  MOVWF  2A
038F:  MOVF   7D,W
0390:  MOVWF  29
0391:  MOVF   7E,W
0392:  MOVWF  28
0393:  MOVF   2A,W
0394:  MOVWF  78
0395:  MOVF   29,W
0396:  MOVWF  79
0397:  MOVF   28,W
0398:  MOVWF  7A
0399:  GOTO   3D2
039A:  CLRF   77
039B:  CLRF   78
039C:  CLRF   79
039D:  CLRF   7A
039E:  GOTO   3D2
039F:  CLRF   27
03A0:  COMF   28,F
03A1:  COMF   29,F
03A2:  COMF   2A,F
03A3:  COMF   27,F
03A4:  INCF   27,F
03A5:  BTFSS  03.2
03A6:  GOTO   3AD
03A7:  INCF   28,F
03A8:  BTFSS  03.2
03A9:  GOTO   3AD
03AA:  INCF   29,F
03AB:  BTFSC  03.2
03AC:  INCF   2A,F
03AD:  BTFSC  26.0
03AE:  GOTO   2BB
03AF:  BTFSC  26.1
03B0:  GOTO   2FD
03B1:  BTFSC  26.2
03B2:  GOTO   333
03B3:  GOTO   362
03B4:  MOVF   00,W
03B5:  ADDWF  28,F
03B6:  BTFSS  03.0
03B7:  GOTO   3BE
03B8:  INCF   29,F
03B9:  BTFSS  03.2
03BA:  GOTO   3BE
03BB:  INCF   2A,F
03BC:  BTFSC  03.2
03BD:  BSF    24.0
03BE:  DECF   04,F
03BF:  MOVF   00,W
03C0:  ADDWF  29,F
03C1:  BTFSS  03.0
03C2:  GOTO   3C6
03C3:  INCF   2A,F
03C4:  BTFSC  03.2
03C5:  BSF    24.0
03C6:  DECF   04,F
03C7:  MOVF   00,W
03C8:  BTFSS  00.7
03C9:  XORLW  80
03CA:  ADDWF  2A,F
03CB:  BTFSC  03.0
03CC:  BSF    24.0
03CD:  BTFSC  26.4
03CE:  GOTO   2C2
03CF:  BTFSC  26.5
03D0:  GOTO   304
03D1:  GOTO   33A
03D2:  BCF    03.5
03D3:  RETURN
03D4:  MOVF   0B,W
03D5:  MOVWF  73
03D6:  BCF    0B.7
03D7:  BSF    03.5
03D8:  BSF    03.6
03D9:  BSF    0C.7
03DA:  BSF    0C.0
03DB:  NOP
03DC:  NOP
03DD:  BTFSS  73.7
03DE:  GOTO   3E4
03DF:  BCF    03.5
03E0:  BCF    03.6
03E1:  BSF    0B.7
03E2:  BSF    03.5
03E3:  BSF    03.6
03E4:  BTFSC  03.0
03E5:  GOTO   40D
03E6:  BCF    03.5
03E7:  MOVF   0C,W
03E8:  ANDLW  7F
03E9:  MOVWF  73
03EA:  MOVF   0D,W
03EB:  MOVWF  74
03EC:  MOVF   0F,W
03ED:  MOVWF  75
03EE:  MOVF   73,W
03EF:  BSF    03.5
03F0:  BCF    03.6
03F1:  MOVWF  28
03F2:  BCF    03.5
03F3:  CALL   09E
03F4:  MOVF   74,W
03F5:  BSF    03.6
03F6:  MOVWF  0D
03F7:  MOVF   75,W
03F8:  MOVWF  0F
03F9:  BCF    03.6
03FA:  MOVF   0B,W
03FB:  MOVWF  76
03FC:  BCF    0B.7
03FD:  BSF    03.5
03FE:  BSF    03.6
03FF:  BSF    0C.7
0400:  BSF    0C.0
0401:  NOP
0402:  NOP
0403:  BTFSS  76.7
0404:  GOTO   40A
0405:  BCF    03.5
0406:  BCF    03.6
0407:  BSF    0B.7
0408:  BSF    03.5
0409:  BSF    03.6
040A:  DECFSZ 72,F
040B:  GOTO   40D
040C:  GOTO   42B
040D:  BCF    03.5
040E:  RLF    0C,W
040F:  RLF    0E,W
0410:  ANDLW  7F
0411:  MOVWF  73
0412:  MOVF   0D,W
0413:  MOVWF  74
0414:  MOVF   0F,W
0415:  MOVWF  75
0416:  MOVF   73,W
0417:  BSF    03.5
0418:  BCF    03.6
0419:  MOVWF  28
041A:  BCF    03.5
041B:  CALL   09E
041C:  MOVF   74,W
041D:  BSF    03.6
041E:  MOVWF  0D
041F:  MOVF   75,W
0420:  MOVWF  0F
0421:  INCF   0D,F
0422:  BTFSC  03.2
0423:  INCF   0F,F
0424:  BCF    03.0
0425:  DECFSZ 72,F
0426:  GOTO   428
0427:  GOTO   42A
0428:  BCF    03.6
0429:  GOTO   3D4
042A:  BSF    03.5
042B:  BCF    03.5
042C:  BCF    03.6
042D:  RETURN
042E:  BTFSC  03.1
042F:  GOTO   433
0430:  MOVLW  B0
0431:  MOVWF  04
0432:  BCF    03.7
0433:  CLRF   77
0434:  CLRF   78
0435:  CLRF   79
0436:  CLRF   7A
0437:  BSF    03.5
0438:  CLRF   30
0439:  CLRF   31
043A:  CLRF   32
043B:  CLRF   33
043C:  MOVF   2F,W
043D:  IORWF  2E,W
043E:  IORWF  2D,W
043F:  IORWF  2C,W
0440:  BTFSC  03.2
0441:  GOTO   472
0442:  MOVLW  20
0443:  MOVWF  34
0444:  BCF    03.0
0445:  RLF    28,F
0446:  RLF    29,F
0447:  RLF    2A,F
0448:  RLF    2B,F
0449:  RLF    30,F
044A:  RLF    31,F
044B:  RLF    32,F
044C:  RLF    33,F
044D:  MOVF   2F,W
044E:  SUBWF  33,W
044F:  BTFSS  03.2
0450:  GOTO   45B
0451:  MOVF   2E,W
0452:  SUBWF  32,W
0453:  BTFSS  03.2
0454:  GOTO   45B
0455:  MOVF   2D,W
0456:  SUBWF  31,W
0457:  BTFSS  03.2
0458:  GOTO   45B
0459:  MOVF   2C,W
045A:  SUBWF  30,W
045B:  BTFSS  03.0
045C:  GOTO   46C
045D:  MOVF   2C,W
045E:  SUBWF  30,F
045F:  MOVF   2D,W
0460:  BTFSS  03.0
0461:  INCFSZ 2D,W
0462:  SUBWF  31,F
0463:  MOVF   2E,W
0464:  BTFSS  03.0
0465:  INCFSZ 2E,W
0466:  SUBWF  32,F
0467:  MOVF   2F,W
0468:  BTFSS  03.0
0469:  INCFSZ 2F,W
046A:  SUBWF  33,F
046B:  BSF    03.0
046C:  RLF    77,F
046D:  RLF    78,F
046E:  RLF    79,F
046F:  RLF    7A,F
0470:  DECFSZ 34,F
0471:  GOTO   444
0472:  MOVF   30,W
0473:  MOVWF  00
0474:  INCF   04,F
0475:  MOVF   31,W
0476:  MOVWF  00
0477:  INCF   04,F
0478:  MOVF   32,W
0479:  MOVWF  00
047A:  INCF   04,F
047B:  MOVF   33,W
047C:  MOVWF  00
047D:  BCF    03.5
047E:  RETURN
047F:  MOVF   04,W
0480:  BSF    03.5
0481:  MOVWF  20
0482:  MOVF   76,W
0483:  MOVWF  22
0484:  BTFSC  03.2
0485:  GOTO   4A1
0486:  MOVF   75,W
0487:  MOVWF  2B
0488:  MOVF   74,W
0489:  MOVWF  2A
048A:  MOVF   73,W
048B:  MOVWF  29
048C:  MOVF   72,W
048D:  MOVWF  28
048E:  CLRF   2F
048F:  CLRF   2E
0490:  MOVLW  20
0491:  MOVWF  2D
0492:  MOVLW  82
0493:  MOVWF  2C
0494:  BCF    03.5
0495:  CALL   13E
0496:  MOVF   7A,W
0497:  MOVWF  75
0498:  MOVF   79,W
0499:  MOVWF  74
049A:  MOVF   78,W
049B:  MOVWF  73
049C:  MOVF   77,W
049D:  MOVWF  72
049E:  BSF    03.5
049F:  DECFSZ 22,F
04A0:  GOTO   486
04A1:  MOVF   75,W
04A2:  MOVWF  2B
04A3:  MOVF   74,W
04A4:  MOVWF  2A
04A5:  MOVF   73,W
04A6:  MOVWF  29
04A7:  MOVF   72,W
04A8:  MOVWF  28
04A9:  MOVF   28,W
04AA:  SUBLW  B6
04AB:  MOVWF  28
04AC:  CLRF   7A
04AD:  MOVF   29,W
04AE:  MOVWF  2C
04AF:  BSF    29.7
04B0:  BCF    03.0
04B1:  RRF    29,F
04B2:  RRF    2A,F
04B3:  RRF    2B,F
04B4:  RRF    7A,F
04B5:  RRF    79,F
04B6:  RRF    78,F
04B7:  RRF    77,F
04B8:  DECFSZ 28,F
04B9:  GOTO   4B0
04BA:  BTFSS  2C.7
04BB:  GOTO   4C7
04BC:  COMF   77,F
04BD:  COMF   78,F
04BE:  COMF   79,F
04BF:  COMF   7A,F
04C0:  INCF   77,F
04C1:  BTFSC  03.2
04C2:  INCF   78,F
04C3:  BTFSC  03.2
04C4:  INCF   79,F
04C5:  BTFSC  03.2
04C6:  INCF   7A,F
04C7:  MOVF   7A,W
04C8:  MOVWF  75
04C9:  MOVF   79,W
04CA:  MOVWF  74
04CB:  MOVF   78,W
04CC:  MOVWF  73
04CD:  MOVF   77,W
04CE:  MOVWF  72
04CF:  BTFSS  75.7
04D0:  GOTO   4DE
04D1:  DECF   20,F
04D2:  BSF    20.5
04D3:  COMF   72,F
04D4:  COMF   73,F
04D5:  COMF   74,F
04D6:  COMF   75,F
04D7:  INCF   72,F
04D8:  BTFSC  03.2
04D9:  INCF   73,F
04DA:  BTFSC  03.2
04DB:  INCF   74,F
04DC:  BTFSC  03.2
04DD:  INCF   75,F
04DE:  MOVLW  3B
04DF:  MOVWF  27
04E0:  MOVLW  9A
04E1:  MOVWF  26
04E2:  MOVLW  CA
04E3:  MOVWF  25
04E4:  CLRF   24
04E5:  MOVLW  0A
04E6:  MOVWF  22
04E7:  MOVF   76,W
04E8:  BTFSC  03.2
04E9:  INCF   20,F
04EA:  BSF    03.1
04EB:  MOVLW  72
04EC:  MOVWF  04
04ED:  BCF    03.7
04EE:  MOVF   75,W
04EF:  MOVWF  2B
04F0:  MOVF   74,W
04F1:  MOVWF  2A
04F2:  MOVF   73,W
04F3:  MOVWF  29
04F4:  MOVF   72,W
04F5:  MOVWF  28
04F6:  MOVF   27,W
04F7:  MOVWF  2F
04F8:  MOVF   26,W
04F9:  MOVWF  2E
04FA:  MOVF   25,W
04FB:  MOVWF  2D
04FC:  MOVF   24,W
04FD:  MOVWF  2C
04FE:  BCF    03.5
04FF:  CALL   42E
0500:  MOVF   78,W
0501:  MOVF   77,F
0502:  BTFSS  03.2
0503:  GOTO   51B
0504:  INCF   76,W
0505:  BSF    03.5
0506:  SUBWF  22,W
0507:  BTFSS  03.2
0508:  GOTO   50B
0509:  BCF    03.5
050A:  GOTO   51B
050B:  MOVF   20,W
050C:  BTFSC  03.2
050D:  GOTO   51E
050E:  ANDLW  0F
050F:  SUBWF  22,W
0510:  BTFSC  03.2
0511:  GOTO   514
0512:  BTFSC  03.0
0513:  GOTO   556
0514:  BTFSC  20.7
0515:  GOTO   556
0516:  BTFSC  20.6
0517:  GOTO   51E
0518:  MOVLW  20
0519:  GOTO   550
051A:  BCF    03.5
051B:  MOVLW  20
051C:  BSF    03.5
051D:  ANDWF  20,F
051E:  BTFSS  20.5
051F:  GOTO   52E
0520:  BCF    20.5
0521:  MOVF   76,W
0522:  BTFSS  03.2
0523:  DECF   20,F
0524:  MOVF   77,W
0525:  MOVWF  20
0526:  MOVLW  2D
0527:  MOVWF  28
0528:  BCF    03.5
0529:  CALL   09E
052A:  BSF    03.5
052B:  MOVF   20,W
052C:  MOVWF  77
052D:  CLRF   20
052E:  MOVF   76,W
052F:  SUBWF  22,W
0530:  BTFSS  03.2
0531:  GOTO   53E
0532:  MOVF   77,W
0533:  MOVWF  20
0534:  MOVLW  2E
0535:  MOVWF  28
0536:  BCF    03.5
0537:  CALL   09E
0538:  BSF    03.5
0539:  MOVF   20,W
053A:  MOVWF  77
053B:  MOVLW  20
053C:  ANDWF  20,F
053D:  MOVLW  00
053E:  MOVLW  30
053F:  BTFSS  20.5
0540:  GOTO   550
0541:  BCF    20.5
0542:  MOVF   76,W
0543:  BTFSS  03.2
0544:  DECF   20,F
0545:  MOVF   77,W
0546:  MOVWF  20
0547:  MOVLW  2D
0548:  MOVWF  28
0549:  BCF    03.5
054A:  CALL   09E
054B:  BSF    03.5
054C:  MOVF   20,W
054D:  MOVWF  77
054E:  CLRF   20
054F:  MOVLW  30
0550:  ADDWF  77,F
0551:  MOVF   77,W
0552:  MOVWF  28
0553:  BCF    03.5
0554:  CALL   09E
0555:  BSF    03.5
0556:  BCF    03.1
0557:  MOVF   27,W
0558:  MOVWF  2B
0559:  MOVF   26,W
055A:  MOVWF  2A
055B:  MOVF   25,W
055C:  MOVWF  29
055D:  MOVF   24,W
055E:  MOVWF  28
055F:  CLRF   2F
0560:  CLRF   2E
0561:  CLRF   2D
0562:  MOVLW  0A
0563:  MOVWF  2C
0564:  BCF    03.5
0565:  CALL   42E
0566:  MOVF   7A,W
0567:  BSF    03.5
0568:  MOVWF  27
0569:  MOVF   79,W
056A:  MOVWF  26
056B:  MOVF   78,W
056C:  MOVWF  25
056D:  MOVF   77,W
056E:  MOVWF  24
056F:  DECFSZ 22,F
0570:  GOTO   4EA
0571:  BCF    03.5
0572:  RETURN
0573:  MOVF   74,W
0574:  BSF    03.5
0575:  MOVWF  20
0576:  MOVF   7C,W
0577:  XORWF  20,F
0578:  BTFSS  20.7
0579:  GOTO   57F
057A:  BCF    03.2
057B:  BCF    03.0
057C:  BTFSC  74.7
057D:  BSF    03.0
057E:  GOTO   5B2
057F:  MOVF   74,W
0580:  MOVWF  20
0581:  MOVF   7B,W
0582:  MOVWF  21
0583:  MOVF   73,W
0584:  SUBWF  21,F
0585:  BTFSC  03.2
0586:  GOTO   58D
0587:  BTFSS  20.7
0588:  GOTO   5B2
0589:  MOVF   03,W
058A:  XORLW  01
058B:  MOVWF  03
058C:  GOTO   5B2
058D:  MOVF   7C,W
058E:  MOVWF  21
058F:  MOVF   74,W
0590:  SUBWF  21,F
0591:  BTFSC  03.2
0592:  GOTO   599
0593:  BTFSS  20.7
0594:  GOTO   5B2
0595:  MOVF   03,W
0596:  XORLW  01
0597:  MOVWF  03
0598:  GOTO   5B2
0599:  MOVF   7D,W
059A:  MOVWF  21
059B:  MOVF   75,W
059C:  SUBWF  21,F
059D:  BTFSC  03.2
059E:  GOTO   5A5
059F:  BTFSS  20.7
05A0:  GOTO   5B2
05A1:  MOVF   03,W
05A2:  XORLW  01
05A3:  MOVWF  03
05A4:  GOTO   5B2
05A5:  MOVF   7E,W
05A6:  MOVWF  21
05A7:  MOVF   76,W
05A8:  SUBWF  21,F
05A9:  BTFSC  03.2
05AA:  GOTO   5B1
05AB:  BTFSS  20.7
05AC:  GOTO   5B2
05AD:  MOVF   03,W
05AE:  XORLW  01
05AF:  MOVWF  03
05B0:  GOTO   5B2
05B1:  BCF    03.0
05B2:  BCF    03.5
05B3:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,BROWNOUT,NOWDT,NOLVP 
.................... #use delay(clock=20M) 
*
0057:  MOVLW  75
0058:  MOVWF  04
0059:  BCF    03.7
005A:  MOVF   00,W
005B:  BTFSC  03.2
005C:  GOTO   06A
005D:  MOVLW  06
005E:  MOVWF  78
005F:  CLRF   77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  DECFSZ 78,F
0063:  GOTO   05F
0064:  MOVLW  7B
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 00,F
0069:  GOTO   05D
006A:  RETURN
.................... #endif 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
081F:  BCF    03.5
0820:  CLRF   20
0821:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #define lcd_rs pin_d0 
.................... #define lcd_en pin_d1 
.................... #define sd pin_c0 
.................... #define on output_high 
.................... #define off output_low 
.................... #define fan pin_d7 
.................... #define relay pin_d6 
.................... #define green pin_d5 
.................... #define yellow2 pin_d4 
.................... #define yellow1 pin_c7 
.................... #define red pin_c6 
.................... #define WAPDA pin_d3 
.................... #define solar pin_d2 
.................... #define disp_clear 0b00000001 
.................... #define disp_control 0b00001110 
.................... #define func_set 0b00111000 
.................... #define lscrol 0b00011000 
.................... #define rscrol 0b00011100 
.................... #define line1 0b10000000 
.................... #define line2 0b11000000 
.................... float PrevVsolar=0,PrevIsolar=0,PrevPsolar=0,adc_value,Vsolar,Vbattery; 
.................... float Isolar,Ibattery,Pin,Pout,delta_V,delta_P,delta_I; 
.................... int pwm,pwm_start=40,pwm_min=35,pwm_max=49,delta=1; 
.................... void lcd_init (void); 
.................... void lcd_data (unsigned char); 
.................... void lcd_cmd (unsigned char); 
.................... void lcd_lscrol (unsigned char); 
.................... void lcd_rscrol (unsigned char); 
.................... void lcd_line1 (unsigned char); 
.................... void lcd_line2 (unsigned char); 
.................... void lcd_init (void) 
.................... { 
.................... delay_ms(300); 
*
0082:  MOVLW  02
0083:  MOVWF  72
0084:  MOVLW  96
0085:  MOVWF  75
0086:  CALL   057
0087:  DECFSZ 72,F
0088:  GOTO   084
.................... lcd_cmd (func_set); 
0089:  MOVLW  38
008A:  MOVWF  74
008B:  CALL   06B
.................... lcd_cmd (disp_control); 
008C:  MOVLW  0E
008D:  MOVWF  74
008E:  CALL   06B
.................... lcd_cmd(disp_clear); 
008F:  MOVLW  01
0090:  MOVWF  74
0091:  CALL   06B
....................  delay_ms(50); 
0092:  MOVLW  32
0093:  MOVWF  75
0094:  CALL   057
0095:  BSF    0A.3
0096:  BCF    0A.4
0097:  GOTO   026 (RETURN)
.................... } 
.................... void lcd_cmd (unsigned char i) 
.................... { 
.................... output_low(lcd_rs); 
*
006B:  BSF    03.5
006C:  BCF    08.0
006D:  BCF    03.5
006E:  BCF    08.0
.................... output_b(i); 
006F:  BSF    03.5
0070:  CLRF   06
0071:  MOVF   74,W
0072:  BCF    03.5
0073:  MOVWF  06
.................... output_high(lcd_en); 
0074:  BSF    03.5
0075:  BCF    08.1
0076:  BCF    03.5
0077:  BSF    08.1
.................... delay_us(100); 
0078:  MOVLW  A6
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  NOP
.................... output_low(lcd_en); 
007D:  BSF    03.5
007E:  BCF    08.1
007F:  BCF    03.5
0080:  BCF    08.1
0081:  RETURN
.................... } 
.................... void lcd_data (unsigned char i) 
.................... { 
.................... output_high(lcd_rs); 
*
009E:  BSF    03.5
009F:  BCF    08.0
00A0:  BCF    03.5
00A1:  BSF    08.0
.................... output_b(i); 
00A2:  BSF    03.5
00A3:  CLRF   06
00A4:  MOVF   28,W
00A5:  BCF    03.5
00A6:  MOVWF  06
.................... output_high(lcd_en); 
00A7:  BSF    03.5
00A8:  BCF    08.1
00A9:  BCF    03.5
00AA:  BSF    08.1
.................... delay_us(100); 
00AB:  MOVLW  A6
00AC:  MOVWF  77
00AD:  DECFSZ 77,F
00AE:  GOTO   0AD
00AF:  NOP
.................... output_low(lcd_en); 
00B0:  BSF    03.5
00B1:  BCF    08.1
00B2:  BCF    03.5
00B3:  BCF    08.1
00B4:  RETURN
.................... } 
.................... void lcd_lscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
.................... { 
.................... lcd_cmd(lscrol); 
.................... delay_ms(300); 
.................... } 
.................... } 
.................... void lcd_rscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
*
010F:  CLRF   73
0110:  MOVF   72,W
0111:  SUBWF  73,W
0112:  BTFSC  03.0
0113:  GOTO   120
.................... { 
.................... lcd_cmd(rscrol); 
0114:  MOVLW  1C
0115:  MOVWF  74
0116:  CALL   06B
.................... delay_ms(300); 
0117:  MOVLW  02
0118:  MOVWF  74
0119:  MOVLW  96
011A:  MOVWF  75
011B:  CALL   057
011C:  DECFSZ 74,F
011D:  GOTO   119
011E:  INCF   73,F
011F:  GOTO   110
.................... } 
0120:  RETURN
.................... } 
.................... void lcd_line1 (unsigned char position) 
.................... { 
.................... lcd_cmd(line1 + position); 
*
0098:  MOVLW  80
0099:  ADDWF  72,W
009A:  MOVWF  73
009B:  MOVWF  74
009C:  CALL   06B
009D:  RETURN
.................... } 
.................... void lcd_line2 (unsigned char position) 
.................... { 
.................... lcd_cmd(line2 + position); 
*
0109:  MOVLW  C0
010A:  ADDWF  72,W
010B:  MOVWF  73
010C:  MOVWF  74
010D:  CALL   06B
010E:  RETURN
.................... } 
.................... void main(void) 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   29
0804:  CLRF   28
0805:  CLRF   27
0806:  CLRF   26
0807:  CLRF   2D
0808:  CLRF   2C
0809:  CLRF   2B
080A:  CLRF   2A
080B:  CLRF   31
080C:  CLRF   30
080D:  CLRF   2F
080E:  CLRF   2E
080F:  MOVLW  28
0810:  MOVWF  5B
0811:  MOVLW  23
0812:  MOVWF  5C
0813:  MOVLW  31
0814:  MOVWF  5D
0815:  MOVLW  01
0816:  MOVWF  5E
0817:  MOVLW  FF
0818:  MOVWF  5F
0819:  BSF    03.5
081A:  BSF    1F.0
081B:  BSF    1F.1
081C:  BSF    1F.2
081D:  BCF    1F.3
081E:  BCF    03.7
.................... { 
.................... pwm=pwm_start; 
*
0822:  MOVF   5B,W
0823:  MOVWF  5A
.................... lcd_init(); 
0824:  BCF    0A.3
0825:  GOTO   082
0826:  BSF    0A.3
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
0827:  BSF    03.5
0828:  BCF    1F.0
0829:  BCF    1F.1
082A:  BCF    1F.2
082B:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_8); 
082C:  BCF    03.5
082D:  BSF    1F.6
082E:  BCF    1F.7
082F:  BSF    03.5
0830:  BSF    1F.7
0831:  BCF    03.5
0832:  BSF    1F.0
.................... output_low(PIN_C1);            
0833:  BCF    5F.1
0834:  MOVF   5F,W
0835:  BSF    03.5
0836:  MOVWF  07
0837:  BCF    03.5
0838:  BCF    07.1
.................... setup_ccp1(CCP_PWM);        
0839:  BCF    5F.2
083A:  MOVF   5F,W
083B:  BSF    03.5
083C:  MOVWF  07
083D:  BCF    03.5
083E:  BCF    07.2
083F:  MOVLW  0C
0840:  MOVWF  17
.................... setup_timer_2(T2_DIV_BY_1,49,1); 
0841:  MOVLW  00
0842:  MOVWF  78
0843:  IORLW  04
0844:  MOVWF  12
0845:  MOVLW  31
0846:  BSF    03.5
0847:  MOVWF  12
.................... int i=0; 
0848:  BCF    03.5
0849:  CLRF   60
.................... do 
.................... { 
.................... lcd_line1 (3); 
084A:  MOVLW  03
084B:  MOVWF  72
084C:  BCF    0A.3
084D:  CALL   098
084E:  BSF    0A.3
.................... lcd_data ("PV Fed "); 
084F:  MOVLW  04
0850:  BSF    03.6
0851:  MOVWF  0D
0852:  MOVLW  00
0853:  MOVWF  0F
0854:  BCF    0A.3
0855:  BCF    03.6
0856:  CALL   0B5
0857:  BSF    0A.3
.................... lcd_line2 (0); 
0858:  CLRF   72
0859:  BCF    0A.3
085A:  CALL   109
085B:  BSF    0A.3
.................... lcd_data ("Conversion With"); 
085C:  MOVLW  08
085D:  BSF    03.6
085E:  MOVWF  0D
085F:  MOVLW  00
0860:  MOVWF  0F
0861:  BCF    0A.3
0862:  BCF    03.6
0863:  CALL   0B5
0864:  BSF    0A.3
.................... delay_ms(1000); 
0865:  MOVLW  04
0866:  MOVWF  72
0867:  MOVLW  FA
0868:  MOVWF  75
0869:  BCF    0A.3
086A:  CALL   057
086B:  BSF    0A.3
086C:  DECFSZ 72,F
086D:  GOTO   067
.................... lcd_rscrol(20); 
086E:  MOVLW  14
086F:  MOVWF  72
0870:  BCF    0A.3
0871:  CALL   10F
0872:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0873:  MOVLW  01
0874:  MOVWF  74
0875:  BCF    0A.3
0876:  CALL   06B
0877:  BSF    0A.3
....................  delay_ms(50); 
0878:  MOVLW  32
0879:  MOVWF  75
087A:  BCF    0A.3
087B:  CALL   057
087C:  BSF    0A.3
....................  lcd_line1 (0); 
087D:  CLRF   72
087E:  BCF    0A.3
087F:  CALL   098
0880:  BSF    0A.3
.................... lcd_data ("Existing UPS"); 
0881:  MOVLW  10
0882:  BSF    03.6
0883:  MOVWF  0D
0884:  MOVLW  00
0885:  MOVWF  0F
0886:  BCF    0A.3
0887:  BCF    03.6
0888:  CALL   0B5
0889:  BSF    0A.3
.................... delay_ms(1000); 
088A:  MOVLW  04
088B:  MOVWF  72
088C:  MOVLW  FA
088D:  MOVWF  75
088E:  BCF    0A.3
088F:  CALL   057
0890:  BSF    0A.3
0891:  DECFSZ 72,F
0892:  GOTO   08C
.................... lcd_rscrol(20); 
0893:  MOVLW  14
0894:  MOVWF  72
0895:  BCF    0A.3
0896:  CALL   10F
0897:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0898:  MOVLW  01
0899:  MOVWF  74
089A:  BCF    0A.3
089B:  CALL   06B
089C:  BSF    0A.3
....................  delay_ms(50); 
089D:  MOVLW  32
089E:  MOVWF  75
089F:  BCF    0A.3
08A0:  CALL   057
08A1:  BSF    0A.3
.................... lcd_line1 (3); 
08A2:  MOVLW  03
08A3:  MOVWF  72
08A4:  BCF    0A.3
08A5:  CALL   098
08A6:  BSF    0A.3
.................... lcd_data ("Made by:"); 
08A7:  MOVLW  17
08A8:  BSF    03.6
08A9:  MOVWF  0D
08AA:  MOVLW  00
08AB:  MOVWF  0F
08AC:  BCF    0A.3
08AD:  BCF    03.6
08AE:  CALL   0B5
08AF:  BSF    0A.3
.................... lcd_line2 (0); 
08B0:  CLRF   72
08B1:  BCF    0A.3
08B2:  CALL   109
08B3:  BSF    0A.3
.................... lcd_data ("Faizan,Shakir"); 
08B4:  MOVLW  1C
08B5:  BSF    03.6
08B6:  MOVWF  0D
08B7:  MOVLW  00
08B8:  MOVWF  0F
08B9:  BCF    0A.3
08BA:  BCF    03.6
08BB:  CALL   0B5
08BC:  BSF    0A.3
.................... delay_ms(1000); 
08BD:  MOVLW  04
08BE:  MOVWF  72
08BF:  MOVLW  FA
08C0:  MOVWF  75
08C1:  BCF    0A.3
08C2:  CALL   057
08C3:  BSF    0A.3
08C4:  DECFSZ 72,F
08C5:  GOTO   0BF
.................... lcd_rscrol(20); 
08C6:  MOVLW  14
08C7:  MOVWF  72
08C8:  BCF    0A.3
08C9:  CALL   10F
08CA:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
08CB:  MOVLW  01
08CC:  MOVWF  74
08CD:  BCF    0A.3
08CE:  CALL   06B
08CF:  BSF    0A.3
....................  delay_ms(50); 
08D0:  MOVLW  32
08D1:  MOVWF  75
08D2:  BCF    0A.3
08D3:  CALL   057
08D4:  BSF    0A.3
.................... lcd_line1 (3); 
08D5:  MOVLW  03
08D6:  MOVWF  72
08D7:  BCF    0A.3
08D8:  CALL   098
08D9:  BSF    0A.3
.................... lcd_data ("Made by:"); 
08DA:  MOVLW  23
08DB:  BSF    03.6
08DC:  MOVWF  0D
08DD:  MOVLW  00
08DE:  MOVWF  0F
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   0B5
08E2:  BSF    0A.3
.................... lcd_line2 (2); 
08E3:  MOVLW  02
08E4:  MOVWF  72
08E5:  BCF    0A.3
08E6:  CALL   109
08E7:  BSF    0A.3
.................... lcd_data ("And Hamza"); 
08E8:  MOVLW  28
08E9:  BSF    03.6
08EA:  MOVWF  0D
08EB:  MOVLW  00
08EC:  MOVWF  0F
08ED:  BCF    0A.3
08EE:  BCF    03.6
08EF:  CALL   0B5
08F0:  BSF    0A.3
.................... delay_ms(1000); 
08F1:  MOVLW  04
08F2:  MOVWF  72
08F3:  MOVLW  FA
08F4:  MOVWF  75
08F5:  BCF    0A.3
08F6:  CALL   057
08F7:  BSF    0A.3
08F8:  DECFSZ 72,F
08F9:  GOTO   0F3
.................... lcd_rscrol(20); 
08FA:  MOVLW  14
08FB:  MOVWF  72
08FC:  BCF    0A.3
08FD:  CALL   10F
08FE:  BSF    0A.3
.................... i++; 
08FF:  INCF   60,F
.................... } 
.................... while(i==0); 
0900:  MOVF   60,F
0901:  BTFSC  03.2
0902:  GOTO   04A
.................... lcd_cmd(disp_clear); 
0903:  MOVLW  01
0904:  MOVWF  74
0905:  BCF    0A.3
0906:  CALL   06B
0907:  BSF    0A.3
....................  delay_ms(50); 
0908:  MOVLW  32
0909:  MOVWF  75
090A:  BCF    0A.3
090B:  CALL   057
090C:  BSF    0A.3
.................... while(1) 
.................... { 
.................... set_adc_channel(0); 
090D:  MOVLW  00
090E:  MOVWF  78
090F:  MOVF   1F,W
0910:  ANDLW  C7
0911:  IORWF  78,W
0912:  MOVWF  1F
.................... delay_us(100); 
0913:  MOVLW  A6
0914:  MOVWF  77
0915:  DECFSZ 77,F
0916:  GOTO   115
0917:  NOP
.................... adc_value = read_adc(); 
0918:  BSF    1F.2
0919:  BTFSC  1F.2
091A:  GOTO   119
091B:  MOVF   1E,W
091C:  MOVWF  7A
091D:  BSF    03.5
091E:  MOVF   1E,W
091F:  MOVWF  73
0920:  MOVF   7A,W
0921:  MOVWF  74
0922:  BCF    0A.3
0923:  BCF    03.5
0924:  CALL   121
0925:  BSF    0A.3
0926:  MOVF   7A,W
0927:  MOVWF  35
0928:  MOVF   79,W
0929:  MOVWF  34
092A:  MOVF   78,W
092B:  MOVWF  33
092C:  MOVF   77,W
092D:  MOVWF  32
.................... Vsolar= (5.0*adc_value/1023.0)/0.167; 
092E:  BSF    03.5
092F:  CLRF   2B
0930:  CLRF   2A
0931:  MOVLW  20
0932:  MOVWF  29
0933:  MOVLW  81
0934:  MOVWF  28
0935:  BCF    03.5
0936:  MOVF   35,W
0937:  BSF    03.5
0938:  MOVWF  2F
0939:  BCF    03.5
093A:  MOVF   34,W
093B:  BSF    03.5
093C:  MOVWF  2E
093D:  BCF    03.5
093E:  MOVF   33,W
093F:  BSF    03.5
0940:  MOVWF  2D
0941:  BCF    03.5
0942:  MOVF   32,W
0943:  BSF    03.5
0944:  MOVWF  2C
0945:  BCF    0A.3
0946:  BCF    03.5
0947:  CALL   13E
0948:  BSF    0A.3
0949:  MOVF   7A,W
094A:  MOVWF  75
094B:  MOVF   79,W
094C:  MOVWF  74
094D:  MOVF   78,W
094E:  MOVWF  73
094F:  MOVF   77,W
0950:  MOVWF  72
0951:  MOVF   75,W
0952:  MOVWF  7E
0953:  MOVF   74,W
0954:  MOVWF  7D
0955:  MOVF   73,W
0956:  MOVWF  7C
0957:  MOVF   72,W
0958:  MOVWF  7B
0959:  BSF    03.5
095A:  CLRF   23
095B:  MOVLW  C0
095C:  MOVWF  22
095D:  MOVLW  7F
095E:  MOVWF  21
095F:  MOVLW  88
0960:  MOVWF  20
0961:  BCF    0A.3
0962:  BCF    03.5
0963:  CALL   1B5
0964:  BSF    0A.3
0965:  MOVF   7A,W
0966:  MOVWF  75
0967:  MOVF   79,W
0968:  MOVWF  74
0969:  MOVF   78,W
096A:  MOVWF  73
096B:  MOVF   77,W
096C:  MOVWF  72
096D:  MOVF   75,W
096E:  MOVWF  7E
096F:  MOVF   74,W
0970:  MOVWF  7D
0971:  MOVF   73,W
0972:  MOVWF  7C
0973:  MOVF   72,W
0974:  MOVWF  7B
0975:  MOVLW  0C
0976:  BSF    03.5
0977:  MOVWF  23
0978:  MOVLW  02
0979:  MOVWF  22
097A:  MOVLW  2B
097B:  MOVWF  21
097C:  MOVLW  7C
097D:  MOVWF  20
097E:  BCF    0A.3
097F:  BCF    03.5
0980:  CALL   1B5
0981:  BSF    0A.3
0982:  MOVF   7A,W
0983:  MOVWF  39
0984:  MOVF   79,W
0985:  MOVWF  38
0986:  MOVF   78,W
0987:  MOVWF  37
0988:  MOVF   77,W
0989:  MOVWF  36
....................  set_adc_channel(1); 
098A:  MOVLW  08
098B:  MOVWF  78
098C:  MOVF   1F,W
098D:  ANDLW  C7
098E:  IORWF  78,W
098F:  MOVWF  1F
.................... delay_ms(100); 
0990:  MOVLW  64
0991:  MOVWF  75
0992:  BCF    0A.3
0993:  CALL   057
0994:  BSF    0A.3
.................... adc_value = read_adc(); 
0995:  BSF    1F.2
0996:  BTFSC  1F.2
0997:  GOTO   196
0998:  MOVF   1E,W
0999:  MOVWF  7A
099A:  BSF    03.5
099B:  MOVF   1E,W
099C:  MOVWF  73
099D:  MOVF   7A,W
099E:  MOVWF  74
099F:  BCF    0A.3
09A0:  BCF    03.5
09A1:  CALL   121
09A2:  BSF    0A.3
09A3:  MOVF   7A,W
09A4:  MOVWF  35
09A5:  MOVF   79,W
09A6:  MOVWF  34
09A7:  MOVF   78,W
09A8:  MOVWF  33
09A9:  MOVF   77,W
09AA:  MOVWF  32
.................... Isolar= ((5.0/1023.0*adc_value)-2.47)/0.064; 
09AB:  MOVLW  0A
09AC:  BSF    03.5
09AD:  MOVWF  2B
09AE:  MOVLW  28
09AF:  MOVWF  2A
09B0:  MOVLW  20
09B1:  MOVWF  29
09B2:  MOVLW  77
09B3:  MOVWF  28
09B4:  BCF    03.5
09B5:  MOVF   35,W
09B6:  BSF    03.5
09B7:  MOVWF  2F
09B8:  BCF    03.5
09B9:  MOVF   34,W
09BA:  BSF    03.5
09BB:  MOVWF  2E
09BC:  BCF    03.5
09BD:  MOVF   33,W
09BE:  BSF    03.5
09BF:  MOVWF  2D
09C0:  BCF    03.5
09C1:  MOVF   32,W
09C2:  BSF    03.5
09C3:  MOVWF  2C
09C4:  BCF    0A.3
09C5:  BCF    03.5
09C6:  CALL   13E
09C7:  BSF    0A.3
09C8:  MOVF   7A,W
09C9:  MOVWF  75
09CA:  MOVF   79,W
09CB:  MOVWF  74
09CC:  MOVF   78,W
09CD:  MOVWF  73
09CE:  MOVF   77,W
09CF:  MOVWF  72
09D0:  BSF    03.1
09D1:  MOVF   75,W
09D2:  MOVWF  7E
09D3:  MOVF   74,W
09D4:  MOVWF  7D
09D5:  MOVF   73,W
09D6:  MOVWF  7C
09D7:  MOVF   72,W
09D8:  MOVWF  7B
09D9:  MOVLW  7B
09DA:  BSF    03.5
09DB:  MOVWF  23
09DC:  MOVLW  14
09DD:  MOVWF  22
09DE:  MOVLW  1E
09DF:  MOVWF  21
09E0:  MOVLW  80
09E1:  MOVWF  20
09E2:  BCF    0A.3
09E3:  BCF    03.5
09E4:  CALL   28E
09E5:  BSF    0A.3
09E6:  MOVF   7A,W
09E7:  MOVWF  75
09E8:  MOVF   79,W
09E9:  MOVWF  74
09EA:  MOVF   78,W
09EB:  MOVWF  73
09EC:  MOVF   77,W
09ED:  MOVWF  72
09EE:  MOVF   75,W
09EF:  MOVWF  7E
09F0:  MOVF   74,W
09F1:  MOVWF  7D
09F2:  MOVF   73,W
09F3:  MOVWF  7C
09F4:  MOVF   72,W
09F5:  MOVWF  7B
09F6:  MOVLW  6F
09F7:  BSF    03.5
09F8:  MOVWF  23
09F9:  MOVLW  12
09FA:  MOVWF  22
09FB:  MOVLW  03
09FC:  MOVWF  21
09FD:  MOVLW  7B
09FE:  MOVWF  20
09FF:  BCF    0A.3
0A00:  BCF    03.5
0A01:  CALL   1B5
0A02:  BSF    0A.3
0A03:  MOVF   7A,W
0A04:  MOVWF  41
0A05:  MOVF   79,W
0A06:  MOVWF  40
0A07:  MOVF   78,W
0A08:  MOVWF  3F
0A09:  MOVF   77,W
0A0A:  MOVWF  3E
.................... set_adc_channel(2); 
0A0B:  MOVLW  10
0A0C:  MOVWF  78
0A0D:  MOVF   1F,W
0A0E:  ANDLW  C7
0A0F:  IORWF  78,W
0A10:  MOVWF  1F
.................... delay_us(100); 
0A11:  MOVLW  A6
0A12:  MOVWF  77
0A13:  DECFSZ 77,F
0A14:  GOTO   213
0A15:  NOP
.................... adc_value = read_adc(); 
0A16:  BSF    1F.2
0A17:  BTFSC  1F.2
0A18:  GOTO   217
0A19:  MOVF   1E,W
0A1A:  MOVWF  7A
0A1B:  BSF    03.5
0A1C:  MOVF   1E,W
0A1D:  MOVWF  73
0A1E:  MOVF   7A,W
0A1F:  MOVWF  74
0A20:  BCF    0A.3
0A21:  BCF    03.5
0A22:  CALL   121
0A23:  BSF    0A.3
0A24:  MOVF   7A,W
0A25:  MOVWF  35
0A26:  MOVF   79,W
0A27:  MOVWF  34
0A28:  MOVF   78,W
0A29:  MOVWF  33
0A2A:  MOVF   77,W
0A2B:  MOVWF  32
.................... Vbattery= (5.0*adc_value/1023.0)/0.333; 
0A2C:  BSF    03.5
0A2D:  CLRF   2B
0A2E:  CLRF   2A
0A2F:  MOVLW  20
0A30:  MOVWF  29
0A31:  MOVLW  81
0A32:  MOVWF  28
0A33:  BCF    03.5
0A34:  MOVF   35,W
0A35:  BSF    03.5
0A36:  MOVWF  2F
0A37:  BCF    03.5
0A38:  MOVF   34,W
0A39:  BSF    03.5
0A3A:  MOVWF  2E
0A3B:  BCF    03.5
0A3C:  MOVF   33,W
0A3D:  BSF    03.5
0A3E:  MOVWF  2D
0A3F:  BCF    03.5
0A40:  MOVF   32,W
0A41:  BSF    03.5
0A42:  MOVWF  2C
0A43:  BCF    0A.3
0A44:  BCF    03.5
0A45:  CALL   13E
0A46:  BSF    0A.3
0A47:  MOVF   7A,W
0A48:  MOVWF  75
0A49:  MOVF   79,W
0A4A:  MOVWF  74
0A4B:  MOVF   78,W
0A4C:  MOVWF  73
0A4D:  MOVF   77,W
0A4E:  MOVWF  72
0A4F:  MOVF   75,W
0A50:  MOVWF  7E
0A51:  MOVF   74,W
0A52:  MOVWF  7D
0A53:  MOVF   73,W
0A54:  MOVWF  7C
0A55:  MOVF   72,W
0A56:  MOVWF  7B
0A57:  BSF    03.5
0A58:  CLRF   23
0A59:  MOVLW  C0
0A5A:  MOVWF  22
0A5B:  MOVLW  7F
0A5C:  MOVWF  21
0A5D:  MOVLW  88
0A5E:  MOVWF  20
0A5F:  BCF    0A.3
0A60:  BCF    03.5
0A61:  CALL   1B5
0A62:  BSF    0A.3
0A63:  MOVF   7A,W
0A64:  MOVWF  75
0A65:  MOVF   79,W
0A66:  MOVWF  74
0A67:  MOVF   78,W
0A68:  MOVWF  73
0A69:  MOVF   77,W
0A6A:  MOVWF  72
0A6B:  MOVF   75,W
0A6C:  MOVWF  7E
0A6D:  MOVF   74,W
0A6E:  MOVWF  7D
0A6F:  MOVF   73,W
0A70:  MOVWF  7C
0A71:  MOVF   72,W
0A72:  MOVWF  7B
0A73:  MOVLW  FA
0A74:  BSF    03.5
0A75:  MOVWF  23
0A76:  MOVLW  7E
0A77:  MOVWF  22
0A78:  MOVLW  2A
0A79:  MOVWF  21
0A7A:  MOVLW  7D
0A7B:  MOVWF  20
0A7C:  BCF    0A.3
0A7D:  BCF    03.5
0A7E:  CALL   1B5
0A7F:  BSF    0A.3
0A80:  MOVF   7A,W
0A81:  MOVWF  3D
0A82:  MOVF   79,W
0A83:  MOVWF  3C
0A84:  MOVF   78,W
0A85:  MOVWF  3B
0A86:  MOVF   77,W
0A87:  MOVWF  3A
....................  set_adc_channel(3); 
0A88:  MOVLW  18
0A89:  MOVWF  78
0A8A:  MOVF   1F,W
0A8B:  ANDLW  C7
0A8C:  IORWF  78,W
0A8D:  MOVWF  1F
.................... delay_ms(100); 
0A8E:  MOVLW  64
0A8F:  MOVWF  75
0A90:  BCF    0A.3
0A91:  CALL   057
0A92:  BSF    0A.3
.................... adc_value = read_adc(); 
0A93:  BSF    1F.2
0A94:  BTFSC  1F.2
0A95:  GOTO   294
0A96:  MOVF   1E,W
0A97:  MOVWF  7A
0A98:  BSF    03.5
0A99:  MOVF   1E,W
0A9A:  MOVWF  73
0A9B:  MOVF   7A,W
0A9C:  MOVWF  74
0A9D:  BCF    0A.3
0A9E:  BCF    03.5
0A9F:  CALL   121
0AA0:  BSF    0A.3
0AA1:  MOVF   7A,W
0AA2:  MOVWF  35
0AA3:  MOVF   79,W
0AA4:  MOVWF  34
0AA5:  MOVF   78,W
0AA6:  MOVWF  33
0AA7:  MOVF   77,W
0AA8:  MOVWF  32
.................... Ibattery= ((5.0/1023.0*adc_value)-2.47)/0.064; 
0AA9:  MOVLW  0A
0AAA:  BSF    03.5
0AAB:  MOVWF  2B
0AAC:  MOVLW  28
0AAD:  MOVWF  2A
0AAE:  MOVLW  20
0AAF:  MOVWF  29
0AB0:  MOVLW  77
0AB1:  MOVWF  28
0AB2:  BCF    03.5
0AB3:  MOVF   35,W
0AB4:  BSF    03.5
0AB5:  MOVWF  2F
0AB6:  BCF    03.5
0AB7:  MOVF   34,W
0AB8:  BSF    03.5
0AB9:  MOVWF  2E
0ABA:  BCF    03.5
0ABB:  MOVF   33,W
0ABC:  BSF    03.5
0ABD:  MOVWF  2D
0ABE:  BCF    03.5
0ABF:  MOVF   32,W
0AC0:  BSF    03.5
0AC1:  MOVWF  2C
0AC2:  BCF    0A.3
0AC3:  BCF    03.5
0AC4:  CALL   13E
0AC5:  BSF    0A.3
0AC6:  MOVF   7A,W
0AC7:  MOVWF  75
0AC8:  MOVF   79,W
0AC9:  MOVWF  74
0ACA:  MOVF   78,W
0ACB:  MOVWF  73
0ACC:  MOVF   77,W
0ACD:  MOVWF  72
0ACE:  BSF    03.1
0ACF:  MOVF   75,W
0AD0:  MOVWF  7E
0AD1:  MOVF   74,W
0AD2:  MOVWF  7D
0AD3:  MOVF   73,W
0AD4:  MOVWF  7C
0AD5:  MOVF   72,W
0AD6:  MOVWF  7B
0AD7:  MOVLW  7B
0AD8:  BSF    03.5
0AD9:  MOVWF  23
0ADA:  MOVLW  14
0ADB:  MOVWF  22
0ADC:  MOVLW  1E
0ADD:  MOVWF  21
0ADE:  MOVLW  80
0ADF:  MOVWF  20
0AE0:  BCF    0A.3
0AE1:  BCF    03.5
0AE2:  CALL   28E
0AE3:  BSF    0A.3
0AE4:  MOVF   7A,W
0AE5:  MOVWF  75
0AE6:  MOVF   79,W
0AE7:  MOVWF  74
0AE8:  MOVF   78,W
0AE9:  MOVWF  73
0AEA:  MOVF   77,W
0AEB:  MOVWF  72
0AEC:  MOVF   75,W
0AED:  MOVWF  7E
0AEE:  MOVF   74,W
0AEF:  MOVWF  7D
0AF0:  MOVF   73,W
0AF1:  MOVWF  7C
0AF2:  MOVF   72,W
0AF3:  MOVWF  7B
0AF4:  MOVLW  6F
0AF5:  BSF    03.5
0AF6:  MOVWF  23
0AF7:  MOVLW  12
0AF8:  MOVWF  22
0AF9:  MOVLW  03
0AFA:  MOVWF  21
0AFB:  MOVLW  7B
0AFC:  MOVWF  20
0AFD:  BCF    0A.3
0AFE:  BCF    03.5
0AFF:  CALL   1B5
0B00:  BSF    0A.3
0B01:  MOVF   7A,W
0B02:  MOVWF  45
0B03:  MOVF   79,W
0B04:  MOVWF  44
0B05:  MOVF   78,W
0B06:  MOVWF  43
0B07:  MOVF   77,W
0B08:  MOVWF  42
....................  lcd_line1(0); 
0B09:  CLRF   72
0B0A:  BCF    0A.3
0B0B:  CALL   098
0B0C:  BSF    0A.3
.................... printf(lcd_data,"VOLTAGE:%f V",Vsolar); 
0B0D:  MOVLW  2D
0B0E:  BSF    03.6
0B0F:  MOVWF  0D
0B10:  MOVLW  00
0B11:  MOVWF  0F
0B12:  BCF    03.0
0B13:  MOVLW  08
0B14:  MOVWF  72
0B15:  BCF    0A.3
0B16:  BCF    03.6
0B17:  CALL   3D4
0B18:  BSF    0A.3
0B19:  MOVLW  89
0B1A:  MOVWF  04
0B1B:  MOVF   39,W
0B1C:  MOVWF  75
0B1D:  MOVF   38,W
0B1E:  MOVWF  74
0B1F:  MOVF   37,W
0B20:  MOVWF  73
0B21:  MOVF   36,W
0B22:  MOVWF  72
0B23:  MOVLW  02
0B24:  MOVWF  76
0B25:  BCF    0A.3
0B26:  CALL   47F
0B27:  BSF    0A.3
0B28:  MOVLW  20
0B29:  BSF    03.5
0B2A:  MOVWF  28
0B2B:  BCF    0A.3
0B2C:  BCF    03.5
0B2D:  CALL   09E
0B2E:  BSF    0A.3
0B2F:  MOVLW  56
0B30:  BSF    03.5
0B31:  MOVWF  28
0B32:  BCF    0A.3
0B33:  BCF    03.5
0B34:  CALL   09E
0B35:  BSF    0A.3
.................... delay_ms(1000); 
0B36:  MOVLW  04
0B37:  MOVWF  72
0B38:  MOVLW  FA
0B39:  MOVWF  75
0B3A:  BCF    0A.3
0B3B:  CALL   057
0B3C:  BSF    0A.3
0B3D:  DECFSZ 72,F
0B3E:  GOTO   338
.................... lcd_rscrol(20); 
0B3F:  MOVLW  14
0B40:  MOVWF  72
0B41:  BCF    0A.3
0B42:  CALL   10F
0B43:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0B44:  MOVLW  01
0B45:  MOVWF  74
0B46:  BCF    0A.3
0B47:  CALL   06B
0B48:  BSF    0A.3
....................  delay_ms(50); 
0B49:  MOVLW  32
0B4A:  MOVWF  75
0B4B:  BCF    0A.3
0B4C:  CALL   057
0B4D:  BSF    0A.3
.................... lcd_line1(0); 
0B4E:  CLRF   72
0B4F:  BCF    0A.3
0B50:  CALL   098
0B51:  BSF    0A.3
....................  printf(lcd_data,"CURRENT:%f A",Isolar); 
0B52:  MOVLW  34
0B53:  BSF    03.6
0B54:  MOVWF  0D
0B55:  MOVLW  00
0B56:  MOVWF  0F
0B57:  BCF    03.0
0B58:  MOVLW  08
0B59:  MOVWF  72
0B5A:  BCF    0A.3
0B5B:  BCF    03.6
0B5C:  CALL   3D4
0B5D:  BSF    0A.3
0B5E:  MOVLW  89
0B5F:  MOVWF  04
0B60:  MOVF   41,W
0B61:  MOVWF  75
0B62:  MOVF   40,W
0B63:  MOVWF  74
0B64:  MOVF   3F,W
0B65:  MOVWF  73
0B66:  MOVF   3E,W
0B67:  MOVWF  72
0B68:  MOVLW  02
0B69:  MOVWF  76
0B6A:  BCF    0A.3
0B6B:  CALL   47F
0B6C:  BSF    0A.3
0B6D:  MOVLW  20
0B6E:  BSF    03.5
0B6F:  MOVWF  28
0B70:  BCF    0A.3
0B71:  BCF    03.5
0B72:  CALL   09E
0B73:  BSF    0A.3
0B74:  MOVLW  41
0B75:  BSF    03.5
0B76:  MOVWF  28
0B77:  BCF    0A.3
0B78:  BCF    03.5
0B79:  CALL   09E
0B7A:  BSF    0A.3
.................... delay_ms(1000); 
0B7B:  MOVLW  04
0B7C:  MOVWF  72
0B7D:  MOVLW  FA
0B7E:  MOVWF  75
0B7F:  BCF    0A.3
0B80:  CALL   057
0B81:  BSF    0A.3
0B82:  DECFSZ 72,F
0B83:  GOTO   37D
.................... lcd_rscrol(20); 
0B84:  MOVLW  14
0B85:  MOVWF  72
0B86:  BCF    0A.3
0B87:  CALL   10F
0B88:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0B89:  MOVLW  01
0B8A:  MOVWF  74
0B8B:  BCF    0A.3
0B8C:  CALL   06B
0B8D:  BSF    0A.3
....................  delay_ms(50); 
0B8E:  MOVLW  32
0B8F:  MOVWF  75
0B90:  BCF    0A.3
0B91:  CALL   057
0B92:  BSF    0A.3
....................  Pin=Vsolar*Isolar; 
0B93:  MOVF   39,W
0B94:  BSF    03.5
0B95:  MOVWF  2B
0B96:  BCF    03.5
0B97:  MOVF   38,W
0B98:  BSF    03.5
0B99:  MOVWF  2A
0B9A:  BCF    03.5
0B9B:  MOVF   37,W
0B9C:  BSF    03.5
0B9D:  MOVWF  29
0B9E:  BCF    03.5
0B9F:  MOVF   36,W
0BA0:  BSF    03.5
0BA1:  MOVWF  28
0BA2:  BCF    03.5
0BA3:  MOVF   41,W
0BA4:  BSF    03.5
0BA5:  MOVWF  2F
0BA6:  BCF    03.5
0BA7:  MOVF   40,W
0BA8:  BSF    03.5
0BA9:  MOVWF  2E
0BAA:  BCF    03.5
0BAB:  MOVF   3F,W
0BAC:  BSF    03.5
0BAD:  MOVWF  2D
0BAE:  BCF    03.5
0BAF:  MOVF   3E,W
0BB0:  BSF    03.5
0BB1:  MOVWF  2C
0BB2:  BCF    0A.3
0BB3:  BCF    03.5
0BB4:  CALL   13E
0BB5:  BSF    0A.3
0BB6:  MOVF   7A,W
0BB7:  MOVWF  49
0BB8:  MOVF   79,W
0BB9:  MOVWF  48
0BBA:  MOVF   78,W
0BBB:  MOVWF  47
0BBC:  MOVF   77,W
0BBD:  MOVWF  46
....................  lcd_line1(0); 
0BBE:  CLRF   72
0BBF:  BCF    0A.3
0BC0:  CALL   098
0BC1:  BSF    0A.3
....................  lcd_data("INPUT POWER:"); 
0BC2:  MOVLW  3B
0BC3:  BSF    03.6
0BC4:  MOVWF  0D
0BC5:  MOVLW  00
0BC6:  MOVWF  0F
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   0B5
0BCA:  BSF    0A.3
....................  lcd_line2(3); 
0BCB:  MOVLW  03
0BCC:  MOVWF  72
0BCD:  BCF    0A.3
0BCE:  CALL   109
0BCF:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pin); 
0BD0:  MOVLW  89
0BD1:  MOVWF  04
0BD2:  MOVF   49,W
0BD3:  MOVWF  75
0BD4:  MOVF   48,W
0BD5:  MOVWF  74
0BD6:  MOVF   47,W
0BD7:  MOVWF  73
0BD8:  MOVF   46,W
0BD9:  MOVWF  72
0BDA:  MOVLW  02
0BDB:  MOVWF  76
0BDC:  BCF    0A.3
0BDD:  CALL   47F
0BDE:  BSF    0A.3
0BDF:  MOVLW  20
0BE0:  BSF    03.5
0BE1:  MOVWF  28
0BE2:  BCF    0A.3
0BE3:  BCF    03.5
0BE4:  CALL   09E
0BE5:  BSF    0A.3
0BE6:  MOVLW  57
0BE7:  BSF    03.5
0BE8:  MOVWF  28
0BE9:  BCF    0A.3
0BEA:  BCF    03.5
0BEB:  CALL   09E
0BEC:  BSF    0A.3
.................... delay_ms(1000); 
0BED:  MOVLW  04
0BEE:  MOVWF  72
0BEF:  MOVLW  FA
0BF0:  MOVWF  75
0BF1:  BCF    0A.3
0BF2:  CALL   057
0BF3:  BSF    0A.3
0BF4:  DECFSZ 72,F
0BF5:  GOTO   3EF
.................... lcd_rscrol(20); 
0BF6:  MOVLW  14
0BF7:  MOVWF  72
0BF8:  BCF    0A.3
0BF9:  CALL   10F
0BFA:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0BFB:  MOVLW  01
0BFC:  MOVWF  74
0BFD:  BCF    0A.3
0BFE:  CALL   06B
0BFF:  BSF    0A.3
....................  delay_ms(50); 
0C00:  MOVLW  32
0C01:  MOVWF  75
0C02:  BCF    0A.3
0C03:  CALL   057
0C04:  BSF    0A.3
.................... lcd_line1(0); 
0C05:  CLRF   72
0C06:  BCF    0A.3
0C07:  CALL   098
0C08:  BSF    0A.3
.................... printf(lcd_data,"VOLTAGE: %f V",Vbattery); 
0C09:  MOVLW  42
0C0A:  BSF    03.6
0C0B:  MOVWF  0D
0C0C:  MOVLW  00
0C0D:  MOVWF  0F
0C0E:  BCF    03.0
0C0F:  MOVLW  09
0C10:  MOVWF  72
0C11:  BCF    0A.3
0C12:  BCF    03.6
0C13:  CALL   3D4
0C14:  BSF    0A.3
0C15:  MOVLW  89
0C16:  MOVWF  04
0C17:  MOVF   3D,W
0C18:  MOVWF  75
0C19:  MOVF   3C,W
0C1A:  MOVWF  74
0C1B:  MOVF   3B,W
0C1C:  MOVWF  73
0C1D:  MOVF   3A,W
0C1E:  MOVWF  72
0C1F:  MOVLW  02
0C20:  MOVWF  76
0C21:  BCF    0A.3
0C22:  CALL   47F
0C23:  BSF    0A.3
0C24:  MOVLW  20
0C25:  BSF    03.5
0C26:  MOVWF  28
0C27:  BCF    0A.3
0C28:  BCF    03.5
0C29:  CALL   09E
0C2A:  BSF    0A.3
0C2B:  MOVLW  56
0C2C:  BSF    03.5
0C2D:  MOVWF  28
0C2E:  BCF    0A.3
0C2F:  BCF    03.5
0C30:  CALL   09E
0C31:  BSF    0A.3
.................... delay_ms(1000); 
0C32:  MOVLW  04
0C33:  MOVWF  72
0C34:  MOVLW  FA
0C35:  MOVWF  75
0C36:  BCF    0A.3
0C37:  CALL   057
0C38:  BSF    0A.3
0C39:  DECFSZ 72,F
0C3A:  GOTO   434
.................... lcd_rscrol(20); 
0C3B:  MOVLW  14
0C3C:  MOVWF  72
0C3D:  BCF    0A.3
0C3E:  CALL   10F
0C3F:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0C40:  MOVLW  01
0C41:  MOVWF  74
0C42:  BCF    0A.3
0C43:  CALL   06B
0C44:  BSF    0A.3
....................  delay_ms(50); 
0C45:  MOVLW  32
0C46:  MOVWF  75
0C47:  BCF    0A.3
0C48:  CALL   057
0C49:  BSF    0A.3
.................... lcd_line1(0); 
0C4A:  CLRF   72
0C4B:  BCF    0A.3
0C4C:  CALL   098
0C4D:  BSF    0A.3
.................... printf(lcd_data,"CURRENT: %f A",Ibattery); 
0C4E:  MOVLW  49
0C4F:  BSF    03.6
0C50:  MOVWF  0D
0C51:  MOVLW  00
0C52:  MOVWF  0F
0C53:  BCF    03.0
0C54:  MOVLW  09
0C55:  MOVWF  72
0C56:  BCF    0A.3
0C57:  BCF    03.6
0C58:  CALL   3D4
0C59:  BSF    0A.3
0C5A:  MOVLW  89
0C5B:  MOVWF  04
0C5C:  MOVF   45,W
0C5D:  MOVWF  75
0C5E:  MOVF   44,W
0C5F:  MOVWF  74
0C60:  MOVF   43,W
0C61:  MOVWF  73
0C62:  MOVF   42,W
0C63:  MOVWF  72
0C64:  MOVLW  02
0C65:  MOVWF  76
0C66:  BCF    0A.3
0C67:  CALL   47F
0C68:  BSF    0A.3
0C69:  MOVLW  20
0C6A:  BSF    03.5
0C6B:  MOVWF  28
0C6C:  BCF    0A.3
0C6D:  BCF    03.5
0C6E:  CALL   09E
0C6F:  BSF    0A.3
0C70:  MOVLW  41
0C71:  BSF    03.5
0C72:  MOVWF  28
0C73:  BCF    0A.3
0C74:  BCF    03.5
0C75:  CALL   09E
0C76:  BSF    0A.3
.................... delay_ms(1000); 
0C77:  MOVLW  04
0C78:  MOVWF  72
0C79:  MOVLW  FA
0C7A:  MOVWF  75
0C7B:  BCF    0A.3
0C7C:  CALL   057
0C7D:  BSF    0A.3
0C7E:  DECFSZ 72,F
0C7F:  GOTO   479
.................... lcd_rscrol(20); 
0C80:  MOVLW  14
0C81:  MOVWF  72
0C82:  BCF    0A.3
0C83:  CALL   10F
0C84:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0C85:  MOVLW  01
0C86:  MOVWF  74
0C87:  BCF    0A.3
0C88:  CALL   06B
0C89:  BSF    0A.3
....................  delay_ms(50); 
0C8A:  MOVLW  32
0C8B:  MOVWF  75
0C8C:  BCF    0A.3
0C8D:  CALL   057
0C8E:  BSF    0A.3
....................   Pout=Vbattery*Ibattery; 
0C8F:  MOVF   3D,W
0C90:  BSF    03.5
0C91:  MOVWF  2B
0C92:  BCF    03.5
0C93:  MOVF   3C,W
0C94:  BSF    03.5
0C95:  MOVWF  2A
0C96:  BCF    03.5
0C97:  MOVF   3B,W
0C98:  BSF    03.5
0C99:  MOVWF  29
0C9A:  BCF    03.5
0C9B:  MOVF   3A,W
0C9C:  BSF    03.5
0C9D:  MOVWF  28
0C9E:  BCF    03.5
0C9F:  MOVF   45,W
0CA0:  BSF    03.5
0CA1:  MOVWF  2F
0CA2:  BCF    03.5
0CA3:  MOVF   44,W
0CA4:  BSF    03.5
0CA5:  MOVWF  2E
0CA6:  BCF    03.5
0CA7:  MOVF   43,W
0CA8:  BSF    03.5
0CA9:  MOVWF  2D
0CAA:  BCF    03.5
0CAB:  MOVF   42,W
0CAC:  BSF    03.5
0CAD:  MOVWF  2C
0CAE:  BCF    0A.3
0CAF:  BCF    03.5
0CB0:  CALL   13E
0CB1:  BSF    0A.3
0CB2:  MOVF   7A,W
0CB3:  MOVWF  4D
0CB4:  MOVF   79,W
0CB5:  MOVWF  4C
0CB6:  MOVF   78,W
0CB7:  MOVWF  4B
0CB8:  MOVF   77,W
0CB9:  MOVWF  4A
....................  lcd_line1(0); 
0CBA:  CLRF   72
0CBB:  BCF    0A.3
0CBC:  CALL   098
0CBD:  BSF    0A.3
....................  lcd_data("OUTPUT POWER:"); 
0CBE:  MOVLW  50
0CBF:  BSF    03.6
0CC0:  MOVWF  0D
0CC1:  MOVLW  00
0CC2:  MOVWF  0F
0CC3:  BCF    0A.3
0CC4:  BCF    03.6
0CC5:  CALL   0B5
0CC6:  BSF    0A.3
....................  lcd_line2(3); 
0CC7:  MOVLW  03
0CC8:  MOVWF  72
0CC9:  BCF    0A.3
0CCA:  CALL   109
0CCB:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pout); 
0CCC:  MOVLW  89
0CCD:  MOVWF  04
0CCE:  MOVF   4D,W
0CCF:  MOVWF  75
0CD0:  MOVF   4C,W
0CD1:  MOVWF  74
0CD2:  MOVF   4B,W
0CD3:  MOVWF  73
0CD4:  MOVF   4A,W
0CD5:  MOVWF  72
0CD6:  MOVLW  02
0CD7:  MOVWF  76
0CD8:  BCF    0A.3
0CD9:  CALL   47F
0CDA:  BSF    0A.3
0CDB:  MOVLW  20
0CDC:  BSF    03.5
0CDD:  MOVWF  28
0CDE:  BCF    0A.3
0CDF:  BCF    03.5
0CE0:  CALL   09E
0CE1:  BSF    0A.3
0CE2:  MOVLW  57
0CE3:  BSF    03.5
0CE4:  MOVWF  28
0CE5:  BCF    0A.3
0CE6:  BCF    03.5
0CE7:  CALL   09E
0CE8:  BSF    0A.3
.................... delay_ms(1000); 
0CE9:  MOVLW  04
0CEA:  MOVWF  72
0CEB:  MOVLW  FA
0CEC:  MOVWF  75
0CED:  BCF    0A.3
0CEE:  CALL   057
0CEF:  BSF    0A.3
0CF0:  DECFSZ 72,F
0CF1:  GOTO   4EB
.................... lcd_rscrol(20); 
0CF2:  MOVLW  14
0CF3:  MOVWF  72
0CF4:  BCF    0A.3
0CF5:  CALL   10F
0CF6:  BSF    0A.3
.................... lcd_cmd(disp_clear); 
0CF7:  MOVLW  01
0CF8:  MOVWF  74
0CF9:  BCF    0A.3
0CFA:  CALL   06B
0CFB:  BSF    0A.3
....................  delay_ms(50); 
0CFC:  MOVLW  32
0CFD:  MOVWF  75
0CFE:  BCF    0A.3
0CFF:  CALL   057
0D00:  BSF    0A.3
....................   if(Vbattery<11.8) 
0D01:  MOVF   3D,W
0D02:  MOVWF  76
0D03:  MOVF   3C,W
0D04:  MOVWF  75
0D05:  MOVF   3B,W
0D06:  MOVWF  74
0D07:  MOVF   3A,W
0D08:  MOVWF  73
0D09:  MOVLW  CD
0D0A:  MOVWF  7E
0D0B:  MOVLW  CC
0D0C:  MOVWF  7D
0D0D:  MOVLW  3C
0D0E:  MOVWF  7C
0D0F:  MOVLW  82
0D10:  MOVWF  7B
0D11:  BCF    0A.3
0D12:  CALL   573
0D13:  BSF    0A.3
0D14:  BTFSS  03.0
0D15:  GOTO   51C
....................  {on(red);} 
0D16:  BCF    5F.6
0D17:  MOVF   5F,W
0D18:  BSF    03.5
0D19:  MOVWF  07
0D1A:  BCF    03.5
0D1B:  BSF    07.6
....................  if(Vbattery<12.5) 
0D1C:  MOVF   3D,W
0D1D:  MOVWF  76
0D1E:  MOVF   3C,W
0D1F:  MOVWF  75
0D20:  MOVF   3B,W
0D21:  MOVWF  74
0D22:  MOVF   3A,W
0D23:  MOVWF  73
0D24:  CLRF   7E
0D25:  CLRF   7D
0D26:  MOVLW  48
0D27:  MOVWF  7C
0D28:  MOVLW  82
0D29:  MOVWF  7B
0D2A:  BCF    0A.3
0D2B:  CALL   573
0D2C:  BSF    0A.3
0D2D:  BTFSS  03.0
0D2E:  GOTO   53B
....................  {on(red); 
0D2F:  BCF    5F.6
0D30:  MOVF   5F,W
0D31:  BSF    03.5
0D32:  MOVWF  07
0D33:  BCF    03.5
0D34:  BSF    07.6
....................  on(yellow1);} 
0D35:  BCF    5F.7
0D36:  MOVF   5F,W
0D37:  BSF    03.5
0D38:  MOVWF  07
0D39:  BCF    03.5
0D3A:  BSF    07.7
....................  if(Vbattery<13) 
0D3B:  MOVF   3D,W
0D3C:  MOVWF  76
0D3D:  MOVF   3C,W
0D3E:  MOVWF  75
0D3F:  MOVF   3B,W
0D40:  MOVWF  74
0D41:  MOVF   3A,W
0D42:  MOVWF  73
0D43:  CLRF   7E
0D44:  CLRF   7D
0D45:  MOVLW  50
0D46:  MOVWF  7C
0D47:  MOVLW  82
0D48:  MOVWF  7B
0D49:  BCF    0A.3
0D4A:  CALL   573
0D4B:  BSF    0A.3
0D4C:  BTFSS  03.0
0D4D:  GOTO   55E
....................  {on(red); 
0D4E:  BCF    5F.6
0D4F:  MOVF   5F,W
0D50:  BSF    03.5
0D51:  MOVWF  07
0D52:  BCF    03.5
0D53:  BSF    07.6
....................  on(yellow1); 
0D54:  BCF    5F.7
0D55:  MOVF   5F,W
0D56:  BSF    03.5
0D57:  MOVWF  07
0D58:  BCF    03.5
0D59:  BSF    07.7
....................  on(yellow2);} 
0D5A:  BSF    03.5
0D5B:  BCF    08.4
0D5C:  BCF    03.5
0D5D:  BSF    08.4
....................  if(Vbattery<13) 
0D5E:  MOVF   3D,W
0D5F:  MOVWF  76
0D60:  MOVF   3C,W
0D61:  MOVWF  75
0D62:  MOVF   3B,W
0D63:  MOVWF  74
0D64:  MOVF   3A,W
0D65:  MOVWF  73
0D66:  CLRF   7E
0D67:  CLRF   7D
0D68:  MOVLW  50
0D69:  MOVWF  7C
0D6A:  MOVLW  82
0D6B:  MOVWF  7B
0D6C:  BCF    0A.3
0D6D:  CALL   573
0D6E:  BSF    0A.3
0D6F:  BTFSS  03.0
0D70:  GOTO   585
....................  {on(red); 
0D71:  BCF    5F.6
0D72:  MOVF   5F,W
0D73:  BSF    03.5
0D74:  MOVWF  07
0D75:  BCF    03.5
0D76:  BSF    07.6
....................  on(yellow1); 
0D77:  BCF    5F.7
0D78:  MOVF   5F,W
0D79:  BSF    03.5
0D7A:  MOVWF  07
0D7B:  BCF    03.5
0D7C:  BSF    07.7
....................  on(yellow2); 
0D7D:  BSF    03.5
0D7E:  BCF    08.4
0D7F:  BCF    03.5
0D80:  BSF    08.4
....................  on(green);} 
0D81:  BSF    03.5
0D82:  BCF    08.5
0D83:  BCF    03.5
0D84:  BSF    08.5
....................  if(Vsolar<Vbattery || Isolar<1) 
0D85:  MOVF   39,W
0D86:  MOVWF  76
0D87:  MOVF   38,W
0D88:  MOVWF  75
0D89:  MOVF   37,W
0D8A:  MOVWF  74
0D8B:  MOVF   36,W
0D8C:  MOVWF  73
0D8D:  MOVF   3D,W
0D8E:  MOVWF  7E
0D8F:  MOVF   3C,W
0D90:  MOVWF  7D
0D91:  MOVF   3B,W
0D92:  MOVWF  7C
0D93:  MOVF   3A,W
0D94:  MOVWF  7B
0D95:  BCF    0A.3
0D96:  CALL   573
0D97:  BSF    0A.3
0D98:  BTFSC  03.0
0D99:  GOTO   5AC
0D9A:  MOVF   41,W
0D9B:  MOVWF  76
0D9C:  MOVF   40,W
0D9D:  MOVWF  75
0D9E:  MOVF   3F,W
0D9F:  MOVWF  74
0DA0:  MOVF   3E,W
0DA1:  MOVWF  73
0DA2:  CLRF   7E
0DA3:  CLRF   7D
0DA4:  CLRF   7C
0DA5:  MOVLW  7F
0DA6:  MOVWF  7B
0DA7:  BCF    0A.3
0DA8:  CALL   573
0DA9:  BSF    0A.3
0DAA:  BTFSS  03.0
0DAB:  GOTO   5BE
....................  {off(relay); 
0DAC:  BSF    03.5
0DAD:  BCF    08.6
0DAE:  BCF    03.5
0DAF:  BCF    08.6
....................  off(sd); 
0DB0:  BCF    5F.0
0DB1:  MOVF   5F,W
0DB2:  BSF    03.5
0DB3:  MOVWF  07
0DB4:  BCF    03.5
0DB5:  BCF    07.0
....................  off(fan); 
0DB6:  BSF    03.5
0DB7:  BCF    08.7
0DB8:  BCF    03.5
0DB9:  BCF    08.7
....................  on(WAPDA);} 
0DBA:  BSF    03.5
0DBB:  BCF    08.3
0DBC:  BCF    03.5
0DBD:  BSF    08.3
....................  if(Vbattery==13.5) 
0DBE:  MOVF   3D,W
0DBF:  MOVWF  76
0DC0:  MOVF   3C,W
0DC1:  MOVWF  75
0DC2:  MOVF   3B,W
0DC3:  MOVWF  74
0DC4:  MOVF   3A,W
0DC5:  MOVWF  73
0DC6:  CLRF   7E
0DC7:  CLRF   7D
0DC8:  MOVLW  58
0DC9:  MOVWF  7C
0DCA:  MOVLW  82
0DCB:  MOVWF  7B
0DCC:  BCF    0A.3
0DCD:  CALL   573
0DCE:  BSF    0A.3
0DCF:  BTFSS  03.2
0DD0:  GOTO   5DB
....................  {off(sd); 
0DD1:  BCF    5F.0
0DD2:  MOVF   5F,W
0DD3:  BSF    03.5
0DD4:  MOVWF  07
0DD5:  BCF    03.5
0DD6:  BCF    07.0
....................  off(fan);}} 
0DD7:  BSF    03.5
0DD8:  BCF    08.7
0DD9:  BCF    03.5
0DDA:  BCF    08.7
0DDB:  GOTO   10D
....................  if(11.5<Vbattery<13.5 || Vsolar>12) 
0DDC:  CLRF   76
0DDD:  CLRF   75
0DDE:  MOVLW  38
0DDF:  MOVWF  74
0DE0:  MOVLW  82
0DE1:  MOVWF  73
0DE2:  MOVF   3D,W
0DE3:  MOVWF  7E
0DE4:  MOVF   3C,W
0DE5:  MOVWF  7D
0DE6:  MOVF   3B,W
0DE7:  MOVWF  7C
0DE8:  MOVF   3A,W
0DE9:  MOVWF  7B
0DEA:  BCF    0A.3
0DEB:  CALL   573
0DEC:  BSF    0A.3
0DED:  MOVLW  00
0DEE:  BTFSC  03.0
0DEF:  MOVLW  01
0DF0:  CLRF   74
0DF1:  MOVWF  73
0DF2:  BCF    0A.3
0DF3:  CALL   121
0DF4:  BSF    0A.3
0DF5:  MOVF   7A,W
0DF6:  MOVWF  76
0DF7:  MOVF   79,W
0DF8:  MOVWF  75
0DF9:  MOVF   78,W
0DFA:  MOVWF  74
0DFB:  MOVF   77,W
0DFC:  MOVWF  73
0DFD:  CLRF   7E
0DFE:  CLRF   7D
0DFF:  MOVLW  58
0E00:  MOVWF  7C
0E01:  MOVLW  82
0E02:  MOVWF  7B
0E03:  BCF    0A.3
0E04:  CALL   573
0E05:  BSF    0A.3
0E06:  BTFSC  03.0
0E07:  GOTO   61B
0E08:  CLRF   76
0E09:  CLRF   75
0E0A:  MOVLW  40
0E0B:  MOVWF  74
0E0C:  MOVLW  82
0E0D:  MOVWF  73
0E0E:  MOVF   39,W
0E0F:  MOVWF  7E
0E10:  MOVF   38,W
0E11:  MOVWF  7D
0E12:  MOVF   37,W
0E13:  MOVWF  7C
0E14:  MOVF   36,W
0E15:  MOVWF  7B
0E16:  BCF    0A.3
0E17:  CALL   573
0E18:  BSF    0A.3
0E19:  BTFSS  03.0
0E1A:  GOTO   7FC
....................  {on(relay); 
0E1B:  BSF    03.5
0E1C:  BCF    08.6
0E1D:  BCF    03.5
0E1E:  BSF    08.6
....................  on(sd); 
0E1F:  BCF    5F.0
0E20:  MOVF   5F,W
0E21:  BSF    03.5
0E22:  MOVWF  07
0E23:  BCF    03.5
0E24:  BSF    07.0
....................  on(fan); 
0E25:  BSF    03.5
0E26:  BCF    08.7
0E27:  BCF    03.5
0E28:  BSF    08.7
....................  on(solar); 
0E29:  BSF    03.5
0E2A:  BCF    08.2
0E2B:  BCF    03.5
0E2C:  BSF    08.2
....................  float delta_P=Pin-PrevPsolar,delta_V=Vsolar-PrevVsolar; 
....................  float delta_I=Isolar-PrevIsolar,gradient=delta_P/delta_V; 
.................... int pwm; 
0E2D:  BSF    03.1
0E2E:  MOVF   49,W
0E2F:  MOVWF  7E
0E30:  MOVF   48,W
0E31:  MOVWF  7D
0E32:  MOVF   47,W
0E33:  MOVWF  7C
0E34:  MOVF   46,W
0E35:  MOVWF  7B
0E36:  MOVF   31,W
0E37:  BSF    03.5
0E38:  MOVWF  23
0E39:  BCF    03.5
0E3A:  MOVF   30,W
0E3B:  BSF    03.5
0E3C:  MOVWF  22
0E3D:  BCF    03.5
0E3E:  MOVF   2F,W
0E3F:  BSF    03.5
0E40:  MOVWF  21
0E41:  BCF    03.5
0E42:  MOVF   2E,W
0E43:  BSF    03.5
0E44:  MOVWF  20
0E45:  BCF    0A.3
0E46:  BCF    03.5
0E47:  CALL   28E
0E48:  BSF    0A.3
0E49:  MOVF   7A,W
0E4A:  MOVWF  64
0E4B:  MOVF   79,W
0E4C:  MOVWF  63
0E4D:  MOVF   78,W
0E4E:  MOVWF  62
0E4F:  MOVF   77,W
0E50:  MOVWF  61
0E51:  BSF    03.1
0E52:  MOVF   39,W
0E53:  MOVWF  7E
0E54:  MOVF   38,W
0E55:  MOVWF  7D
0E56:  MOVF   37,W
0E57:  MOVWF  7C
0E58:  MOVF   36,W
0E59:  MOVWF  7B
0E5A:  MOVF   29,W
0E5B:  BSF    03.5
0E5C:  MOVWF  23
0E5D:  BCF    03.5
0E5E:  MOVF   28,W
0E5F:  BSF    03.5
0E60:  MOVWF  22
0E61:  BCF    03.5
0E62:  MOVF   27,W
0E63:  BSF    03.5
0E64:  MOVWF  21
0E65:  BCF    03.5
0E66:  MOVF   26,W
0E67:  BSF    03.5
0E68:  MOVWF  20
0E69:  BCF    0A.3
0E6A:  BCF    03.5
0E6B:  CALL   28E
0E6C:  BSF    0A.3
0E6D:  MOVF   7A,W
0E6E:  MOVWF  68
0E6F:  MOVF   79,W
0E70:  MOVWF  67
0E71:  MOVF   78,W
0E72:  MOVWF  66
0E73:  MOVF   77,W
0E74:  MOVWF  65
0E75:  BSF    03.1
0E76:  MOVF   41,W
0E77:  MOVWF  7E
0E78:  MOVF   40,W
0E79:  MOVWF  7D
0E7A:  MOVF   3F,W
0E7B:  MOVWF  7C
0E7C:  MOVF   3E,W
0E7D:  MOVWF  7B
0E7E:  MOVF   2D,W
0E7F:  BSF    03.5
0E80:  MOVWF  23
0E81:  BCF    03.5
0E82:  MOVF   2C,W
0E83:  BSF    03.5
0E84:  MOVWF  22
0E85:  BCF    03.5
0E86:  MOVF   2B,W
0E87:  BSF    03.5
0E88:  MOVWF  21
0E89:  BCF    03.5
0E8A:  MOVF   2A,W
0E8B:  BSF    03.5
0E8C:  MOVWF  20
0E8D:  BCF    0A.3
0E8E:  BCF    03.5
0E8F:  CALL   28E
0E90:  BSF    0A.3
0E91:  MOVF   7A,W
0E92:  MOVWF  6C
0E93:  MOVF   79,W
0E94:  MOVWF  6B
0E95:  MOVF   78,W
0E96:  MOVWF  6A
0E97:  MOVF   77,W
0E98:  MOVWF  69
0E99:  MOVF   64,W
0E9A:  MOVWF  7E
0E9B:  MOVF   63,W
0E9C:  MOVWF  7D
0E9D:  MOVF   62,W
0E9E:  MOVWF  7C
0E9F:  MOVF   61,W
0EA0:  MOVWF  7B
0EA1:  MOVF   68,W
0EA2:  BSF    03.5
0EA3:  MOVWF  23
0EA4:  BCF    03.5
0EA5:  MOVF   67,W
0EA6:  BSF    03.5
0EA7:  MOVWF  22
0EA8:  BCF    03.5
0EA9:  MOVF   66,W
0EAA:  BSF    03.5
0EAB:  MOVWF  21
0EAC:  BCF    03.5
0EAD:  MOVF   65,W
0EAE:  BSF    03.5
0EAF:  MOVWF  20
0EB0:  BCF    0A.3
0EB1:  BCF    03.5
0EB2:  CALL   1B5
0EB3:  BSF    0A.3
0EB4:  MOVF   7A,W
0EB5:  MOVWF  70
0EB6:  MOVF   79,W
0EB7:  MOVWF  6F
0EB8:  MOVF   78,W
0EB9:  MOVWF  6E
0EBA:  MOVF   77,W
0EBB:  MOVWF  6D
.................... if(delta_V!=0) 
0EBC:  MOVF   68,W
0EBD:  MOVWF  76
0EBE:  MOVF   67,W
0EBF:  MOVWF  75
0EC0:  MOVF   66,W
0EC1:  MOVWF  74
0EC2:  MOVF   65,W
0EC3:  MOVWF  73
0EC4:  CLRF   7E
0EC5:  CLRF   7D
0EC6:  CLRF   7C
0EC7:  CLRF   7B
0EC8:  BCF    0A.3
0EC9:  CALL   573
0ECA:  BSF    0A.3
0ECB:  BTFSC  03.2
0ECC:  GOTO   7FC
.................... { if(gradient>0) 
0ECD:  CLRF   76
0ECE:  CLRF   75
0ECF:  CLRF   74
0ED0:  CLRF   73
0ED1:  MOVF   70,W
0ED2:  MOVWF  7E
0ED3:  MOVF   6F,W
0ED4:  MOVWF  7D
0ED5:  MOVF   6E,W
0ED6:  MOVWF  7C
0ED7:  MOVF   6D,W
0ED8:  MOVWF  7B
0ED9:  BCF    0A.3
0EDA:  CALL   573
0EDB:  BSF    0A.3
0EDC:  BTFSS  03.0
0EDD:  GOTO   719
.................... { pwm+=delta; 
0EDE:  MOVF   5E,W
0EDF:  ADDWF  71,F
.................... PrevPsolar=Pin; 
0EE0:  MOVF   49,W
0EE1:  MOVWF  31
0EE2:  MOVF   48,W
0EE3:  MOVWF  30
0EE4:  MOVF   47,W
0EE5:  MOVWF  2F
0EE6:  MOVF   46,W
0EE7:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0EE8:  MOVF   39,W
0EE9:  MOVWF  29
0EEA:  MOVF   38,W
0EEB:  MOVWF  28
0EEC:  MOVF   37,W
0EED:  MOVWF  27
0EEE:  MOVF   36,W
0EEF:  MOVWF  26
.................... PrevIsolar=Isolar;  
0EF0:  MOVF   41,W
0EF1:  MOVWF  2D
0EF2:  MOVF   40,W
0EF3:  MOVWF  2C
0EF4:  MOVF   3F,W
0EF5:  MOVWF  2B
0EF6:  MOVF   3E,W
0EF7:  MOVWF  2A
.................... if (pwm<pwm_min) 
0EF8:  MOVF   5C,W
0EF9:  SUBWF  71,W
0EFA:  BTFSC  03.0
0EFB:  GOTO   701
.................... {pwm=pwm_min; 
0EFC:  MOVF   5C,W
0EFD:  MOVWF  71
.................... set_pwm1_duty(pwm);} 
0EFE:  MOVF   71,W
0EFF:  MOVWF  15
0F00:  GOTO   718
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0F01:  MOVF   71,W
0F02:  SUBWF  5D,W
0F03:  BTFSS  03.0
0F04:  GOTO   709
0F05:  MOVF   5D,W
0F06:  SUBWF  71,W
0F07:  BTFSS  03.2
0F08:  GOTO   70E
.................... {pwm=pwm_max; 
0F09:  MOVF   5D,W
0F0A:  MOVWF  71
.................... set_pwm1_duty(pwm);} 
0F0B:  MOVF   71,W
0F0C:  MOVWF  15
0F0D:  GOTO   718
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0F0E:  MOVF   5D,W
0F0F:  SUBWF  71,W
0F10:  BTFSC  03.0
0F11:  GOTO   718
0F12:  MOVF   71,W
0F13:  SUBWF  5C,W
0F14:  BTFSC  03.0
0F15:  GOTO   718
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0F16:  MOVF   71,W
0F17:  MOVWF  15
.................... }} 
0F18:  GOTO   7FC
.................... else if(gradient<0) 
0F19:  MOVF   70,W
0F1A:  MOVWF  76
0F1B:  MOVF   6F,W
0F1C:  MOVWF  75
0F1D:  MOVF   6E,W
0F1E:  MOVWF  74
0F1F:  MOVF   6D,W
0F20:  MOVWF  73
0F21:  CLRF   7E
0F22:  CLRF   7D
0F23:  CLRF   7C
0F24:  CLRF   7B
0F25:  BCF    0A.3
0F26:  CALL   573
0F27:  BSF    0A.3
0F28:  BTFSS  03.0
0F29:  GOTO   765
.................... {  
.................... pwm-=delta; 
0F2A:  MOVF   5E,W
0F2B:  SUBWF  71,F
.................... PrevPsolar=Pin;  
0F2C:  MOVF   49,W
0F2D:  MOVWF  31
0F2E:  MOVF   48,W
0F2F:  MOVWF  30
0F30:  MOVF   47,W
0F31:  MOVWF  2F
0F32:  MOVF   46,W
0F33:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0F34:  MOVF   39,W
0F35:  MOVWF  29
0F36:  MOVF   38,W
0F37:  MOVWF  28
0F38:  MOVF   37,W
0F39:  MOVWF  27
0F3A:  MOVF   36,W
0F3B:  MOVWF  26
.................... PrevIsolar=Isolar;  
0F3C:  MOVF   41,W
0F3D:  MOVWF  2D
0F3E:  MOVF   40,W
0F3F:  MOVWF  2C
0F40:  MOVF   3F,W
0F41:  MOVWF  2B
0F42:  MOVF   3E,W
0F43:  MOVWF  2A
.................... if (pwm<pwm_min) 
0F44:  MOVF   5C,W
0F45:  SUBWF  71,W
0F46:  BTFSC  03.0
0F47:  GOTO   74D
.................... { 
.................... pwm=pwm_min; 
0F48:  MOVF   5C,W
0F49:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F4A:  MOVF   71,W
0F4B:  MOVWF  15
.................... } 
0F4C:  GOTO   764
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0F4D:  MOVF   71,W
0F4E:  SUBWF  5D,W
0F4F:  BTFSS  03.0
0F50:  GOTO   755
0F51:  MOVF   5D,W
0F52:  SUBWF  71,W
0F53:  BTFSS  03.2
0F54:  GOTO   75A
.................... { 
.................... pwm=pwm_max; 
0F55:  MOVF   5D,W
0F56:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F57:  MOVF   71,W
0F58:  MOVWF  15
.................... } 
0F59:  GOTO   764
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0F5A:  MOVF   5D,W
0F5B:  SUBWF  71,W
0F5C:  BTFSC  03.0
0F5D:  GOTO   764
0F5E:  MOVF   71,W
0F5F:  SUBWF  5C,W
0F60:  BTFSC  03.0
0F61:  GOTO   764
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0F62:  MOVF   71,W
0F63:  MOVWF  15
.................... }} 
0F64:  GOTO   7FC
.................... else  
.................... { 
.................... if(delta_I>0) 
0F65:  CLRF   76
0F66:  CLRF   75
0F67:  CLRF   74
0F68:  CLRF   73
0F69:  MOVF   6C,W
0F6A:  MOVWF  7E
0F6B:  MOVF   6B,W
0F6C:  MOVWF  7D
0F6D:  MOVF   6A,W
0F6E:  MOVWF  7C
0F6F:  MOVF   69,W
0F70:  MOVWF  7B
0F71:  BCF    0A.3
0F72:  CALL   573
0F73:  BSF    0A.3
0F74:  BTFSS  03.0
0F75:  GOTO   7B1
.................... {  
.................... pwm+=delta; 
0F76:  MOVF   5E,W
0F77:  ADDWF  71,F
.................... PrevPsolar=Pin;  
0F78:  MOVF   49,W
0F79:  MOVWF  31
0F7A:  MOVF   48,W
0F7B:  MOVWF  30
0F7C:  MOVF   47,W
0F7D:  MOVWF  2F
0F7E:  MOVF   46,W
0F7F:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0F80:  MOVF   39,W
0F81:  MOVWF  29
0F82:  MOVF   38,W
0F83:  MOVWF  28
0F84:  MOVF   37,W
0F85:  MOVWF  27
0F86:  MOVF   36,W
0F87:  MOVWF  26
.................... PrevIsolar=Isolar; 
0F88:  MOVF   41,W
0F89:  MOVWF  2D
0F8A:  MOVF   40,W
0F8B:  MOVWF  2C
0F8C:  MOVF   3F,W
0F8D:  MOVWF  2B
0F8E:  MOVF   3E,W
0F8F:  MOVWF  2A
.................... if (pwm<pwm_min) 
0F90:  MOVF   5C,W
0F91:  SUBWF  71,W
0F92:  BTFSC  03.0
0F93:  GOTO   799
.................... { 
.................... pwm=pwm_min; 
0F94:  MOVF   5C,W
0F95:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0F96:  MOVF   71,W
0F97:  MOVWF  15
.................... } 
0F98:  GOTO   7B0
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0F99:  MOVF   71,W
0F9A:  SUBWF  5D,W
0F9B:  BTFSS  03.0
0F9C:  GOTO   7A1
0F9D:  MOVF   5D,W
0F9E:  SUBWF  71,W
0F9F:  BTFSS  03.2
0FA0:  GOTO   7A6
.................... { 
.................... pwm=pwm_max; 
0FA1:  MOVF   5D,W
0FA2:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0FA3:  MOVF   71,W
0FA4:  MOVWF  15
.................... } 
0FA5:  GOTO   7B0
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0FA6:  MOVF   5D,W
0FA7:  SUBWF  71,W
0FA8:  BTFSC  03.0
0FA9:  GOTO   7B0
0FAA:  MOVF   71,W
0FAB:  SUBWF  5C,W
0FAC:  BTFSC  03.0
0FAD:  GOTO   7B0
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
0FAE:  MOVF   71,W
0FAF:  MOVWF  15
.................... }} 
0FB0:  GOTO   7FC
.................... else if(delta_I<0) 
0FB1:  MOVF   6C,W
0FB2:  MOVWF  76
0FB3:  MOVF   6B,W
0FB4:  MOVWF  75
0FB5:  MOVF   6A,W
0FB6:  MOVWF  74
0FB7:  MOVF   69,W
0FB8:  MOVWF  73
0FB9:  CLRF   7E
0FBA:  CLRF   7D
0FBB:  CLRF   7C
0FBC:  CLRF   7B
0FBD:  BCF    0A.3
0FBE:  CALL   573
0FBF:  BSF    0A.3
0FC0:  BTFSS  03.0
0FC1:  GOTO   7FC
.................... {  
.................... pwm-=delta; 
0FC2:  MOVF   5E,W
0FC3:  SUBWF  71,F
.................... PrevPsolar=Pin;  
0FC4:  MOVF   49,W
0FC5:  MOVWF  31
0FC6:  MOVF   48,W
0FC7:  MOVWF  30
0FC8:  MOVF   47,W
0FC9:  MOVWF  2F
0FCA:  MOVF   46,W
0FCB:  MOVWF  2E
.................... PrevVsolar=Vsolar;  
0FCC:  MOVF   39,W
0FCD:  MOVWF  29
0FCE:  MOVF   38,W
0FCF:  MOVWF  28
0FD0:  MOVF   37,W
0FD1:  MOVWF  27
0FD2:  MOVF   36,W
0FD3:  MOVWF  26
.................... PrevIsolar=Isolar; 
0FD4:  MOVF   41,W
0FD5:  MOVWF  2D
0FD6:  MOVF   40,W
0FD7:  MOVWF  2C
0FD8:  MOVF   3F,W
0FD9:  MOVWF  2B
0FDA:  MOVF   3E,W
0FDB:  MOVWF  2A
.................... if (pwm<pwm_min) 
0FDC:  MOVF   5C,W
0FDD:  SUBWF  71,W
0FDE:  BTFSC  03.0
0FDF:  GOTO   7E5
.................... { 
.................... pwm=pwm_min; 
0FE0:  MOVF   5C,W
0FE1:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0FE2:  MOVF   71,W
0FE3:  MOVWF  15
.................... } 
0FE4:  GOTO   7FC
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0FE5:  MOVF   71,W
0FE6:  SUBWF  5D,W
0FE7:  BTFSS  03.0
0FE8:  GOTO   7ED
0FE9:  MOVF   5D,W
0FEA:  SUBWF  71,W
0FEB:  BTFSS  03.2
0FEC:  GOTO   7F2
.................... { 
.................... pwm=pwm_max; 
0FED:  MOVF   5D,W
0FEE:  MOVWF  71
.................... set_pwm1_duty(pwm); 
0FEF:  MOVF   71,W
0FF0:  MOVWF  15
.................... } 
0FF1:  GOTO   7FC
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0FF2:  MOVF   5D,W
0FF3:  SUBWF  71,W
0FF4:  BTFSC  03.0
0FF5:  GOTO   7FC
0FF6:  MOVF   71,W
0FF7:  SUBWF  5C,W
0FF8:  BTFSC  03.0
0FF9:  GOTO   7FC
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm);}}}}}} 
0FFA:  MOVF   71,W
0FFB:  MOVWF  15
....................   
0FFC:  SLEEP
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
