CCS PCM C Compiler, Version 5.015, 5967               25-Feb-19 11:18

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\MPPT4\gib.lst

               ROM used:   1440 words (18%)
                           Largest free fragment is 2048
               RAM used:   65 (18%) at main() level
                           81 (22%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   307
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
*
001A:  MOVLW  8E
001B:  MOVWF  77
001C:  MOVF   59,W
001D:  MOVWF  78
001E:  MOVF   58,W
001F:  MOVWF  79
0020:  CLRF   7A
0021:  MOVF   78,F
0022:  BTFSS  03.2
0023:  GOTO   02E
0024:  MOVF   79,W
0025:  MOVWF  78
0026:  CLRF   79
0027:  MOVLW  08
0028:  SUBWF  77,F
0029:  MOVF   78,F
002A:  BTFSS  03.2
002B:  GOTO   02E
002C:  CLRF   77
002D:  GOTO   036
002E:  BCF    03.0
002F:  BTFSC  78.7
0030:  GOTO   035
0031:  RLF    79,F
0032:  RLF    78,F
0033:  DECF   77,F
0034:  GOTO   02E
0035:  BCF    78.7
0036:  RETURN
0037:  MOVF   58,W
0038:  BTFSC  03.2
0039:  GOTO   0A7
003A:  MOVWF  60
003B:  MOVF   5C,W
003C:  BTFSC  03.2
003D:  GOTO   0A7
003E:  ADDWF  60,F
003F:  BTFSC  03.0
0040:  GOTO   048
0041:  MOVLW  7F
0042:  SUBWF  60,F
0043:  BTFSS  03.0
0044:  GOTO   0A7
0045:  BTFSC  03.2
0046:  GOTO   0A7
0047:  GOTO   04C
0048:  MOVLW  81
0049:  ADDWF  60,F
004A:  BTFSC  03.0
004B:  GOTO   0A7
004C:  MOVF   60,W
004D:  MOVWF  77
004E:  CLRF   78
004F:  CLRF   79
0050:  CLRF   7A
0051:  MOVF   59,W
0052:  MOVWF  64
0053:  BSF    64.7
0054:  MOVF   5A,W
0055:  MOVWF  63
0056:  MOVF   5B,W
0057:  MOVWF  62
0058:  MOVLW  18
0059:  MOVWF  60
005A:  CLRF   61
005B:  BTFSS  62.0
005C:  GOTO   075
005D:  MOVF   5F,W
005E:  ADDWF  7A,F
005F:  BTFSS  03.0
0060:  GOTO   067
0061:  INCF   79,F
0062:  BTFSS  03.2
0063:  GOTO   067
0064:  INCF   78,F
0065:  BTFSC  03.2
0066:  BSF    61.7
0067:  MOVF   5E,W
0068:  ADDWF  79,F
0069:  BTFSS  03.0
006A:  GOTO   06E
006B:  INCF   78,F
006C:  BTFSC  03.2
006D:  BSF    61.7
006E:  MOVF   5D,W
006F:  MOVWF  5A
0070:  BSF    5A.7
0071:  MOVF   5A,W
0072:  ADDWF  78,F
0073:  BTFSC  03.0
0074:  BSF    61.7
0075:  RLF    61,F
0076:  RRF    78,F
0077:  RRF    79,F
0078:  RRF    7A,F
0079:  RRF    64,F
007A:  RRF    63,F
007B:  RRF    62,F
007C:  BCF    03.0
007D:  DECFSZ 60,F
007E:  GOTO   05A
007F:  MOVLW  01
0080:  ADDWF  77,F
0081:  BTFSC  03.0
0082:  GOTO   0A7
0083:  BTFSC  78.7
0084:  GOTO   08C
0085:  RLF    64,F
0086:  RLF    7A,F
0087:  RLF    79,F
0088:  RLF    78,F
0089:  DECF   77,F
008A:  BTFSC  03.2
008B:  GOTO   0A7
008C:  BTFSS  64.7
008D:  GOTO   09D
008E:  INCF   7A,F
008F:  BTFSS  03.2
0090:  GOTO   09D
0091:  INCF   79,F
0092:  BTFSS  03.2
0093:  GOTO   09D
0094:  INCF   78,F
0095:  BTFSS  03.2
0096:  GOTO   09D
0097:  RRF    78,F
0098:  RRF    79,F
0099:  RRF    7A,F
009A:  INCF   77,F
009B:  BTFSC  03.2
009C:  GOTO   0A7
009D:  MOVF   59,W
009E:  MOVWF  61
009F:  MOVF   5D,W
00A0:  XORWF  61,F
00A1:  BTFSS  61.7
00A2:  GOTO   0A5
00A3:  BSF    78.7
00A4:  GOTO   0AB
00A5:  BCF    78.7
00A6:  GOTO   0AB
00A7:  CLRF   77
00A8:  CLRF   78
00A9:  CLRF   79
00AA:  CLRF   7A
00AB:  RETURN
00AC:  MOVF   5C,W
00AD:  BTFSC  03.2
00AE:  GOTO   171
00AF:  MOVWF  68
00B0:  MOVF   60,W
00B1:  BTFSC  03.2
00B2:  GOTO   171
00B3:  SUBWF  68,F
00B4:  BTFSS  03.0
00B5:  GOTO   0BB
00B6:  MOVLW  7F
00B7:  ADDWF  68,F
00B8:  BTFSC  03.0
00B9:  GOTO   171
00BA:  GOTO   0C1
00BB:  MOVLW  81
00BC:  SUBWF  68,F
00BD:  BTFSS  03.0
00BE:  GOTO   171
00BF:  BTFSC  03.2
00C0:  GOTO   171
00C1:  MOVF   68,W
00C2:  MOVWF  77
00C3:  CLRF   78
00C4:  CLRF   79
00C5:  CLRF   7A
00C6:  CLRF   67
00C7:  MOVF   5D,W
00C8:  MOVWF  66
00C9:  BSF    66.7
00CA:  MOVF   5E,W
00CB:  MOVWF  65
00CC:  MOVF   5F,W
00CD:  MOVWF  64
00CE:  MOVLW  19
00CF:  MOVWF  68
00D0:  MOVF   63,W
00D1:  SUBWF  64,F
00D2:  BTFSC  03.0
00D3:  GOTO   0E4
00D4:  MOVLW  01
00D5:  SUBWF  65,F
00D6:  BTFSC  03.0
00D7:  GOTO   0E4
00D8:  SUBWF  66,F
00D9:  BTFSC  03.0
00DA:  GOTO   0E4
00DB:  SUBWF  67,F
00DC:  BTFSC  03.0
00DD:  GOTO   0E4
00DE:  INCF   67,F
00DF:  INCF   66,F
00E0:  INCF   65,F
00E1:  MOVF   63,W
00E2:  ADDWF  64,F
00E3:  GOTO   116
00E4:  MOVF   62,W
00E5:  SUBWF  65,F
00E6:  BTFSC  03.0
00E7:  GOTO   0FF
00E8:  MOVLW  01
00E9:  SUBWF  66,F
00EA:  BTFSC  03.0
00EB:  GOTO   0FF
00EC:  SUBWF  67,F
00ED:  BTFSC  03.0
00EE:  GOTO   0FF
00EF:  INCF   67,F
00F0:  INCF   66,F
00F1:  MOVF   62,W
00F2:  ADDWF  65,F
00F3:  MOVF   63,W
00F4:  ADDWF  64,F
00F5:  BTFSS  03.0
00F6:  GOTO   116
00F7:  INCF   65,F
00F8:  BTFSS  03.2
00F9:  GOTO   116
00FA:  INCF   66,F
00FB:  BTFSS  03.2
00FC:  GOTO   116
00FD:  INCF   67,F
00FE:  GOTO   116
00FF:  MOVF   61,W
0100:  IORLW  80
0101:  SUBWF  66,F
0102:  BTFSC  03.0
0103:  GOTO   115
0104:  MOVLW  01
0105:  SUBWF  67,F
0106:  BTFSC  03.0
0107:  GOTO   115
0108:  INCF   67,F
0109:  MOVF   61,W
010A:  IORLW  80
010B:  ADDWF  66,F
010C:  MOVF   62,W
010D:  ADDWF  65,F
010E:  BTFSS  03.0
010F:  GOTO   0F3
0110:  INCF   66,F
0111:  BTFSS  03.2
0112:  GOTO   0F3
0113:  INCF   67,F
0114:  GOTO   0F3
0115:  BSF    7A.0
0116:  DECFSZ 68,F
0117:  GOTO   119
0118:  GOTO   124
0119:  BCF    03.0
011A:  RLF    64,F
011B:  RLF    65,F
011C:  RLF    66,F
011D:  RLF    67,F
011E:  BCF    03.0
011F:  RLF    7A,F
0120:  RLF    79,F
0121:  RLF    78,F
0122:  RLF    69,F
0123:  GOTO   0D0
0124:  BTFSS  69.0
0125:  GOTO   12C
0126:  BCF    03.0
0127:  RRF    78,F
0128:  RRF    79,F
0129:  RRF    7A,F
012A:  RRF    69,F
012B:  GOTO   12F
012C:  DECF   77,F
012D:  BTFSC  03.2
012E:  GOTO   171
012F:  BTFSC  69.7
0130:  GOTO   158
0131:  BCF    03.0
0132:  RLF    64,F
0133:  RLF    65,F
0134:  RLF    66,F
0135:  RLF    67,F
0136:  MOVF   63,W
0137:  SUBWF  64,F
0138:  BTFSC  03.0
0139:  GOTO   144
013A:  MOVLW  01
013B:  SUBWF  65,F
013C:  BTFSC  03.0
013D:  GOTO   144
013E:  SUBWF  66,F
013F:  BTFSC  03.0
0140:  GOTO   144
0141:  SUBWF  67,F
0142:  BTFSS  03.0
0143:  GOTO   167
0144:  MOVF   62,W
0145:  SUBWF  65,F
0146:  BTFSC  03.0
0147:  GOTO   14F
0148:  MOVLW  01
0149:  SUBWF  66,F
014A:  BTFSC  03.0
014B:  GOTO   14F
014C:  SUBWF  67,F
014D:  BTFSS  03.0
014E:  GOTO   167
014F:  MOVF   61,W
0150:  IORLW  80
0151:  SUBWF  66,F
0152:  BTFSC  03.0
0153:  GOTO   158
0154:  MOVLW  01
0155:  SUBWF  67,F
0156:  BTFSS  03.0
0157:  GOTO   167
0158:  INCF   7A,F
0159:  BTFSS  03.2
015A:  GOTO   167
015B:  INCF   79,F
015C:  BTFSS  03.2
015D:  GOTO   167
015E:  INCF   78,F
015F:  BTFSS  03.2
0160:  GOTO   167
0161:  INCF   77,F
0162:  BTFSC  03.2
0163:  GOTO   171
0164:  RRF    78,F
0165:  RRF    79,F
0166:  RRF    7A,F
0167:  MOVF   5D,W
0168:  MOVWF  68
0169:  MOVF   61,W
016A:  XORWF  68,F
016B:  BTFSS  68.7
016C:  GOTO   16F
016D:  BSF    78.7
016E:  GOTO   175
016F:  BCF    78.7
0170:  GOTO   175
0171:  CLRF   77
0172:  CLRF   78
0173:  CLRF   79
0174:  CLRF   7A
0175:  RETURN
*
0187:  MOVLW  80
0188:  BTFSC  03.1
0189:  XORWF  61,F
018A:  CLRF   66
018B:  CLRF   67
018C:  MOVF   5D,W
018D:  MOVWF  65
018E:  MOVF   61,W
018F:  XORWF  65,F
0190:  MOVF   5C,W
0191:  BTFSC  03.2
0192:  GOTO   277
0193:  MOVWF  64
0194:  MOVWF  77
0195:  MOVF   60,W
0196:  BTFSC  03.2
0197:  GOTO   280
0198:  SUBWF  64,F
0199:  BTFSC  03.2
019A:  GOTO   21C
019B:  BTFSS  03.0
019C:  GOTO   1DA
019D:  MOVF   61,W
019E:  MOVWF  6A
019F:  BSF    6A.7
01A0:  MOVF   62,W
01A1:  MOVWF  69
01A2:  MOVF   63,W
01A3:  MOVWF  68
01A4:  CLRF   67
01A5:  BCF    03.0
01A6:  RRF    6A,F
01A7:  RRF    69,F
01A8:  RRF    68,F
01A9:  RRF    67,F
01AA:  DECFSZ 64,F
01AB:  GOTO   1A4
01AC:  BTFSS  65.7
01AD:  GOTO   1B1
01AE:  BSF    66.0
01AF:  GOTO   294
01B0:  BCF    66.0
01B1:  BCF    64.0
01B2:  BSF    66.4
01B3:  MOVLW  5F
01B4:  MOVWF  04
01B5:  BCF    03.7
01B6:  GOTO   2A9
01B7:  BCF    66.4
01B8:  BTFSC  65.7
01B9:  GOTO   1C4
01BA:  BTFSS  64.0
01BB:  GOTO   1CF
01BC:  RRF    6A,F
01BD:  RRF    69,F
01BE:  RRF    68,F
01BF:  RRF    67,F
01C0:  INCF   77,F
01C1:  BTFSC  03.2
01C2:  GOTO   28F
01C3:  GOTO   1CF
01C4:  BTFSC  6A.7
01C5:  GOTO   1D2
01C6:  BCF    03.0
01C7:  RLF    67,F
01C8:  RLF    68,F
01C9:  RLF    69,F
01CA:  RLF    6A,F
01CB:  DECF   77,F
01CC:  BTFSC  03.2
01CD:  GOTO   28F
01CE:  GOTO   1C4
01CF:  BSF    66.6
01D0:  GOTO   23C
01D1:  BCF    66.6
01D2:  MOVF   5D,W
01D3:  MOVWF  65
01D4:  BTFSS  65.7
01D5:  GOTO   1D8
01D6:  BSF    6A.7
01D7:  GOTO   288
01D8:  BCF    6A.7
01D9:  GOTO   288
01DA:  MOVF   60,W
01DB:  MOVWF  64
01DC:  MOVWF  77
01DD:  MOVF   5C,W
01DE:  SUBWF  64,F
01DF:  MOVF   5D,W
01E0:  MOVWF  6A
01E1:  BSF    6A.7
01E2:  MOVF   5E,W
01E3:  MOVWF  69
01E4:  MOVF   5F,W
01E5:  MOVWF  68
01E6:  CLRF   67
01E7:  BCF    03.0
01E8:  RRF    6A,F
01E9:  RRF    69,F
01EA:  RRF    68,F
01EB:  RRF    67,F
01EC:  DECFSZ 64,F
01ED:  GOTO   1E6
01EE:  BTFSS  65.7
01EF:  GOTO   1F3
01F0:  BSF    66.1
01F1:  GOTO   294
01F2:  BCF    66.1
01F3:  BCF    64.0
01F4:  BSF    66.5
01F5:  MOVLW  63
01F6:  MOVWF  04
01F7:  BCF    03.7
01F8:  GOTO   2A9
01F9:  BCF    66.5
01FA:  BTFSC  65.7
01FB:  GOTO   206
01FC:  BTFSS  64.0
01FD:  GOTO   211
01FE:  RRF    6A,F
01FF:  RRF    69,F
0200:  RRF    68,F
0201:  RRF    67,F
0202:  INCF   77,F
0203:  BTFSC  03.2
0204:  GOTO   28F
0205:  GOTO   211
0206:  BTFSC  6A.7
0207:  GOTO   214
0208:  BCF    03.0
0209:  RLF    67,F
020A:  RLF    68,F
020B:  RLF    69,F
020C:  RLF    6A,F
020D:  DECF   77,F
020E:  BTFSC  03.2
020F:  GOTO   28F
0210:  GOTO   206
0211:  BSF    66.7
0212:  GOTO   23C
0213:  BCF    66.7
0214:  MOVF   61,W
0215:  MOVWF  65
0216:  BTFSS  65.7
0217:  GOTO   21A
0218:  BSF    6A.7
0219:  GOTO   288
021A:  BCF    6A.7
021B:  GOTO   288
021C:  MOVF   61,W
021D:  MOVWF  6A
021E:  BSF    6A.7
021F:  MOVF   62,W
0220:  MOVWF  69
0221:  MOVF   63,W
0222:  MOVWF  68
0223:  BTFSS  65.7
0224:  GOTO   229
0225:  BCF    6A.7
0226:  BSF    66.2
0227:  GOTO   294
0228:  BCF    66.2
0229:  CLRF   67
022A:  BCF    64.0
022B:  MOVLW  5F
022C:  MOVWF  04
022D:  BCF    03.7
022E:  GOTO   2A9
022F:  BTFSC  65.7
0230:  GOTO   252
0231:  MOVF   5D,W
0232:  MOVWF  65
0233:  BTFSS  64.0
0234:  GOTO   23C
0235:  RRF    6A,F
0236:  RRF    69,F
0237:  RRF    68,F
0238:  RRF    67,F
0239:  INCF   77,F
023A:  BTFSC  03.2
023B:  GOTO   28F
023C:  BTFSS  67.7
023D:  GOTO   24D
023E:  INCF   68,F
023F:  BTFSS  03.2
0240:  GOTO   24D
0241:  INCF   69,F
0242:  BTFSS  03.2
0243:  GOTO   24D
0244:  INCF   6A,F
0245:  BTFSS  03.2
0246:  GOTO   24D
0247:  RRF    6A,F
0248:  RRF    69,F
0249:  RRF    68,F
024A:  INCF   77,F
024B:  BTFSC  03.2
024C:  GOTO   28F
024D:  BTFSC  66.6
024E:  GOTO   1D1
024F:  BTFSC  66.7
0250:  GOTO   213
0251:  GOTO   271
0252:  MOVLW  80
0253:  XORWF  6A,F
0254:  BTFSS  6A.7
0255:  GOTO   25A
0256:  GOTO   294
0257:  MOVF   61,W
0258:  MOVWF  65
0259:  GOTO   267
025A:  MOVF   5D,W
025B:  MOVWF  65
025C:  MOVF   6A,F
025D:  BTFSS  03.2
025E:  GOTO   267
025F:  MOVF   69,F
0260:  BTFSS  03.2
0261:  GOTO   267
0262:  MOVF   68,F
0263:  BTFSS  03.2
0264:  GOTO   267
0265:  CLRF   77
0266:  GOTO   288
0267:  BTFSC  6A.7
0268:  GOTO   271
0269:  BCF    03.0
026A:  RLF    67,F
026B:  RLF    68,F
026C:  RLF    69,F
026D:  RLF    6A,F
026E:  DECFSZ 77,F
026F:  GOTO   267
0270:  GOTO   28F
0271:  BTFSS  65.7
0272:  GOTO   275
0273:  BSF    6A.7
0274:  GOTO   288
0275:  BCF    6A.7
0276:  GOTO   288
0277:  MOVF   60,W
0278:  MOVWF  77
0279:  MOVF   61,W
027A:  MOVWF  6A
027B:  MOVF   62,W
027C:  MOVWF  69
027D:  MOVF   63,W
027E:  MOVWF  68
027F:  GOTO   288
0280:  MOVF   5C,W
0281:  MOVWF  77
0282:  MOVF   5D,W
0283:  MOVWF  6A
0284:  MOVF   5E,W
0285:  MOVWF  69
0286:  MOVF   5F,W
0287:  MOVWF  68
0288:  MOVF   6A,W
0289:  MOVWF  78
028A:  MOVF   69,W
028B:  MOVWF  79
028C:  MOVF   68,W
028D:  MOVWF  7A
028E:  GOTO   2C7
028F:  CLRF   77
0290:  CLRF   78
0291:  CLRF   79
0292:  CLRF   7A
0293:  GOTO   2C7
0294:  CLRF   67
0295:  COMF   68,F
0296:  COMF   69,F
0297:  COMF   6A,F
0298:  COMF   67,F
0299:  INCF   67,F
029A:  BTFSS  03.2
029B:  GOTO   2A2
029C:  INCF   68,F
029D:  BTFSS  03.2
029E:  GOTO   2A2
029F:  INCF   69,F
02A0:  BTFSC  03.2
02A1:  INCF   6A,F
02A2:  BTFSC  66.0
02A3:  GOTO   1B0
02A4:  BTFSC  66.1
02A5:  GOTO   1F2
02A6:  BTFSC  66.2
02A7:  GOTO   228
02A8:  GOTO   257
02A9:  MOVF   00,W
02AA:  ADDWF  68,F
02AB:  BTFSS  03.0
02AC:  GOTO   2B3
02AD:  INCF   69,F
02AE:  BTFSS  03.2
02AF:  GOTO   2B3
02B0:  INCF   6A,F
02B1:  BTFSC  03.2
02B2:  BSF    64.0
02B3:  DECF   04,F
02B4:  MOVF   00,W
02B5:  ADDWF  69,F
02B6:  BTFSS  03.0
02B7:  GOTO   2BB
02B8:  INCF   6A,F
02B9:  BTFSC  03.2
02BA:  BSF    64.0
02BB:  DECF   04,F
02BC:  MOVF   00,W
02BD:  BTFSS  00.7
02BE:  XORLW  80
02BF:  ADDWF  6A,F
02C0:  BTFSC  03.0
02C1:  BSF    64.0
02C2:  BTFSC  66.4
02C3:  GOTO   1B7
02C4:  BTFSC  66.5
02C5:  GOTO   1F9
02C6:  GOTO   22F
02C7:  RETURN
02C8:  MOVF   59,W
02C9:  MOVWF  60
02CA:  MOVF   5D,W
02CB:  XORWF  60,F
02CC:  BTFSS  60.7
02CD:  GOTO   2D3
02CE:  BCF    03.2
02CF:  BCF    03.0
02D0:  BTFSC  59.7
02D1:  BSF    03.0
02D2:  GOTO   306
02D3:  MOVF   59,W
02D4:  MOVWF  60
02D5:  MOVF   5C,W
02D6:  MOVWF  61
02D7:  MOVF   58,W
02D8:  SUBWF  61,F
02D9:  BTFSC  03.2
02DA:  GOTO   2E1
02DB:  BTFSS  60.7
02DC:  GOTO   306
02DD:  MOVF   03,W
02DE:  XORLW  01
02DF:  MOVWF  03
02E0:  GOTO   306
02E1:  MOVF   5D,W
02E2:  MOVWF  61
02E3:  MOVF   59,W
02E4:  SUBWF  61,F
02E5:  BTFSC  03.2
02E6:  GOTO   2ED
02E7:  BTFSS  60.7
02E8:  GOTO   306
02E9:  MOVF   03,W
02EA:  XORLW  01
02EB:  MOVWF  03
02EC:  GOTO   306
02ED:  MOVF   5E,W
02EE:  MOVWF  61
02EF:  MOVF   5A,W
02F0:  SUBWF  61,F
02F1:  BTFSC  03.2
02F2:  GOTO   2F9
02F3:  BTFSS  60.7
02F4:  GOTO   306
02F5:  MOVF   03,W
02F6:  XORLW  01
02F7:  MOVWF  03
02F8:  GOTO   306
02F9:  MOVF   5F,W
02FA:  MOVWF  61
02FB:  MOVF   5B,W
02FC:  SUBWF  61,F
02FD:  BTFSC  03.2
02FE:  GOTO   305
02FF:  BTFSS  60.7
0300:  GOTO   306
0301:  MOVF   03,W
0302:  XORLW  01
0303:  MOVWF  03
0304:  GOTO   306
0305:  BCF    03.0
0306:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=20000000) 
*
0004:  MOVLW  59
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   017
000A:  MOVLW  06
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  7B
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  DECFSZ 00,F
0016:  GOTO   00A
0017:  BCF    0A.3
0018:  BCF    0A.4
0019:  GOTO   348 (RETURN)
*
0176:  MOVLW  03
0177:  SUBWF  58,F
0178:  BTFSS  03.0
0179:  GOTO   184
017A:  MOVLW  58
017B:  MOVWF  04
017C:  BCF    03.7
017D:  MOVF   00,W
017E:  BTFSC  03.2
017F:  GOTO   184
0180:  GOTO   182
0181:  GOTO   182
0182:  DECFSZ 00,F
0183:  GOTO   181
0184:  BCF    0A.3
0185:  BCF    0A.4
0186:  GOTO   3B4 (RETURN)
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0312:  BCF    03.5
0313:  CLRF   20
0314:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void main(void) 
*
0307:  MOVF   03,W
0308:  ANDLW  1F
0309:  MOVWF  03
030A:  MOVLW  FF
030B:  MOVWF  26
030C:  BSF    03.5
030D:  BSF    1F.0
030E:  BSF    1F.1
030F:  BSF    1F.2
0310:  BCF    1F.3
0311:  BCF    03.7
*
0315:  MOVLW  0A
0316:  MOVWF  28
0317:  MOVLW  06
0318:  MOVWF  29
0319:  MOVLW  0E
031A:  MOVWF  2A
031B:  MOVLW  01
031C:  MOVWF  2B
.................... { 
.................... int pwm; 
.................... int pwm_start=10; 
.................... int pwm_min=6; 
.................... int pwm_max=14; 
.................... int delta=1; 
.................... float adc_value,adc_value1; 
.................... float voltageold; 
.................... float currentold; 
.................... float measuredvoltage,measuredvoltage1; 
.................... float measuredcurrent; 
.................... float deltav; 
.................... float deltai; 
.................... float inc; 
.................... float cond; 
....................  
.................... voltageold=0; 
031D:  CLRF   37
031E:  CLRF   36
031F:  CLRF   35
0320:  CLRF   34
.................... currentold=0; 
0321:  CLRF   3B
0322:  CLRF   3A
0323:  CLRF   39
0324:  CLRF   38
.................... pwm=pwm_start; 
0325:  MOVF   28,W
0326:  MOVWF  27
....................  
.................... while(1) 
.................... {  
.................... setup_adc(ADC_CLOCK_DIV_8);    
0327:  BSF    1F.6
0328:  BCF    1F.7
0329:  BSF    03.5
032A:  BSF    1F.7
032B:  BCF    03.5
032C:  BSF    1F.0
.................... setup_adc_ports(ALL_ANALOG);    
032D:  BSF    03.5
032E:  BCF    1F.0
032F:  BCF    1F.1
0330:  BCF    1F.2
0331:  BCF    1F.3
....................  
.................... setup_ccp1(ccp_pwm);          /* setup pin CCP1 (RC2) to do PWM */ 
0332:  BCF    03.5
0333:  BCF    26.2
0334:  MOVF   26,W
0335:  BSF    03.5
0336:  MOVWF  07
0337:  BCF    03.5
0338:  BCF    07.2
0339:  MOVLW  0C
033A:  MOVWF  17
....................  
.................... setup_timer_2(T2_DIV_BY_1,19,1);   /* 50 KHZ */ 
033B:  MOVLW  00
033C:  MOVWF  78
033D:  IORLW  04
033E:  MOVWF  12
033F:  MOVLW  13
0340:  BSF    03.5
0341:  MOVWF  12
....................  
.................... delay_ms(1000);  
0342:  MOVLW  04
0343:  BCF    03.5
0344:  MOVWF  58
0345:  MOVLW  FA
0346:  MOVWF  59
0347:  GOTO   004
0348:  DECFSZ 58,F
0349:  GOTO   345
....................  
.................... set_adc_channel(0); 
034A:  MOVLW  00
034B:  MOVWF  78
034C:  MOVF   1F,W
034D:  ANDLW  C7
034E:  IORWF  78,W
034F:  MOVWF  1F
.................... delay_us(100); 
0350:  MOVLW  A6
0351:  MOVWF  77
0352:  DECFSZ 77,F
0353:  GOTO   352
0354:  NOP
....................  
.................... adc_value = read_adc(); 
0355:  BSF    1F.2
0356:  BTFSC  1F.2
0357:  GOTO   356
0358:  MOVF   1E,W
0359:  MOVWF  7A
035A:  BSF    03.5
035B:  MOVF   1E,W
035C:  BCF    03.5
035D:  MOVWF  58
035E:  MOVF   1E,W
035F:  MOVWF  59
0360:  CALL   01A
0361:  MOVF   7A,W
0362:  MOVWF  2F
0363:  MOVF   79,W
0364:  MOVWF  2E
0365:  MOVF   78,W
0366:  MOVWF  2D
0367:  MOVF   77,W
0368:  MOVWF  2C
....................  
.................... measuredvoltage = (5.0*adc_value/1023.0)/0.111; 
0369:  CLRF   5B
036A:  CLRF   5A
036B:  MOVLW  20
036C:  MOVWF  59
036D:  MOVLW  81
036E:  MOVWF  58
036F:  MOVF   2F,W
0370:  MOVWF  5F
0371:  MOVF   2E,W
0372:  MOVWF  5E
0373:  MOVF   2D,W
0374:  MOVWF  5D
0375:  MOVF   2C,W
0376:  MOVWF  5C
0377:  CALL   037
0378:  MOVF   7A,W
0379:  MOVWF  5B
037A:  MOVF   79,W
037B:  MOVWF  5A
037C:  MOVF   78,W
037D:  MOVWF  59
037E:  MOVF   77,W
037F:  MOVWF  58
0380:  MOVF   7A,W
0381:  MOVWF  5F
0382:  MOVF   79,W
0383:  MOVWF  5E
0384:  MOVF   78,W
0385:  MOVWF  5D
0386:  MOVF   77,W
0387:  MOVWF  5C
0388:  CLRF   63
0389:  MOVLW  C0
038A:  MOVWF  62
038B:  MOVLW  7F
038C:  MOVWF  61
038D:  MOVLW  88
038E:  MOVWF  60
038F:  CALL   0AC
0390:  MOVF   7A,W
0391:  MOVWF  5B
0392:  MOVF   79,W
0393:  MOVWF  5A
0394:  MOVF   78,W
0395:  MOVWF  59
0396:  MOVF   77,W
0397:  MOVWF  58
0398:  MOVF   7A,W
0399:  MOVWF  5F
039A:  MOVF   79,W
039B:  MOVWF  5E
039C:  MOVF   78,W
039D:  MOVWF  5D
039E:  MOVF   77,W
039F:  MOVWF  5C
03A0:  MOVLW  F8
03A1:  MOVWF  63
03A2:  MOVLW  53
03A3:  MOVWF  62
03A4:  MOVLW  63
03A5:  MOVWF  61
03A6:  MOVLW  7B
03A7:  MOVWF  60
03A8:  CALL   0AC
03A9:  MOVF   7A,W
03AA:  MOVWF  3F
03AB:  MOVF   79,W
03AC:  MOVWF  3E
03AD:  MOVF   78,W
03AE:  MOVWF  3D
03AF:  MOVF   77,W
03B0:  MOVWF  3C
....................  
.................... delay_us(200); 
03B1:  MOVLW  C8
03B2:  MOVWF  58
03B3:  GOTO   176
....................  
.................... adc_value1 = read_adc(); 
03B4:  BSF    1F.2
03B5:  BTFSC  1F.2
03B6:  GOTO   3B5
03B7:  MOVF   1E,W
03B8:  MOVWF  7A
03B9:  BSF    03.5
03BA:  MOVF   1E,W
03BB:  BCF    03.5
03BC:  MOVWF  58
03BD:  MOVF   1E,W
03BE:  MOVWF  59
03BF:  CALL   01A
03C0:  MOVF   7A,W
03C1:  MOVWF  33
03C2:  MOVF   79,W
03C3:  MOVWF  32
03C4:  MOVF   78,W
03C5:  MOVWF  31
03C6:  MOVF   77,W
03C7:  MOVWF  30
....................  
.................... measuredvoltage1 = (5.0*adc_value/1023.0)/0.111; 
03C8:  CLRF   5B
03C9:  CLRF   5A
03CA:  MOVLW  20
03CB:  MOVWF  59
03CC:  MOVLW  81
03CD:  MOVWF  58
03CE:  MOVF   2F,W
03CF:  MOVWF  5F
03D0:  MOVF   2E,W
03D1:  MOVWF  5E
03D2:  MOVF   2D,W
03D3:  MOVWF  5D
03D4:  MOVF   2C,W
03D5:  MOVWF  5C
03D6:  CALL   037
03D7:  MOVF   7A,W
03D8:  MOVWF  5B
03D9:  MOVF   79,W
03DA:  MOVWF  5A
03DB:  MOVF   78,W
03DC:  MOVWF  59
03DD:  MOVF   77,W
03DE:  MOVWF  58
03DF:  MOVF   7A,W
03E0:  MOVWF  5F
03E1:  MOVF   79,W
03E2:  MOVWF  5E
03E3:  MOVF   78,W
03E4:  MOVWF  5D
03E5:  MOVF   77,W
03E6:  MOVWF  5C
03E7:  CLRF   63
03E8:  MOVLW  C0
03E9:  MOVWF  62
03EA:  MOVLW  7F
03EB:  MOVWF  61
03EC:  MOVLW  88
03ED:  MOVWF  60
03EE:  CALL   0AC
03EF:  MOVF   7A,W
03F0:  MOVWF  5B
03F1:  MOVF   79,W
03F2:  MOVWF  5A
03F3:  MOVF   78,W
03F4:  MOVWF  59
03F5:  MOVF   77,W
03F6:  MOVWF  58
03F7:  MOVF   7A,W
03F8:  MOVWF  5F
03F9:  MOVF   79,W
03FA:  MOVWF  5E
03FB:  MOVF   78,W
03FC:  MOVWF  5D
03FD:  MOVF   77,W
03FE:  MOVWF  5C
03FF:  MOVLW  F8
0400:  MOVWF  63
0401:  MOVLW  53
0402:  MOVWF  62
0403:  MOVLW  63
0404:  MOVWF  61
0405:  MOVLW  7B
0406:  MOVWF  60
0407:  CALL   0AC
0408:  MOVF   7A,W
0409:  MOVWF  43
040A:  MOVF   79,W
040B:  MOVWF  42
040C:  MOVF   78,W
040D:  MOVWF  41
040E:  MOVF   77,W
040F:  MOVWF  40
....................  
....................  set_adc_channel(1); 
0410:  MOVLW  08
0411:  MOVWF  78
0412:  MOVF   1F,W
0413:  ANDLW  C7
0414:  IORWF  78,W
0415:  MOVWF  1F
.................... delay_us(100); 
0416:  MOVLW  A6
0417:  MOVWF  77
0418:  DECFSZ 77,F
0419:  GOTO   418
041A:  NOP
....................  
.................... adc_value = read_adc(); 
041B:  BSF    1F.2
041C:  BTFSC  1F.2
041D:  GOTO   41C
041E:  MOVF   1E,W
041F:  MOVWF  7A
0420:  BSF    03.5
0421:  MOVF   1E,W
0422:  BCF    03.5
0423:  MOVWF  58
0424:  MOVF   1E,W
0425:  MOVWF  59
0426:  CALL   01A
0427:  MOVF   7A,W
0428:  MOVWF  2F
0429:  MOVF   79,W
042A:  MOVWF  2E
042B:  MOVF   78,W
042C:  MOVWF  2D
042D:  MOVF   77,W
042E:  MOVWF  2C
....................  
.................... measuredcurrent = ((5.0/1023.0*adc_value)-2.5)/0.066; 
042F:  MOVLW  0A
0430:  MOVWF  5B
0431:  MOVLW  28
0432:  MOVWF  5A
0433:  MOVLW  20
0434:  MOVWF  59
0435:  MOVLW  77
0436:  MOVWF  58
0437:  MOVF   2F,W
0438:  MOVWF  5F
0439:  MOVF   2E,W
043A:  MOVWF  5E
043B:  MOVF   2D,W
043C:  MOVWF  5D
043D:  MOVF   2C,W
043E:  MOVWF  5C
043F:  CALL   037
0440:  MOVF   7A,W
0441:  MOVWF  5B
0442:  MOVF   79,W
0443:  MOVWF  5A
0444:  MOVF   78,W
0445:  MOVWF  59
0446:  MOVF   77,W
0447:  MOVWF  58
0448:  BSF    03.1
0449:  MOVF   7A,W
044A:  MOVWF  5F
044B:  MOVF   79,W
044C:  MOVWF  5E
044D:  MOVF   78,W
044E:  MOVWF  5D
044F:  MOVF   77,W
0450:  MOVWF  5C
0451:  CLRF   63
0452:  CLRF   62
0453:  MOVLW  20
0454:  MOVWF  61
0455:  MOVLW  80
0456:  MOVWF  60
0457:  CALL   187
0458:  MOVF   7A,W
0459:  MOVWF  5B
045A:  MOVF   79,W
045B:  MOVWF  5A
045C:  MOVF   78,W
045D:  MOVWF  59
045E:  MOVF   77,W
045F:  MOVWF  58
0460:  MOVF   7A,W
0461:  MOVWF  5F
0462:  MOVF   79,W
0463:  MOVWF  5E
0464:  MOVF   78,W
0465:  MOVWF  5D
0466:  MOVF   77,W
0467:  MOVWF  5C
0468:  MOVLW  02
0469:  MOVWF  63
046A:  MOVLW  2B
046B:  MOVWF  62
046C:  MOVLW  07
046D:  MOVWF  61
046E:  MOVLW  7B
046F:  MOVWF  60
0470:  CALL   0AC
0471:  MOVF   7A,W
0472:  MOVWF  47
0473:  MOVF   79,W
0474:  MOVWF  46
0475:  MOVF   78,W
0476:  MOVWF  45
0477:  MOVF   77,W
0478:  MOVWF  44
....................  
.................... deltav=measuredvoltage-voltageold; 
0479:  BSF    03.1
047A:  MOVF   3F,W
047B:  MOVWF  5F
047C:  MOVF   3E,W
047D:  MOVWF  5E
047E:  MOVF   3D,W
047F:  MOVWF  5D
0480:  MOVF   3C,W
0481:  MOVWF  5C
0482:  MOVF   37,W
0483:  MOVWF  63
0484:  MOVF   36,W
0485:  MOVWF  62
0486:  MOVF   35,W
0487:  MOVWF  61
0488:  MOVF   34,W
0489:  MOVWF  60
048A:  CALL   187
048B:  MOVF   7A,W
048C:  MOVWF  4B
048D:  MOVF   79,W
048E:  MOVWF  4A
048F:  MOVF   78,W
0490:  MOVWF  49
0491:  MOVF   77,W
0492:  MOVWF  48
....................  
.................... deltai=measuredcurrent-currentold; 
0493:  BSF    03.1
0494:  MOVF   47,W
0495:  MOVWF  5F
0496:  MOVF   46,W
0497:  MOVWF  5E
0498:  MOVF   45,W
0499:  MOVWF  5D
049A:  MOVF   44,W
049B:  MOVWF  5C
049C:  MOVF   3B,W
049D:  MOVWF  63
049E:  MOVF   3A,W
049F:  MOVWF  62
04A0:  MOVF   39,W
04A1:  MOVWF  61
04A2:  MOVF   38,W
04A3:  MOVWF  60
04A4:  CALL   187
04A5:  MOVF   7A,W
04A6:  MOVWF  4F
04A7:  MOVF   79,W
04A8:  MOVWF  4E
04A9:  MOVF   78,W
04AA:  MOVWF  4D
04AB:  MOVF   77,W
04AC:  MOVWF  4C
....................  
.................... inc=deltai/deltav; 
04AD:  MOVF   4F,W
04AE:  MOVWF  5F
04AF:  MOVF   4E,W
04B0:  MOVWF  5E
04B1:  MOVF   4D,W
04B2:  MOVWF  5D
04B3:  MOVF   4C,W
04B4:  MOVWF  5C
04B5:  MOVF   4B,W
04B6:  MOVWF  63
04B7:  MOVF   4A,W
04B8:  MOVWF  62
04B9:  MOVF   49,W
04BA:  MOVWF  61
04BB:  MOVF   48,W
04BC:  MOVWF  60
04BD:  CALL   0AC
04BE:  MOVF   7A,W
04BF:  MOVWF  53
04C0:  MOVF   79,W
04C1:  MOVWF  52
04C2:  MOVF   78,W
04C3:  MOVWF  51
04C4:  MOVF   77,W
04C5:  MOVWF  50
....................  
.................... cond=-(measuredcurrent/measuredvoltage); 
04C6:  MOVF   47,W
04C7:  MOVWF  5F
04C8:  MOVF   46,W
04C9:  MOVWF  5E
04CA:  MOVF   45,W
04CB:  MOVWF  5D
04CC:  MOVF   44,W
04CD:  MOVWF  5C
04CE:  MOVF   3F,W
04CF:  MOVWF  63
04D0:  MOVF   3E,W
04D1:  MOVWF  62
04D2:  MOVF   3D,W
04D3:  MOVWF  61
04D4:  MOVF   3C,W
04D5:  MOVWF  60
04D6:  CALL   0AC
04D7:  MOVF   77,W
04D8:  MOVWF  54
04D9:  MOVF   78,W
04DA:  XORLW  80
04DB:  MOVWF  55
04DC:  MOVF   79,W
04DD:  MOVWF  56
04DE:  MOVF   7A,W
04DF:  MOVWF  57
....................  
.................... while(deltav==0) 
04E0:  MOVF   4B,W
04E1:  MOVWF  5B
04E2:  MOVF   4A,W
04E3:  MOVWF  5A
04E4:  MOVF   49,W
04E5:  MOVWF  59
04E6:  MOVF   48,W
04E7:  MOVWF  58
04E8:  CLRF   5F
04E9:  CLRF   5E
04EA:  CLRF   5D
04EB:  CLRF   5C
04EC:  CALL   2C8
04ED:  BTFSS  03.2
04EE:  GOTO   521
.................... { 
.................... if(deltai==0) 
04EF:  MOVF   4F,W
04F0:  MOVWF  5B
04F1:  MOVF   4E,W
04F2:  MOVWF  5A
04F3:  MOVF   4D,W
04F4:  MOVWF  59
04F5:  MOVF   4C,W
04F6:  MOVWF  58
04F7:  CLRF   5F
04F8:  CLRF   5E
04F9:  CLRF   5D
04FA:  CLRF   5C
04FB:  CALL   2C8
04FC:  BTFSC  03.2
.................... { 
....................       pwm=pwm; 
.................... } 
04FD:  GOTO   520
.................... else 
.................... { 
.................... Do  
.................... { 
.................... pwm=pwm-delta; 
04FE:  MOVF   2B,W
04FF:  SUBWF  27,F
.................... } 
.................... while(deltai>0); 
0500:  CLRF   5B
0501:  CLRF   5A
0502:  CLRF   59
0503:  CLRF   58
0504:  MOVF   4F,W
0505:  MOVWF  5F
0506:  MOVF   4E,W
0507:  MOVWF  5E
0508:  MOVF   4D,W
0509:  MOVWF  5D
050A:  MOVF   4C,W
050B:  MOVWF  5C
050C:  CALL   2C8
050D:  BTFSC  03.0
050E:  GOTO   4FE
.................... Do  
.................... { 
.................... pwm=pwm+delta; 
050F:  MOVF   2B,W
0510:  ADDWF  27,F
.................... } 
.................... while(deltai<0); 
0511:  MOVF   4F,W
0512:  MOVWF  5B
0513:  MOVF   4E,W
0514:  MOVWF  5A
0515:  MOVF   4D,W
0516:  MOVWF  59
0517:  MOVF   4C,W
0518:  MOVWF  58
0519:  CLRF   5F
051A:  CLRF   5E
051B:  CLRF   5D
051C:  CLRF   5C
051D:  CALL   2C8
051E:  BTFSC  03.0
051F:  GOTO   50F
.................... } 
0520:  GOTO   4E0
.................... } 
....................  
.................... while(deltav!=0) 
0521:  MOVF   4B,W
0522:  MOVWF  5B
0523:  MOVF   4A,W
0524:  MOVWF  5A
0525:  MOVF   49,W
0526:  MOVWF  59
0527:  MOVF   48,W
0528:  MOVWF  58
0529:  CLRF   5F
052A:  CLRF   5E
052B:  CLRF   5D
052C:  CLRF   5C
052D:  CALL   2C8
052E:  BTFSC  03.2
052F:  GOTO   56E
.................... { 
.................... if(inc==cond) 
0530:  MOVF   53,W
0531:  MOVWF  5B
0532:  MOVF   52,W
0533:  MOVWF  5A
0534:  MOVF   51,W
0535:  MOVWF  59
0536:  MOVF   50,W
0537:  MOVWF  58
0538:  MOVF   57,W
0539:  MOVWF  5F
053A:  MOVF   56,W
053B:  MOVWF  5E
053C:  MOVF   55,W
053D:  MOVWF  5D
053E:  MOVF   54,W
053F:  MOVWF  5C
0540:  CALL   2C8
0541:  BTFSC  03.2
.................... { 
....................       pwm=pwm; 
.................... } 
0542:  GOTO   56D
.................... else 
.................... { 
.................... Do  
.................... { 
.................... pwm=pwm+delta; 
0543:  MOVF   2B,W
0544:  ADDWF  27,F
.................... } 
.................... while(inc>cond); 
0545:  MOVF   57,W
0546:  MOVWF  5B
0547:  MOVF   56,W
0548:  MOVWF  5A
0549:  MOVF   55,W
054A:  MOVWF  59
054B:  MOVF   54,W
054C:  MOVWF  58
054D:  MOVF   53,W
054E:  MOVWF  5F
054F:  MOVF   52,W
0550:  MOVWF  5E
0551:  MOVF   51,W
0552:  MOVWF  5D
0553:  MOVF   50,W
0554:  MOVWF  5C
0555:  CALL   2C8
0556:  BTFSC  03.0
0557:  GOTO   543
.................... Do  
.................... { 
.................... pwm=pwm-delta; 
0558:  MOVF   2B,W
0559:  SUBWF  27,F
.................... } 
.................... while(inc<cond); 
055A:  MOVF   53,W
055B:  MOVWF  5B
055C:  MOVF   52,W
055D:  MOVWF  5A
055E:  MOVF   51,W
055F:  MOVWF  59
0560:  MOVF   50,W
0561:  MOVWF  58
0562:  MOVF   57,W
0563:  MOVWF  5F
0564:  MOVF   56,W
0565:  MOVWF  5E
0566:  MOVF   55,W
0567:  MOVWF  5D
0568:  MOVF   54,W
0569:  MOVWF  5C
056A:  CALL   2C8
056B:  BTFSC  03.0
056C:  GOTO   558
.................... } 
056D:  GOTO   521
.................... } 
....................  
.................... voltageold =measuredvoltage; 
056E:  MOVF   3F,W
056F:  MOVWF  37
0570:  MOVF   3E,W
0571:  MOVWF  36
0572:  MOVF   3D,W
0573:  MOVWF  35
0574:  MOVF   3C,W
0575:  MOVWF  34
.................... currentold=measuredcurrent; 
0576:  MOVF   47,W
0577:  MOVWF  3B
0578:  MOVF   46,W
0579:  MOVWF  3A
057A:  MOVF   45,W
057B:  MOVWF  39
057C:  MOVF   44,W
057D:  MOVWF  38
.................... if (pwm<pwm_min) 
057E:  MOVF   29,W
057F:  SUBWF  27,W
0580:  BTFSC  03.0
0581:  GOTO   587
.................... { 
.................... pwm=pwm_min; 
0582:  MOVF   29,W
0583:  MOVWF  27
.................... set_pwm1_duty(pwm); 
0584:  MOVF   27,W
0585:  MOVWF  15
.................... } 
0586:  GOTO   59E
.................... else if (pwm>pwm_max || pwm==pwm_max) 
0587:  MOVF   27,W
0588:  SUBWF  2A,W
0589:  BTFSS  03.0
058A:  GOTO   58F
058B:  MOVF   2A,W
058C:  SUBWF  27,W
058D:  BTFSS  03.2
058E:  GOTO   594
.................... { 
.................... pwm=pwm_max; 
058F:  MOVF   2A,W
0590:  MOVWF  27
.................... set_pwm1_duty(pwm); 
0591:  MOVF   27,W
0592:  MOVWF  15
.................... } 
0593:  GOTO   59E
.................... else if (pwm<pwm_max && pwm>pwm_min) 
0594:  MOVF   2A,W
0595:  SUBWF  27,W
0596:  BTFSC  03.0
0597:  GOTO   59E
0598:  MOVF   27,W
0599:  SUBWF  29,W
059A:  BTFSC  03.0
059B:  GOTO   59E
.................... { 
.................... pwm=pwm; 
.................... set_pwm1_duty(pwm); 
059C:  MOVF   27,W
059D:  MOVWF  15
.................... } 
059E:  GOTO   327
....................  
....................  
.................... } 
.................... } 
059F:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
