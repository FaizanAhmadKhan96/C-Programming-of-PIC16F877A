CCS PCM C Compiler, Version 5.015, 5967               04-Mar-19 15:55

               Filename:   E:\BEE-7D\Final Year Project\PIC Microcontroller\Mid_defence\mt.lst

               ROM used:   2969 words (36%)
                           Largest free fragment is 2048
               RAM used:   75 (20%) at main() level
                           101 (27%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #if defined(__PCM__) 
.................... #include<16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
0004:  DATA CD,30
0005:  DATA E4,32
0006:  DATA 20,31
0007:  DATA 79,1D
0008:  DATA 00,00
0009:  DATA C6,30
000A:  DATA 69,3D
000B:  DATA 61,37
000C:  DATA AC,29
000D:  DATA E8,30
000E:  DATA EB,34
000F:  DATA 72,00
0010:  DATA CD,30
0011:  DATA E4,32
0012:  DATA 20,31
0013:  DATA 79,1D
0014:  DATA 00,01
0015:  DATA 41,37
0016:  DATA 64,10
0017:  DATA C8,30
0018:  DATA 6D,3D
0019:  DATA 61,00
001A:  DATA D6,27
001B:  DATA 4C,2A
001C:  DATA C1,23
001D:  DATA 45,1D
001E:  DATA 25,33
001F:  DATA 20,2B
0020:  DATA 00,00
0021:  DATA C3,2A
0022:  DATA 52,29
0023:  DATA 45,27
0024:  DATA 54,1D
0025:  DATA 25,33
0026:  DATA A0,20
0027:  DATA 00,01
0028:  DATA 49,27
0029:  DATA D0,2A
002A:  DATA 54,10
002B:  DATA D0,27
002C:  DATA D7,22
002D:  DATA 52,1D
002E:  DATA 00,01
002F:  DATA D6,27
0030:  DATA 4C,2A
0031:  DATA C1,23
0032:  DATA 45,1D
0033:  DATA A0,12
0034:  DATA 66,10
0035:  DATA 56,00
0036:  DATA C3,2A
0037:  DATA 52,29
0038:  DATA 45,27
0039:  DATA 54,1D
003A:  DATA A0,12
003B:  DATA 66,10
003C:  DATA 41,00
003D:  DATA CF,2A
003E:  DATA 54,28
003F:  DATA 55,2A
0040:  DATA 20,28
0041:  DATA CF,2B
0042:  DATA 45,29
0043:  DATA 3A,00
0044:  DATA CC,24
0045:  DATA 47,24
0046:  DATA 54,10
0047:  DATA 49,27
0048:  DATA D4,22
0049:  DATA CE,29
004A:  DATA 49,2A
004B:  DATA 59,1D
004C:  DATA 00,01
004D:  DATA 25,33
004E:  DATA 20,26
004F:  DATA 55,2C
0050:  DATA 00,01
0051:  DATA D4,22
0052:  DATA 4D,28
0053:  DATA 3A,10
0054:  DATA 25,33
0055:  DATA A0,21
0056:  DATA 00,00
*
00B5:  MOVF   0B,W
00B6:  MOVWF  63
00B7:  BCF    0B.7
00B8:  BSF    03.5
00B9:  BSF    03.6
00BA:  BSF    0C.7
00BB:  BSF    0C.0
00BC:  NOP
00BD:  NOP
00BE:  BCF    03.5
00BF:  BCF    03.6
00C0:  BTFSC  63.7
00C1:  BSF    0B.7
00C2:  BSF    03.6
00C3:  MOVF   0C,W
00C4:  ANDLW  7F
00C5:  BTFSC  03.2
00C6:  GOTO   109
00C7:  BCF    03.6
00C8:  MOVWF  63
00C9:  BSF    03.6
00CA:  MOVF   0D,W
00CB:  BCF    03.6
00CC:  MOVWF  64
00CD:  BSF    03.6
00CE:  MOVF   0F,W
00CF:  BCF    03.6
00D0:  MOVWF  65
00D1:  MOVF   63,W
00D2:  MOVWF  70
00D3:  CALL   09E
00D4:  MOVF   64,W
00D5:  BSF    03.6
00D6:  MOVWF  0D
00D7:  BCF    03.6
00D8:  MOVF   65,W
00D9:  BSF    03.6
00DA:  MOVWF  0F
00DB:  BCF    03.6
00DC:  MOVF   0B,W
00DD:  MOVWF  66
00DE:  BCF    0B.7
00DF:  BSF    03.5
00E0:  BSF    03.6
00E1:  BSF    0C.7
00E2:  BSF    0C.0
00E3:  NOP
00E4:  NOP
00E5:  BCF    03.5
00E6:  BCF    03.6
00E7:  BTFSC  66.7
00E8:  BSF    0B.7
00E9:  BSF    03.6
00EA:  RLF    0C,W
00EB:  RLF    0E,W
00EC:  ANDLW  7F
00ED:  BTFSC  03.2
00EE:  GOTO   109
00EF:  BCF    03.6
00F0:  MOVWF  63
00F1:  BSF    03.6
00F2:  MOVF   0D,W
00F3:  BCF    03.6
00F4:  MOVWF  64
00F5:  BSF    03.6
00F6:  MOVF   0F,W
00F7:  BCF    03.6
00F8:  MOVWF  65
00F9:  MOVF   63,W
00FA:  MOVWF  70
00FB:  CALL   09E
00FC:  MOVF   64,W
00FD:  BSF    03.6
00FE:  MOVWF  0D
00FF:  BCF    03.6
0100:  MOVF   65,W
0101:  BSF    03.6
0102:  MOVWF  0F
0103:  INCF   0D,F
0104:  BTFSC  03.2
0105:  INCF   0F,F
0106:  BCF    03.6
0107:  GOTO   0B5
0108:  BSF    03.6
0109:  BCF    03.6
010A:  RETURN
*
0123:  MOVLW  8E
0124:  MOVWF  77
0125:  MOVF   64,W
0126:  MOVWF  78
0127:  MOVF   63,W
0128:  MOVWF  79
0129:  CLRF   7A
012A:  MOVF   78,F
012B:  BTFSS  03.2
012C:  GOTO   137
012D:  MOVF   79,W
012E:  MOVWF  78
012F:  CLRF   79
0130:  MOVLW  08
0131:  SUBWF  77,F
0132:  MOVF   78,F
0133:  BTFSS  03.2
0134:  GOTO   137
0135:  CLRF   77
0136:  GOTO   13F
0137:  BCF    03.0
0138:  BTFSC  78.7
0139:  GOTO   13E
013A:  RLF    79,F
013B:  RLF    78,F
013C:  DECF   77,F
013D:  GOTO   137
013E:  BCF    78.7
013F:  RETURN
0140:  MOVF   70,W
0141:  BTFSC  03.2
0142:  GOTO   1BF
0143:  BSF    03.5
0144:  MOVWF  20
0145:  MOVF   7B,W
0146:  BTFSS  03.2
0147:  GOTO   14A
0148:  BCF    03.5
0149:  GOTO   1BF
014A:  ADDWF  20,F
014B:  BTFSC  03.0
014C:  GOTO   158
014D:  MOVLW  7F
014E:  SUBWF  20,F
014F:  BTFSC  03.0
0150:  GOTO   153
0151:  BCF    03.5
0152:  GOTO   1BF
0153:  BTFSS  03.2
0154:  GOTO   157
0155:  BCF    03.5
0156:  GOTO   1BF
0157:  GOTO   15E
0158:  MOVLW  81
0159:  ADDWF  20,F
015A:  BTFSS  03.0
015B:  GOTO   15E
015C:  BCF    03.5
015D:  GOTO   1BF
015E:  MOVF   20,W
015F:  MOVWF  77
0160:  CLRF   78
0161:  CLRF   79
0162:  CLRF   7A
0163:  MOVF   71,W
0164:  MOVWF  24
0165:  BSF    24.7
0166:  MOVF   72,W
0167:  MOVWF  23
0168:  MOVF   73,W
0169:  MOVWF  22
016A:  MOVLW  18
016B:  MOVWF  20
016C:  CLRF   21
016D:  BTFSS  22.0
016E:  GOTO   187
016F:  MOVF   7E,W
0170:  ADDWF  7A,F
0171:  BTFSS  03.0
0172:  GOTO   179
0173:  INCF   79,F
0174:  BTFSS  03.2
0175:  GOTO   179
0176:  INCF   78,F
0177:  BTFSC  03.2
0178:  BSF    21.7
0179:  MOVF   7D,W
017A:  ADDWF  79,F
017B:  BTFSS  03.0
017C:  GOTO   180
017D:  INCF   78,F
017E:  BTFSC  03.2
017F:  BSF    21.7
0180:  MOVF   7C,W
0181:  MOVWF  72
0182:  BSF    72.7
0183:  MOVF   72,W
0184:  ADDWF  78,F
0185:  BTFSC  03.0
0186:  BSF    21.7
0187:  RLF    21,F
0188:  RRF    78,F
0189:  RRF    79,F
018A:  RRF    7A,F
018B:  RRF    24,F
018C:  RRF    23,F
018D:  RRF    22,F
018E:  BCF    03.0
018F:  DECFSZ 20,F
0190:  GOTO   16C
0191:  MOVLW  01
0192:  ADDWF  77,F
0193:  BTFSS  03.0
0194:  GOTO   197
0195:  BCF    03.5
0196:  GOTO   1BF
0197:  BTFSC  78.7
0198:  GOTO   1A1
0199:  RLF    24,F
019A:  RLF    7A,F
019B:  RLF    79,F
019C:  RLF    78,F
019D:  DECFSZ 77,F
019E:  GOTO   1A1
019F:  BCF    03.5
01A0:  GOTO   1BF
01A1:  BTFSS  24.7
01A2:  GOTO   1B4
01A3:  INCF   7A,F
01A4:  BTFSS  03.2
01A5:  GOTO   1B4
01A6:  INCF   79,F
01A7:  BTFSS  03.2
01A8:  GOTO   1B4
01A9:  INCF   78,F
01AA:  BTFSS  03.2
01AB:  GOTO   1B4
01AC:  RRF    78,F
01AD:  RRF    79,F
01AE:  RRF    7A,F
01AF:  INCF   77,F
01B0:  BTFSS  03.2
01B1:  GOTO   1B4
01B2:  BCF    03.5
01B3:  GOTO   1BF
01B4:  MOVF   71,W
01B5:  MOVWF  21
01B6:  MOVF   7C,W
01B7:  XORWF  21,F
01B8:  BTFSS  21.7
01B9:  GOTO   1BC
01BA:  BSF    78.7
01BB:  GOTO   1C4
01BC:  BCF    78.7
01BD:  GOTO   1C4
01BE:  BCF    03.5
01BF:  CLRF   77
01C0:  CLRF   78
01C1:  CLRF   79
01C2:  CLRF   7A
01C3:  BSF    03.5
01C4:  BCF    03.5
01C5:  RETURN
01C6:  MOVF   67,W
01C7:  BTFSC  03.2
01C8:  GOTO   28B
01C9:  MOVWF  73
01CA:  MOVF   6B,W
01CB:  BTFSC  03.2
01CC:  GOTO   28B
01CD:  SUBWF  73,F
01CE:  BTFSS  03.0
01CF:  GOTO   1D5
01D0:  MOVLW  7F
01D1:  ADDWF  73,F
01D2:  BTFSC  03.0
01D3:  GOTO   28B
01D4:  GOTO   1DB
01D5:  MOVLW  81
01D6:  SUBWF  73,F
01D7:  BTFSS  03.0
01D8:  GOTO   28B
01D9:  BTFSC  03.2
01DA:  GOTO   28B
01DB:  MOVF   73,W
01DC:  MOVWF  77
01DD:  CLRF   78
01DE:  CLRF   79
01DF:  CLRF   7A
01E0:  CLRF   72
01E1:  MOVF   68,W
01E2:  MOVWF  71
01E3:  BSF    71.7
01E4:  MOVF   69,W
01E5:  MOVWF  70
01E6:  MOVF   6A,W
01E7:  MOVWF  6F
01E8:  MOVLW  19
01E9:  MOVWF  73
01EA:  MOVF   6E,W
01EB:  SUBWF  6F,F
01EC:  BTFSC  03.0
01ED:  GOTO   1FE
01EE:  MOVLW  01
01EF:  SUBWF  70,F
01F0:  BTFSC  03.0
01F1:  GOTO   1FE
01F2:  SUBWF  71,F
01F3:  BTFSC  03.0
01F4:  GOTO   1FE
01F5:  SUBWF  72,F
01F6:  BTFSC  03.0
01F7:  GOTO   1FE
01F8:  INCF   72,F
01F9:  INCF   71,F
01FA:  INCF   70,F
01FB:  MOVF   6E,W
01FC:  ADDWF  6F,F
01FD:  GOTO   230
01FE:  MOVF   6D,W
01FF:  SUBWF  70,F
0200:  BTFSC  03.0
0201:  GOTO   219
0202:  MOVLW  01
0203:  SUBWF  71,F
0204:  BTFSC  03.0
0205:  GOTO   219
0206:  SUBWF  72,F
0207:  BTFSC  03.0
0208:  GOTO   219
0209:  INCF   72,F
020A:  INCF   71,F
020B:  MOVF   6D,W
020C:  ADDWF  70,F
020D:  MOVF   6E,W
020E:  ADDWF  6F,F
020F:  BTFSS  03.0
0210:  GOTO   230
0211:  INCF   70,F
0212:  BTFSS  03.2
0213:  GOTO   230
0214:  INCF   71,F
0215:  BTFSS  03.2
0216:  GOTO   230
0217:  INCF   72,F
0218:  GOTO   230
0219:  MOVF   6C,W
021A:  IORLW  80
021B:  SUBWF  71,F
021C:  BTFSC  03.0
021D:  GOTO   22F
021E:  MOVLW  01
021F:  SUBWF  72,F
0220:  BTFSC  03.0
0221:  GOTO   22F
0222:  INCF   72,F
0223:  MOVF   6C,W
0224:  IORLW  80
0225:  ADDWF  71,F
0226:  MOVF   6D,W
0227:  ADDWF  70,F
0228:  BTFSS  03.0
0229:  GOTO   20D
022A:  INCF   71,F
022B:  BTFSS  03.2
022C:  GOTO   20D
022D:  INCF   72,F
022E:  GOTO   20D
022F:  BSF    7A.0
0230:  DECFSZ 73,F
0231:  GOTO   233
0232:  GOTO   23E
0233:  BCF    03.0
0234:  RLF    6F,F
0235:  RLF    70,F
0236:  RLF    71,F
0237:  RLF    72,F
0238:  BCF    03.0
0239:  RLF    7A,F
023A:  RLF    79,F
023B:  RLF    78,F
023C:  RLF    74,F
023D:  GOTO   1EA
023E:  BTFSS  74.0
023F:  GOTO   246
0240:  BCF    03.0
0241:  RRF    78,F
0242:  RRF    79,F
0243:  RRF    7A,F
0244:  RRF    74,F
0245:  GOTO   249
0246:  DECF   77,F
0247:  BTFSC  03.2
0248:  GOTO   28B
0249:  BTFSC  74.7
024A:  GOTO   272
024B:  BCF    03.0
024C:  RLF    6F,F
024D:  RLF    70,F
024E:  RLF    71,F
024F:  RLF    72,F
0250:  MOVF   6E,W
0251:  SUBWF  6F,F
0252:  BTFSC  03.0
0253:  GOTO   25E
0254:  MOVLW  01
0255:  SUBWF  70,F
0256:  BTFSC  03.0
0257:  GOTO   25E
0258:  SUBWF  71,F
0259:  BTFSC  03.0
025A:  GOTO   25E
025B:  SUBWF  72,F
025C:  BTFSS  03.0
025D:  GOTO   281
025E:  MOVF   6D,W
025F:  SUBWF  70,F
0260:  BTFSC  03.0
0261:  GOTO   269
0262:  MOVLW  01
0263:  SUBWF  71,F
0264:  BTFSC  03.0
0265:  GOTO   269
0266:  SUBWF  72,F
0267:  BTFSS  03.0
0268:  GOTO   281
0269:  MOVF   6C,W
026A:  IORLW  80
026B:  SUBWF  71,F
026C:  BTFSC  03.0
026D:  GOTO   272
026E:  MOVLW  01
026F:  SUBWF  72,F
0270:  BTFSS  03.0
0271:  GOTO   281
0272:  INCF   7A,F
0273:  BTFSS  03.2
0274:  GOTO   281
0275:  INCF   79,F
0276:  BTFSS  03.2
0277:  GOTO   281
0278:  INCF   78,F
0279:  BTFSS  03.2
027A:  GOTO   281
027B:  INCF   77,F
027C:  BTFSC  03.2
027D:  GOTO   28B
027E:  RRF    78,F
027F:  RRF    79,F
0280:  RRF    7A,F
0281:  MOVF   68,W
0282:  MOVWF  73
0283:  MOVF   6C,W
0284:  XORWF  73,F
0285:  BTFSS  73.7
0286:  GOTO   289
0287:  BSF    78.7
0288:  GOTO   28F
0289:  BCF    78.7
028A:  GOTO   28F
028B:  CLRF   77
028C:  CLRF   78
028D:  CLRF   79
028E:  CLRF   7A
028F:  RETURN
0290:  MOVLW  80
0291:  BTFSC  03.1
0292:  XORWF  6C,F
0293:  CLRF   71
0294:  CLRF   72
0295:  MOVF   68,W
0296:  MOVWF  70
0297:  MOVF   6C,W
0298:  XORWF  70,F
0299:  MOVF   67,W
029A:  BTFSC  03.2
029B:  GOTO   380
029C:  MOVWF  6F
029D:  MOVWF  77
029E:  MOVF   6B,W
029F:  BTFSC  03.2
02A0:  GOTO   389
02A1:  SUBWF  6F,F
02A2:  BTFSC  03.2
02A3:  GOTO   325
02A4:  BTFSS  03.0
02A5:  GOTO   2E3
02A6:  MOVF   6C,W
02A7:  MOVWF  75
02A8:  BSF    75.7
02A9:  MOVF   6D,W
02AA:  MOVWF  74
02AB:  MOVF   6E,W
02AC:  MOVWF  73
02AD:  CLRF   72
02AE:  BCF    03.0
02AF:  RRF    75,F
02B0:  RRF    74,F
02B1:  RRF    73,F
02B2:  RRF    72,F
02B3:  DECFSZ 6F,F
02B4:  GOTO   2AD
02B5:  BTFSS  70.7
02B6:  GOTO   2BA
02B7:  BSF    71.0
02B8:  GOTO   39D
02B9:  BCF    71.0
02BA:  BCF    6F.0
02BB:  BSF    71.4
02BC:  MOVLW  6A
02BD:  MOVWF  04
02BE:  BCF    03.7
02BF:  GOTO   3B2
02C0:  BCF    71.4
02C1:  BTFSC  70.7
02C2:  GOTO   2CD
02C3:  BTFSS  6F.0
02C4:  GOTO   2D8
02C5:  RRF    75,F
02C6:  RRF    74,F
02C7:  RRF    73,F
02C8:  RRF    72,F
02C9:  INCF   77,F
02CA:  BTFSC  03.2
02CB:  GOTO   398
02CC:  GOTO   2D8
02CD:  BTFSC  75.7
02CE:  GOTO   2DB
02CF:  BCF    03.0
02D0:  RLF    72,F
02D1:  RLF    73,F
02D2:  RLF    74,F
02D3:  RLF    75,F
02D4:  DECF   77,F
02D5:  BTFSC  03.2
02D6:  GOTO   398
02D7:  GOTO   2CD
02D8:  BSF    71.6
02D9:  GOTO   345
02DA:  BCF    71.6
02DB:  MOVF   68,W
02DC:  MOVWF  70
02DD:  BTFSS  70.7
02DE:  GOTO   2E1
02DF:  BSF    75.7
02E0:  GOTO   391
02E1:  BCF    75.7
02E2:  GOTO   391
02E3:  MOVF   6B,W
02E4:  MOVWF  6F
02E5:  MOVWF  77
02E6:  MOVF   67,W
02E7:  SUBWF  6F,F
02E8:  MOVF   68,W
02E9:  MOVWF  75
02EA:  BSF    75.7
02EB:  MOVF   69,W
02EC:  MOVWF  74
02ED:  MOVF   6A,W
02EE:  MOVWF  73
02EF:  CLRF   72
02F0:  BCF    03.0
02F1:  RRF    75,F
02F2:  RRF    74,F
02F3:  RRF    73,F
02F4:  RRF    72,F
02F5:  DECFSZ 6F,F
02F6:  GOTO   2EF
02F7:  BTFSS  70.7
02F8:  GOTO   2FC
02F9:  BSF    71.1
02FA:  GOTO   39D
02FB:  BCF    71.1
02FC:  BCF    6F.0
02FD:  BSF    71.5
02FE:  MOVLW  6E
02FF:  MOVWF  04
0300:  BCF    03.7
0301:  GOTO   3B2
0302:  BCF    71.5
0303:  BTFSC  70.7
0304:  GOTO   30F
0305:  BTFSS  6F.0
0306:  GOTO   31A
0307:  RRF    75,F
0308:  RRF    74,F
0309:  RRF    73,F
030A:  RRF    72,F
030B:  INCF   77,F
030C:  BTFSC  03.2
030D:  GOTO   398
030E:  GOTO   31A
030F:  BTFSC  75.7
0310:  GOTO   31D
0311:  BCF    03.0
0312:  RLF    72,F
0313:  RLF    73,F
0314:  RLF    74,F
0315:  RLF    75,F
0316:  DECF   77,F
0317:  BTFSC  03.2
0318:  GOTO   398
0319:  GOTO   30F
031A:  BSF    71.7
031B:  GOTO   345
031C:  BCF    71.7
031D:  MOVF   6C,W
031E:  MOVWF  70
031F:  BTFSS  70.7
0320:  GOTO   323
0321:  BSF    75.7
0322:  GOTO   391
0323:  BCF    75.7
0324:  GOTO   391
0325:  MOVF   6C,W
0326:  MOVWF  75
0327:  BSF    75.7
0328:  MOVF   6D,W
0329:  MOVWF  74
032A:  MOVF   6E,W
032B:  MOVWF  73
032C:  BTFSS  70.7
032D:  GOTO   332
032E:  BCF    75.7
032F:  BSF    71.2
0330:  GOTO   39D
0331:  BCF    71.2
0332:  CLRF   72
0333:  BCF    6F.0
0334:  MOVLW  6A
0335:  MOVWF  04
0336:  BCF    03.7
0337:  GOTO   3B2
0338:  BTFSC  70.7
0339:  GOTO   35B
033A:  MOVF   68,W
033B:  MOVWF  70
033C:  BTFSS  6F.0
033D:  GOTO   345
033E:  RRF    75,F
033F:  RRF    74,F
0340:  RRF    73,F
0341:  RRF    72,F
0342:  INCF   77,F
0343:  BTFSC  03.2
0344:  GOTO   398
0345:  BTFSS  72.7
0346:  GOTO   356
0347:  INCF   73,F
0348:  BTFSS  03.2
0349:  GOTO   356
034A:  INCF   74,F
034B:  BTFSS  03.2
034C:  GOTO   356
034D:  INCF   75,F
034E:  BTFSS  03.2
034F:  GOTO   356
0350:  RRF    75,F
0351:  RRF    74,F
0352:  RRF    73,F
0353:  INCF   77,F
0354:  BTFSC  03.2
0355:  GOTO   398
0356:  BTFSC  71.6
0357:  GOTO   2DA
0358:  BTFSC  71.7
0359:  GOTO   31C
035A:  GOTO   37A
035B:  MOVLW  80
035C:  XORWF  75,F
035D:  BTFSS  75.7
035E:  GOTO   363
035F:  GOTO   39D
0360:  MOVF   6C,W
0361:  MOVWF  70
0362:  GOTO   370
0363:  MOVF   68,W
0364:  MOVWF  70
0365:  MOVF   75,F
0366:  BTFSS  03.2
0367:  GOTO   370
0368:  MOVF   74,F
0369:  BTFSS  03.2
036A:  GOTO   370
036B:  MOVF   73,F
036C:  BTFSS  03.2
036D:  GOTO   370
036E:  CLRF   77
036F:  GOTO   391
0370:  BTFSC  75.7
0371:  GOTO   37A
0372:  BCF    03.0
0373:  RLF    72,F
0374:  RLF    73,F
0375:  RLF    74,F
0376:  RLF    75,F
0377:  DECFSZ 77,F
0378:  GOTO   370
0379:  GOTO   398
037A:  BTFSS  70.7
037B:  GOTO   37E
037C:  BSF    75.7
037D:  GOTO   391
037E:  BCF    75.7
037F:  GOTO   391
0380:  MOVF   6B,W
0381:  MOVWF  77
0382:  MOVF   6C,W
0383:  MOVWF  75
0384:  MOVF   6D,W
0385:  MOVWF  74
0386:  MOVF   6E,W
0387:  MOVWF  73
0388:  GOTO   391
0389:  MOVF   67,W
038A:  MOVWF  77
038B:  MOVF   68,W
038C:  MOVWF  75
038D:  MOVF   69,W
038E:  MOVWF  74
038F:  MOVF   6A,W
0390:  MOVWF  73
0391:  MOVF   75,W
0392:  MOVWF  78
0393:  MOVF   74,W
0394:  MOVWF  79
0395:  MOVF   73,W
0396:  MOVWF  7A
0397:  GOTO   3D0
0398:  CLRF   77
0399:  CLRF   78
039A:  CLRF   79
039B:  CLRF   7A
039C:  GOTO   3D0
039D:  CLRF   72
039E:  COMF   73,F
039F:  COMF   74,F
03A0:  COMF   75,F
03A1:  COMF   72,F
03A2:  INCF   72,F
03A3:  BTFSS  03.2
03A4:  GOTO   3AB
03A5:  INCF   73,F
03A6:  BTFSS  03.2
03A7:  GOTO   3AB
03A8:  INCF   74,F
03A9:  BTFSC  03.2
03AA:  INCF   75,F
03AB:  BTFSC  71.0
03AC:  GOTO   2B9
03AD:  BTFSC  71.1
03AE:  GOTO   2FB
03AF:  BTFSC  71.2
03B0:  GOTO   331
03B1:  GOTO   360
03B2:  MOVF   00,W
03B3:  ADDWF  73,F
03B4:  BTFSS  03.0
03B5:  GOTO   3BC
03B6:  INCF   74,F
03B7:  BTFSS  03.2
03B8:  GOTO   3BC
03B9:  INCF   75,F
03BA:  BTFSC  03.2
03BB:  BSF    6F.0
03BC:  DECF   04,F
03BD:  MOVF   00,W
03BE:  ADDWF  74,F
03BF:  BTFSS  03.0
03C0:  GOTO   3C4
03C1:  INCF   75,F
03C2:  BTFSC  03.2
03C3:  BSF    6F.0
03C4:  DECF   04,F
03C5:  MOVF   00,W
03C6:  BTFSS  00.7
03C7:  XORLW  80
03C8:  ADDWF  75,F
03C9:  BTFSC  03.0
03CA:  BSF    6F.0
03CB:  BTFSC  71.4
03CC:  GOTO   2C0
03CD:  BTFSC  71.5
03CE:  GOTO   302
03CF:  GOTO   338
03D0:  RETURN
03D1:  MOVLW  8E
03D2:  MOVWF  77
03D3:  MOVF   63,W
03D4:  SUBWF  77,F
03D5:  MOVF   64,W
03D6:  MOVWF  79
03D7:  MOVF   65,W
03D8:  MOVWF  78
03D9:  BSF    79.7
03DA:  MOVF   77,F
03DB:  BTFSC  03.2
03DC:  GOTO   3E8
03DD:  BCF    03.0
03DE:  MOVF   79,F
03DF:  BTFSS  03.2
03E0:  GOTO   3E4
03E1:  MOVF   78,F
03E2:  BTFSC  03.2
03E3:  GOTO   3E8
03E4:  RRF    79,F
03E5:  RRF    78,F
03E6:  DECFSZ 77,F
03E7:  GOTO   3DD
03E8:  BTFSS  64.7
03E9:  GOTO   3EF
03EA:  COMF   78,F
03EB:  COMF   79,F
03EC:  INCF   78,F
03ED:  BTFSC  03.2
03EE:  INCF   79,F
03EF:  BSF    0A.3
03F0:  BCF    0A.4
03F1:  GOTO   251 (RETURN)
*
0409:  MOVF   0B,W
040A:  MOVWF  64
040B:  BCF    0B.7
040C:  BSF    03.5
040D:  BSF    03.6
040E:  BSF    0C.7
040F:  BSF    0C.0
0410:  NOP
0411:  NOP
0412:  BCF    03.5
0413:  BCF    03.6
0414:  BTFSC  64.7
0415:  BSF    0B.7
0416:  BTFSC  03.0
0417:  GOTO   440
0418:  BSF    03.6
0419:  MOVF   0C,W
041A:  ANDLW  7F
041B:  BCF    03.6
041C:  MOVWF  64
041D:  BSF    03.6
041E:  MOVF   0D,W
041F:  BCF    03.6
0420:  MOVWF  65
0421:  BSF    03.6
0422:  MOVF   0F,W
0423:  BCF    03.6
0424:  MOVWF  66
0425:  MOVF   64,W
0426:  MOVWF  70
0427:  CALL   09E
0428:  MOVF   65,W
0429:  BSF    03.6
042A:  MOVWF  0D
042B:  BCF    03.6
042C:  MOVF   66,W
042D:  BSF    03.6
042E:  MOVWF  0F
042F:  BCF    03.6
0430:  MOVF   0B,W
0431:  MOVWF  67
0432:  BCF    0B.7
0433:  BSF    03.5
0434:  BSF    03.6
0435:  BSF    0C.7
0436:  BSF    0C.0
0437:  NOP
0438:  NOP
0439:  BCF    03.5
043A:  BCF    03.6
043B:  BTFSC  67.7
043C:  BSF    0B.7
043D:  DECFSZ 63,F
043E:  GOTO   440
043F:  GOTO   45F
0440:  BSF    03.6
0441:  RLF    0C,W
0442:  RLF    0E,W
0443:  ANDLW  7F
0444:  BCF    03.6
0445:  MOVWF  64
0446:  BSF    03.6
0447:  MOVF   0D,W
0448:  BCF    03.6
0449:  MOVWF  65
044A:  BSF    03.6
044B:  MOVF   0F,W
044C:  BCF    03.6
044D:  MOVWF  66
044E:  MOVF   64,W
044F:  MOVWF  70
0450:  CALL   09E
0451:  MOVF   65,W
0452:  BSF    03.6
0453:  MOVWF  0D
0454:  BCF    03.6
0455:  MOVF   66,W
0456:  BSF    03.6
0457:  MOVWF  0F
0458:  INCF   0D,F
0459:  BTFSC  03.2
045A:  INCF   0F,F
045B:  BCF    03.0
045C:  BCF    03.6
045D:  DECFSZ 63,F
045E:  GOTO   409
045F:  RETURN
0460:  BTFSC  03.1
0461:  GOTO   465
0462:  MOVLW  A0
0463:  MOVWF  04
0464:  BCF    03.7
0465:  CLRF   77
0466:  CLRF   78
0467:  CLRF   79
0468:  CLRF   7A
0469:  BSF    03.5
046A:  CLRF   20
046B:  CLRF   21
046C:  CLRF   22
046D:  CLRF   23
046E:  MOVF   7E,W
046F:  IORWF  7D,W
0470:  IORWF  7C,W
0471:  IORWF  7B,W
0472:  BTFSC  03.2
0473:  GOTO   4A4
0474:  MOVLW  20
0475:  MOVWF  24
0476:  BCF    03.0
0477:  RLF    70,F
0478:  RLF    71,F
0479:  RLF    72,F
047A:  RLF    73,F
047B:  RLF    20,F
047C:  RLF    21,F
047D:  RLF    22,F
047E:  RLF    23,F
047F:  MOVF   7E,W
0480:  SUBWF  23,W
0481:  BTFSS  03.2
0482:  GOTO   48D
0483:  MOVF   7D,W
0484:  SUBWF  22,W
0485:  BTFSS  03.2
0486:  GOTO   48D
0487:  MOVF   7C,W
0488:  SUBWF  21,W
0489:  BTFSS  03.2
048A:  GOTO   48D
048B:  MOVF   7B,W
048C:  SUBWF  20,W
048D:  BTFSS  03.0
048E:  GOTO   49E
048F:  MOVF   7B,W
0490:  SUBWF  20,F
0491:  MOVF   7C,W
0492:  BTFSS  03.0
0493:  INCFSZ 7C,W
0494:  SUBWF  21,F
0495:  MOVF   7D,W
0496:  BTFSS  03.0
0497:  INCFSZ 7D,W
0498:  SUBWF  22,F
0499:  MOVF   7E,W
049A:  BTFSS  03.0
049B:  INCFSZ 7E,W
049C:  SUBWF  23,F
049D:  BSF    03.0
049E:  RLF    77,F
049F:  RLF    78,F
04A0:  RLF    79,F
04A1:  RLF    7A,F
04A2:  DECFSZ 24,F
04A3:  GOTO   476
04A4:  MOVF   20,W
04A5:  MOVWF  00
04A6:  INCF   04,F
04A7:  MOVF   21,W
04A8:  MOVWF  00
04A9:  INCF   04,F
04AA:  MOVF   22,W
04AB:  MOVWF  00
04AC:  INCF   04,F
04AD:  MOVF   23,W
04AE:  MOVWF  00
04AF:  BCF    03.5
04B0:  RETURN
04B1:  MOVF   04,W
04B2:  MOVWF  68
04B3:  MOVF   67,W
04B4:  MOVWF  6A
04B5:  BTFSC  03.2
04B6:  GOTO   4D0
04B7:  MOVF   66,W
04B8:  MOVWF  73
04B9:  MOVF   65,W
04BA:  MOVWF  72
04BB:  MOVF   64,W
04BC:  MOVWF  71
04BD:  MOVF   63,W
04BE:  MOVWF  70
04BF:  CLRF   7E
04C0:  CLRF   7D
04C1:  MOVLW  20
04C2:  MOVWF  7C
04C3:  MOVLW  82
04C4:  MOVWF  7B
04C5:  CALL   140
04C6:  MOVF   7A,W
04C7:  MOVWF  66
04C8:  MOVF   79,W
04C9:  MOVWF  65
04CA:  MOVF   78,W
04CB:  MOVWF  64
04CC:  MOVF   77,W
04CD:  MOVWF  63
04CE:  DECFSZ 6A,F
04CF:  GOTO   4B7
04D0:  MOVF   66,W
04D1:  MOVWF  73
04D2:  MOVF   65,W
04D3:  MOVWF  72
04D4:  MOVF   64,W
04D5:  MOVWF  71
04D6:  MOVF   63,W
04D7:  MOVWF  70
04D8:  MOVF   70,W
04D9:  SUBLW  B6
04DA:  MOVWF  70
04DB:  CLRF   7A
04DC:  MOVF   71,W
04DD:  MOVWF  74
04DE:  BSF    71.7
04DF:  BCF    03.0
04E0:  RRF    71,F
04E1:  RRF    72,F
04E2:  RRF    73,F
04E3:  RRF    7A,F
04E4:  RRF    79,F
04E5:  RRF    78,F
04E6:  RRF    77,F
04E7:  DECFSZ 70,F
04E8:  GOTO   4DF
04E9:  BTFSS  74.7
04EA:  GOTO   4F6
04EB:  COMF   77,F
04EC:  COMF   78,F
04ED:  COMF   79,F
04EE:  COMF   7A,F
04EF:  INCF   77,F
04F0:  BTFSC  03.2
04F1:  INCF   78,F
04F2:  BTFSC  03.2
04F3:  INCF   79,F
04F4:  BTFSC  03.2
04F5:  INCF   7A,F
04F6:  MOVF   7A,W
04F7:  MOVWF  66
04F8:  MOVF   79,W
04F9:  MOVWF  65
04FA:  MOVF   78,W
04FB:  MOVWF  64
04FC:  MOVF   77,W
04FD:  MOVWF  63
04FE:  BTFSS  66.7
04FF:  GOTO   50D
0500:  DECF   68,F
0501:  BSF    68.5
0502:  COMF   63,F
0503:  COMF   64,F
0504:  COMF   65,F
0505:  COMF   66,F
0506:  INCF   63,F
0507:  BTFSC  03.2
0508:  INCF   64,F
0509:  BTFSC  03.2
050A:  INCF   65,F
050B:  BTFSC  03.2
050C:  INCF   66,F
050D:  MOVLW  3B
050E:  MOVWF  6F
050F:  MOVLW  9A
0510:  MOVWF  6E
0511:  MOVLW  CA
0512:  MOVWF  6D
0513:  CLRF   6C
0514:  MOVLW  0A
0515:  MOVWF  6A
0516:  MOVF   67,W
0517:  BTFSC  03.2
0518:  INCF   68,F
0519:  BSF    03.1
051A:  MOVLW  63
051B:  MOVWF  04
051C:  BCF    03.7
051D:  MOVF   66,W
051E:  MOVWF  73
051F:  MOVF   65,W
0520:  MOVWF  72
0521:  MOVF   64,W
0522:  MOVWF  71
0523:  MOVF   63,W
0524:  MOVWF  70
0525:  MOVF   6F,W
0526:  MOVWF  7E
0527:  MOVF   6E,W
0528:  MOVWF  7D
0529:  MOVF   6D,W
052A:  MOVWF  7C
052B:  MOVF   6C,W
052C:  MOVWF  7B
052D:  CALL   460
052E:  MOVF   78,W
052F:  MOVF   77,F
0530:  BTFSS  03.2
0531:  GOTO   545
0532:  INCF   67,W
0533:  SUBWF  6A,W
0534:  BTFSC  03.2
0535:  GOTO   545
0536:  MOVF   68,W
0537:  BTFSC  03.2
0538:  GOTO   547
0539:  ANDLW  0F
053A:  SUBWF  6A,W
053B:  BTFSC  03.2
053C:  GOTO   53F
053D:  BTFSC  03.0
053E:  GOTO   577
053F:  BTFSC  68.7
0540:  GOTO   577
0541:  BTFSC  68.6
0542:  GOTO   547
0543:  MOVLW  20
0544:  GOTO   573
0545:  MOVLW  20
0546:  ANDWF  68,F
0547:  BTFSS  68.5
0548:  GOTO   555
0549:  BCF    68.5
054A:  MOVF   67,W
054B:  BTFSS  03.2
054C:  DECF   68,F
054D:  MOVF   77,W
054E:  MOVWF  68
054F:  MOVLW  2D
0550:  MOVWF  70
0551:  CALL   09E
0552:  MOVF   68,W
0553:  MOVWF  77
0554:  CLRF   68
0555:  MOVF   67,W
0556:  SUBWF  6A,W
0557:  BTFSS  03.2
0558:  GOTO   563
0559:  MOVF   77,W
055A:  MOVWF  68
055B:  MOVLW  2E
055C:  MOVWF  70
055D:  CALL   09E
055E:  MOVF   68,W
055F:  MOVWF  77
0560:  MOVLW  20
0561:  ANDWF  68,F
0562:  MOVLW  00
0563:  MOVLW  30
0564:  BTFSS  68.5
0565:  GOTO   573
0566:  BCF    68.5
0567:  MOVF   67,W
0568:  BTFSS  03.2
0569:  DECF   68,F
056A:  MOVF   77,W
056B:  MOVWF  68
056C:  MOVLW  2D
056D:  MOVWF  70
056E:  CALL   09E
056F:  MOVF   68,W
0570:  MOVWF  77
0571:  CLRF   68
0572:  MOVLW  30
0573:  ADDWF  77,F
0574:  MOVF   77,W
0575:  MOVWF  70
0576:  CALL   09E
0577:  BCF    03.1
0578:  MOVF   6F,W
0579:  MOVWF  73
057A:  MOVF   6E,W
057B:  MOVWF  72
057C:  MOVF   6D,W
057D:  MOVWF  71
057E:  MOVF   6C,W
057F:  MOVWF  70
0580:  CLRF   7E
0581:  CLRF   7D
0582:  CLRF   7C
0583:  MOVLW  0A
0584:  MOVWF  7B
0585:  CALL   460
0586:  MOVF   7A,W
0587:  MOVWF  6F
0588:  MOVF   79,W
0589:  MOVWF  6E
058A:  MOVF   78,W
058B:  MOVWF  6D
058C:  MOVF   77,W
058D:  MOVWF  6C
058E:  DECFSZ 6A,F
058F:  GOTO   519
0590:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HS,BROWNOUT,NOWDT 
.................... #use delay(clock=20M) 
*
0057:  MOVLW  66
0058:  MOVWF  04
0059:  BCF    03.7
005A:  MOVF   00,W
005B:  BTFSC  03.2
005C:  GOTO   06A
005D:  MOVLW  06
005E:  MOVWF  78
005F:  CLRF   77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  DECFSZ 78,F
0063:  GOTO   05F
0064:  MOVLW  7B
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 00,F
0069:  GOTO   05D
006A:  RETURN
.................... #endif 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0809:  BCF    03.5
080A:  CLRF   20
080B:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define lcd_rs pin_d0 
.................... #define lcd_en pin_d1 
.................... #define sw pin_d2 
....................  
.................... #define disp_clear 0b00000001 
.................... #define disp_control 0b00001110 
.................... #define func_set 0b00111000 
.................... #define lscrol 0b00011000 
.................... #define rscrol 0b00011100 
.................... #define line1 0b10000000 
.................... #define line2 0b11000000 
....................  
.................... float adc_value,adc_value1,adc_value2; 
.................... float vout,v1,v2,Rldr; 
.................... float voltmeter1,voltmeter2; 
.................... float ammeter1,ammeter2; 
.................... float temperature,LUX; 
.................... float Pin,Pout; 
....................  
.................... void lcd_init (void); 
.................... void lcd_data (unsigned char); 
.................... void lcd_cmd (unsigned char); 
.................... void lcd_lscrol (unsigned char); 
.................... void lcd_rscrol (unsigned char); 
.................... void lcd_line1 (unsigned char); 
.................... void lcd_line2 (unsigned char); 
.................... void relay (unsigned char); 
....................  
.................... void lcd_init (void) 
.................... { 
.................... delay_ms(300); 
*
0082:  MOVLW  02
0083:  MOVWF  63
0084:  MOVLW  96
0085:  MOVWF  66
0086:  CALL   057
0087:  DECFSZ 63,F
0088:  GOTO   084
.................... lcd_cmd (func_set); 
0089:  MOVLW  38
008A:  MOVWF  65
008B:  CALL   06B
.................... lcd_cmd (disp_control); 
008C:  MOVLW  0E
008D:  MOVWF  65
008E:  CALL   06B
.................... lcd_cmd(disp_clear); 
008F:  MOVLW  01
0090:  MOVWF  65
0091:  CALL   06B
....................  delay_ms(50); 
0092:  MOVLW  32
0093:  MOVWF  66
0094:  CALL   057
0095:  BSF    0A.3
0096:  BCF    0A.4
0097:  GOTO   00E (RETURN)
.................... } 
....................  
.................... void lcd_cmd (unsigned char i) 
.................... { 
.................... output_low(lcd_rs); 
*
006B:  BSF    03.5
006C:  BCF    08.0
006D:  BCF    03.5
006E:  BCF    08.0
.................... output_b(i); 
006F:  BSF    03.5
0070:  CLRF   06
0071:  BCF    03.5
0072:  MOVF   65,W
0073:  MOVWF  06
.................... output_high(lcd_en); 
0074:  BSF    03.5
0075:  BCF    08.1
0076:  BCF    03.5
0077:  BSF    08.1
.................... delay_us(100); 
0078:  MOVLW  A6
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  NOP
.................... output_low(lcd_en); 
007D:  BSF    03.5
007E:  BCF    08.1
007F:  BCF    03.5
0080:  BCF    08.1
0081:  RETURN
.................... } 
....................  
.................... void lcd_data (unsigned char i) 
.................... { 
.................... output_high(lcd_rs); 
*
009E:  BSF    03.5
009F:  BCF    08.0
00A0:  BCF    03.5
00A1:  BSF    08.0
.................... output_b(i); 
00A2:  BSF    03.5
00A3:  CLRF   06
00A4:  MOVF   70,W
00A5:  BCF    03.5
00A6:  MOVWF  06
.................... output_high(lcd_en); 
00A7:  BSF    03.5
00A8:  BCF    08.1
00A9:  BCF    03.5
00AA:  BSF    08.1
.................... delay_us(100); 
00AB:  MOVLW  A6
00AC:  MOVWF  77
00AD:  DECFSZ 77,F
00AE:  GOTO   0AD
00AF:  NOP
.................... output_low(lcd_en); 
00B0:  BSF    03.5
00B1:  BCF    08.1
00B2:  BCF    03.5
00B3:  BCF    08.1
00B4:  RETURN
.................... } 
....................  
.................... void lcd_lscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
.................... { 
.................... lcd_cmd(lscrol); 
.................... delay_ms(300); 
.................... } 
.................... } 
....................  
.................... void lcd_rscrol (unsigned char i) 
.................... { 
.................... unsigned int8 count; 
.................... for(count=0;count<i;count++) 
*
0111:  CLRF   64
0112:  MOVF   63,W
0113:  SUBWF  64,W
0114:  BTFSC  03.0
0115:  GOTO   122
.................... { 
.................... lcd_cmd(rscrol); 
0116:  MOVLW  1C
0117:  MOVWF  65
0118:  CALL   06B
.................... delay_ms(300); 
0119:  MOVLW  02
011A:  MOVWF  65
011B:  MOVLW  96
011C:  MOVWF  66
011D:  CALL   057
011E:  DECFSZ 65,F
011F:  GOTO   11B
0120:  INCF   64,F
0121:  GOTO   112
.................... } 
0122:  RETURN
.................... } 
....................  
.................... void lcd_line1 (unsigned char position) 
.................... { 
.................... lcd_cmd(line1 + position); 
*
0098:  MOVLW  80
0099:  ADDWF  63,W
009A:  MOVWF  64
009B:  MOVWF  65
009C:  CALL   06B
009D:  RETURN
.................... } 
....................  
.................... void lcd_line2 (unsigned char position) 
.................... { 
.................... lcd_cmd(line2 + position); 
*
010B:  MOVLW  C0
010C:  ADDWF  63,W
010D:  MOVWF  64
010E:  MOVWF  65
010F:  CALL   06B
0110:  RETURN
.................... } 
....................  
.................... void relay (unsigned char threshold) 
.................... { 
.................... set_tris_b(0x00); 
*
03F2:  MOVLW  00
03F3:  BSF    03.5
03F4:  MOVWF  06
....................  
.................... if(threshold<=2) 
03F5:  BCF    03.5
03F6:  MOVF   64,W
03F7:  SUBLW  02
03F8:  BTFSS  03.0
03F9:  GOTO   402
.................... { 
.................... output_high(sw); 
03FA:  BSF    03.5
03FB:  BCF    08.2
03FC:  BCF    03.5
03FD:  BSF    08.2
.................... delay_ms(100); 
03FE:  MOVLW  64
03FF:  MOVWF  66
0400:  CALL   057
.................... } 
0401:  GOTO   406
.................... else 
.................... { 
.................... output_low(sw); 
0402:  BSF    03.5
0403:  BCF    08.2
0404:  BCF    03.5
0405:  BCF    08.2
.................... } 
0406:  BSF    0A.3
0407:  BCF    0A.4
0408:  GOTO   257 (RETURN)
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    1F.0
0805:  BSF    1F.1
0806:  BSF    1F.2
0807:  BCF    1F.3
0808:  BCF    03.7
.................... { 
....................  
.................... lcd_init(); 
*
080C:  BCF    0A.3
080D:  GOTO   082
080E:  BSF    0A.3
....................  
.................... SETUP_ADC_PORTS(ALL_ANALOG); 
080F:  BSF    03.5
0810:  BCF    1F.0
0811:  BCF    1F.1
0812:  BCF    1F.2
0813:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_DIV_2); 
0814:  BCF    03.5
0815:  BCF    1F.6
0816:  BCF    1F.7
0817:  BSF    03.5
0818:  BSF    1F.7
0819:  BCF    03.5
081A:  BSF    1F.0
....................  
.................... int i=0; 
081B:  CLRF   62
....................  
.................... do 
.................... { 
.................... lcd_line1 (3); 
081C:  MOVLW  03
081D:  MOVWF  63
081E:  BCF    0A.3
081F:  CALL   098
0820:  BSF    0A.3
.................... lcd_data ("Made by:"); 
0821:  MOVLW  04
0822:  BSF    03.6
0823:  MOVWF  0D
0824:  MOVLW  00
0825:  MOVWF  0F
0826:  BCF    0A.3
0827:  BCF    03.6
0828:  CALL   0B5
0829:  BSF    0A.3
.................... lcd_line2 (0); 
082A:  CLRF   63
082B:  BCF    0A.3
082C:  CALL   10B
082D:  BSF    0A.3
.................... lcd_data ("Faizan,Shakir"); 
082E:  MOVLW  09
082F:  BSF    03.6
0830:  MOVWF  0D
0831:  MOVLW  00
0832:  MOVWF  0F
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   0B5
0836:  BSF    0A.3
.................... delay_ms(1000); 
0837:  MOVLW  04
0838:  MOVWF  63
0839:  MOVLW  FA
083A:  MOVWF  66
083B:  BCF    0A.3
083C:  CALL   057
083D:  BSF    0A.3
083E:  DECFSZ 63,F
083F:  GOTO   039
.................... lcd_rscrol(20); 
0840:  MOVLW  14
0841:  MOVWF  63
0842:  BCF    0A.3
0843:  CALL   111
0844:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0845:  MOVLW  01
0846:  MOVWF  65
0847:  BCF    0A.3
0848:  CALL   06B
0849:  BSF    0A.3
....................  delay_ms(50); 
084A:  MOVLW  32
084B:  MOVWF  66
084C:  BCF    0A.3
084D:  CALL   057
084E:  BSF    0A.3
....................  
.................... lcd_line1 (3); 
084F:  MOVLW  03
0850:  MOVWF  63
0851:  BCF    0A.3
0852:  CALL   098
0853:  BSF    0A.3
.................... lcd_data ("Made by:"); 
0854:  MOVLW  10
0855:  BSF    03.6
0856:  MOVWF  0D
0857:  MOVLW  00
0858:  MOVWF  0F
0859:  BCF    0A.3
085A:  BCF    03.6
085B:  CALL   0B5
085C:  BSF    0A.3
.................... lcd_line2 (2); 
085D:  MOVLW  02
085E:  MOVWF  63
085F:  BCF    0A.3
0860:  CALL   10B
0861:  BSF    0A.3
.................... lcd_data ("And Hamza"); 
0862:  MOVLW  15
0863:  BSF    03.6
0864:  MOVWF  0D
0865:  MOVLW  00
0866:  MOVWF  0F
0867:  BCF    0A.3
0868:  BCF    03.6
0869:  CALL   0B5
086A:  BSF    0A.3
.................... delay_ms(1000); 
086B:  MOVLW  04
086C:  MOVWF  63
086D:  MOVLW  FA
086E:  MOVWF  66
086F:  BCF    0A.3
0870:  CALL   057
0871:  BSF    0A.3
0872:  DECFSZ 63,F
0873:  GOTO   06D
.................... lcd_rscrol(20); 
0874:  MOVLW  14
0875:  MOVWF  63
0876:  BCF    0A.3
0877:  CALL   111
0878:  BSF    0A.3
.................... i++; 
0879:  INCF   62,F
.................... } 
.................... while(i==0); 
087A:  MOVF   62,F
087B:  BTFSC  03.2
087C:  GOTO   01C
....................  
.................... lcd_cmd(disp_clear); 
087D:  MOVLW  01
087E:  MOVWF  65
087F:  BCF    0A.3
0880:  CALL   06B
0881:  BSF    0A.3
....................  delay_ms(50); 
0882:  MOVLW  32
0883:  MOVWF  66
0884:  BCF    0A.3
0885:  CALL   057
0886:  BSF    0A.3
....................   
.................... while(1) 
.................... { 
....................  
.................... set_adc_channel(0); 
0887:  MOVLW  00
0888:  MOVWF  78
0889:  MOVF   1F,W
088A:  ANDLW  C7
088B:  IORWF  78,W
088C:  MOVWF  1F
.................... delay_us(100); 
088D:  MOVLW  A6
088E:  MOVWF  77
088F:  DECFSZ 77,F
0890:  GOTO   08F
0891:  NOP
....................  
.................... adc_value = read_adc(); 
0892:  BSF    1F.2
0893:  BTFSC  1F.2
0894:  GOTO   093
0895:  MOVF   1E,W
0896:  MOVWF  7A
0897:  BSF    03.5
0898:  MOVF   1E,W
0899:  BCF    03.5
089A:  MOVWF  63
089B:  MOVF   1E,W
089C:  MOVWF  64
089D:  BCF    0A.3
089E:  CALL   123
089F:  BSF    0A.3
08A0:  MOVF   7A,W
08A1:  MOVWF  29
08A2:  MOVF   79,W
08A3:  MOVWF  28
08A4:  MOVF   78,W
08A5:  MOVWF  27
08A6:  MOVF   77,W
08A7:  MOVWF  26
....................  
.................... voltmeter1= (5.0*adc_value/1023.0)/0.11; 
08A8:  CLRF   73
08A9:  CLRF   72
08AA:  MOVLW  20
08AB:  MOVWF  71
08AC:  MOVLW  81
08AD:  MOVWF  70
08AE:  MOVF   29,W
08AF:  MOVWF  7E
08B0:  MOVF   28,W
08B1:  MOVWF  7D
08B2:  MOVF   27,W
08B3:  MOVWF  7C
08B4:  MOVF   26,W
08B5:  MOVWF  7B
08B6:  BCF    0A.3
08B7:  CALL   140
08B8:  BSF    0A.3
08B9:  MOVF   7A,W
08BA:  MOVWF  66
08BB:  MOVF   79,W
08BC:  MOVWF  65
08BD:  MOVF   78,W
08BE:  MOVWF  64
08BF:  MOVF   77,W
08C0:  MOVWF  63
08C1:  MOVF   66,W
08C2:  MOVWF  6A
08C3:  MOVF   65,W
08C4:  MOVWF  69
08C5:  MOVF   64,W
08C6:  MOVWF  68
08C7:  MOVF   63,W
08C8:  MOVWF  67
08C9:  CLRF   6E
08CA:  MOVLW  C0
08CB:  MOVWF  6D
08CC:  MOVLW  7F
08CD:  MOVWF  6C
08CE:  MOVLW  88
08CF:  MOVWF  6B
08D0:  BCF    0A.3
08D1:  CALL   1C6
08D2:  BSF    0A.3
08D3:  MOVF   7A,W
08D4:  MOVWF  66
08D5:  MOVF   79,W
08D6:  MOVWF  65
08D7:  MOVF   78,W
08D8:  MOVWF  64
08D9:  MOVF   77,W
08DA:  MOVWF  63
08DB:  MOVF   66,W
08DC:  MOVWF  6A
08DD:  MOVF   65,W
08DE:  MOVWF  69
08DF:  MOVF   64,W
08E0:  MOVWF  68
08E1:  MOVF   63,W
08E2:  MOVWF  67
08E3:  MOVLW  AE
08E4:  MOVWF  6E
08E5:  MOVLW  47
08E6:  MOVWF  6D
08E7:  MOVLW  61
08E8:  MOVWF  6C
08E9:  MOVLW  7B
08EA:  MOVWF  6B
08EB:  BCF    0A.3
08EC:  CALL   1C6
08ED:  BSF    0A.3
08EE:  MOVF   7A,W
08EF:  MOVWF  45
08F0:  MOVF   79,W
08F1:  MOVWF  44
08F2:  MOVF   78,W
08F3:  MOVWF  43
08F4:  MOVF   77,W
08F5:  MOVWF  42
....................  
....................  set_adc_channel(1); 
08F6:  MOVLW  08
08F7:  MOVWF  78
08F8:  MOVF   1F,W
08F9:  ANDLW  C7
08FA:  IORWF  78,W
08FB:  MOVWF  1F
.................... delay_us(100); 
08FC:  MOVLW  A6
08FD:  MOVWF  77
08FE:  DECFSZ 77,F
08FF:  GOTO   0FE
0900:  NOP
....................  
.................... adc_value = read_adc(); 
0901:  BSF    1F.2
0902:  BTFSC  1F.2
0903:  GOTO   102
0904:  MOVF   1E,W
0905:  MOVWF  7A
0906:  BSF    03.5
0907:  MOVF   1E,W
0908:  BCF    03.5
0909:  MOVWF  63
090A:  MOVF   1E,W
090B:  MOVWF  64
090C:  BCF    0A.3
090D:  CALL   123
090E:  BSF    0A.3
090F:  MOVF   7A,W
0910:  MOVWF  29
0911:  MOVF   79,W
0912:  MOVWF  28
0913:  MOVF   78,W
0914:  MOVWF  27
0915:  MOVF   77,W
0916:  MOVWF  26
....................  
.................... ammeter1= ((5.0/1023.0*adc_value)-2.5)/0.16; 
0917:  MOVLW  0A
0918:  MOVWF  73
0919:  MOVLW  28
091A:  MOVWF  72
091B:  MOVLW  20
091C:  MOVWF  71
091D:  MOVLW  77
091E:  MOVWF  70
091F:  MOVF   29,W
0920:  MOVWF  7E
0921:  MOVF   28,W
0922:  MOVWF  7D
0923:  MOVF   27,W
0924:  MOVWF  7C
0925:  MOVF   26,W
0926:  MOVWF  7B
0927:  BCF    0A.3
0928:  CALL   140
0929:  BSF    0A.3
092A:  MOVF   7A,W
092B:  MOVWF  66
092C:  MOVF   79,W
092D:  MOVWF  65
092E:  MOVF   78,W
092F:  MOVWF  64
0930:  MOVF   77,W
0931:  MOVWF  63
0932:  BSF    03.1
0933:  MOVF   66,W
0934:  MOVWF  6A
0935:  MOVF   65,W
0936:  MOVWF  69
0937:  MOVF   64,W
0938:  MOVWF  68
0939:  MOVF   63,W
093A:  MOVWF  67
093B:  CLRF   6E
093C:  CLRF   6D
093D:  MOVLW  20
093E:  MOVWF  6C
093F:  MOVLW  80
0940:  MOVWF  6B
0941:  BCF    0A.3
0942:  CALL   290
0943:  BSF    0A.3
0944:  MOVF   7A,W
0945:  MOVWF  66
0946:  MOVF   79,W
0947:  MOVWF  65
0948:  MOVF   78,W
0949:  MOVWF  64
094A:  MOVF   77,W
094B:  MOVWF  63
094C:  MOVF   66,W
094D:  MOVWF  6A
094E:  MOVF   65,W
094F:  MOVWF  69
0950:  MOVF   64,W
0951:  MOVWF  68
0952:  MOVF   63,W
0953:  MOVWF  67
0954:  MOVLW  0A
0955:  MOVWF  6E
0956:  MOVLW  D7
0957:  MOVWF  6D
0958:  MOVLW  23
0959:  MOVWF  6C
095A:  MOVLW  7C
095B:  MOVWF  6B
095C:  BCF    0A.3
095D:  CALL   1C6
095E:  BSF    0A.3
095F:  MOVF   7A,W
0960:  MOVWF  4D
0961:  MOVF   79,W
0962:  MOVWF  4C
0963:  MOVF   78,W
0964:  MOVWF  4B
0965:  MOVF   77,W
0966:  MOVWF  4A
....................  
.................... set_adc_channel(2); 
0967:  MOVLW  10
0968:  MOVWF  78
0969:  MOVF   1F,W
096A:  ANDLW  C7
096B:  IORWF  78,W
096C:  MOVWF  1F
.................... delay_us(100); 
096D:  MOVLW  A6
096E:  MOVWF  77
096F:  DECFSZ 77,F
0970:  GOTO   16F
0971:  NOP
....................  
.................... adc_value = read_adc(); 
0972:  BSF    1F.2
0973:  BTFSC  1F.2
0974:  GOTO   173
0975:  MOVF   1E,W
0976:  MOVWF  7A
0977:  BSF    03.5
0978:  MOVF   1E,W
0979:  BCF    03.5
097A:  MOVWF  63
097B:  MOVF   1E,W
097C:  MOVWF  64
097D:  BCF    0A.3
097E:  CALL   123
097F:  BSF    0A.3
0980:  MOVF   7A,W
0981:  MOVWF  29
0982:  MOVF   79,W
0983:  MOVWF  28
0984:  MOVF   78,W
0985:  MOVWF  27
0986:  MOVF   77,W
0987:  MOVWF  26
....................  
.................... voltmeter2= (5.0*adc_value/1023.0)/0.33; 
0988:  CLRF   73
0989:  CLRF   72
098A:  MOVLW  20
098B:  MOVWF  71
098C:  MOVLW  81
098D:  MOVWF  70
098E:  MOVF   29,W
098F:  MOVWF  7E
0990:  MOVF   28,W
0991:  MOVWF  7D
0992:  MOVF   27,W
0993:  MOVWF  7C
0994:  MOVF   26,W
0995:  MOVWF  7B
0996:  BCF    0A.3
0997:  CALL   140
0998:  BSF    0A.3
0999:  MOVF   7A,W
099A:  MOVWF  66
099B:  MOVF   79,W
099C:  MOVWF  65
099D:  MOVF   78,W
099E:  MOVWF  64
099F:  MOVF   77,W
09A0:  MOVWF  63
09A1:  MOVF   66,W
09A2:  MOVWF  6A
09A3:  MOVF   65,W
09A4:  MOVWF  69
09A5:  MOVF   64,W
09A6:  MOVWF  68
09A7:  MOVF   63,W
09A8:  MOVWF  67
09A9:  CLRF   6E
09AA:  MOVLW  C0
09AB:  MOVWF  6D
09AC:  MOVLW  7F
09AD:  MOVWF  6C
09AE:  MOVLW  88
09AF:  MOVWF  6B
09B0:  BCF    0A.3
09B1:  CALL   1C6
09B2:  BSF    0A.3
09B3:  MOVF   7A,W
09B4:  MOVWF  66
09B5:  MOVF   79,W
09B6:  MOVWF  65
09B7:  MOVF   78,W
09B8:  MOVWF  64
09B9:  MOVF   77,W
09BA:  MOVWF  63
09BB:  MOVF   66,W
09BC:  MOVWF  6A
09BD:  MOVF   65,W
09BE:  MOVWF  69
09BF:  MOVF   64,W
09C0:  MOVWF  68
09C1:  MOVF   63,W
09C2:  MOVWF  67
09C3:  MOVLW  C3
09C4:  MOVWF  6E
09C5:  MOVLW  F5
09C6:  MOVWF  6D
09C7:  MOVLW  28
09C8:  MOVWF  6C
09C9:  MOVLW  7D
09CA:  MOVWF  6B
09CB:  BCF    0A.3
09CC:  CALL   1C6
09CD:  BSF    0A.3
09CE:  MOVF   7A,W
09CF:  MOVWF  49
09D0:  MOVF   79,W
09D1:  MOVWF  48
09D2:  MOVF   78,W
09D3:  MOVWF  47
09D4:  MOVF   77,W
09D5:  MOVWF  46
....................  
.................... set_adc_channel(3); 
09D6:  MOVLW  18
09D7:  MOVWF  78
09D8:  MOVF   1F,W
09D9:  ANDLW  C7
09DA:  IORWF  78,W
09DB:  MOVWF  1F
.................... delay_us(100); 
09DC:  MOVLW  A6
09DD:  MOVWF  77
09DE:  DECFSZ 77,F
09DF:  GOTO   1DE
09E0:  NOP
....................  
.................... adc_value = read_adc(); 
09E1:  BSF    1F.2
09E2:  BTFSC  1F.2
09E3:  GOTO   1E2
09E4:  MOVF   1E,W
09E5:  MOVWF  7A
09E6:  BSF    03.5
09E7:  MOVF   1E,W
09E8:  BCF    03.5
09E9:  MOVWF  63
09EA:  MOVF   1E,W
09EB:  MOVWF  64
09EC:  BCF    0A.3
09ED:  CALL   123
09EE:  BSF    0A.3
09EF:  MOVF   7A,W
09F0:  MOVWF  29
09F1:  MOVF   79,W
09F2:  MOVWF  28
09F3:  MOVF   78,W
09F4:  MOVWF  27
09F5:  MOVF   77,W
09F6:  MOVWF  26
....................  
.................... ammeter2= ((5.0/1023.0*adc_value)-2.5)/0.066; 
09F7:  MOVLW  0A
09F8:  MOVWF  73
09F9:  MOVLW  28
09FA:  MOVWF  72
09FB:  MOVLW  20
09FC:  MOVWF  71
09FD:  MOVLW  77
09FE:  MOVWF  70
09FF:  MOVF   29,W
0A00:  MOVWF  7E
0A01:  MOVF   28,W
0A02:  MOVWF  7D
0A03:  MOVF   27,W
0A04:  MOVWF  7C
0A05:  MOVF   26,W
0A06:  MOVWF  7B
0A07:  BCF    0A.3
0A08:  CALL   140
0A09:  BSF    0A.3
0A0A:  MOVF   7A,W
0A0B:  MOVWF  66
0A0C:  MOVF   79,W
0A0D:  MOVWF  65
0A0E:  MOVF   78,W
0A0F:  MOVWF  64
0A10:  MOVF   77,W
0A11:  MOVWF  63
0A12:  BSF    03.1
0A13:  MOVF   66,W
0A14:  MOVWF  6A
0A15:  MOVF   65,W
0A16:  MOVWF  69
0A17:  MOVF   64,W
0A18:  MOVWF  68
0A19:  MOVF   63,W
0A1A:  MOVWF  67
0A1B:  CLRF   6E
0A1C:  CLRF   6D
0A1D:  MOVLW  20
0A1E:  MOVWF  6C
0A1F:  MOVLW  80
0A20:  MOVWF  6B
0A21:  BCF    0A.3
0A22:  CALL   290
0A23:  BSF    0A.3
0A24:  MOVF   7A,W
0A25:  MOVWF  66
0A26:  MOVF   79,W
0A27:  MOVWF  65
0A28:  MOVF   78,W
0A29:  MOVWF  64
0A2A:  MOVF   77,W
0A2B:  MOVWF  63
0A2C:  MOVF   66,W
0A2D:  MOVWF  6A
0A2E:  MOVF   65,W
0A2F:  MOVWF  69
0A30:  MOVF   64,W
0A31:  MOVWF  68
0A32:  MOVF   63,W
0A33:  MOVWF  67
0A34:  MOVLW  02
0A35:  MOVWF  6E
0A36:  MOVLW  2B
0A37:  MOVWF  6D
0A38:  MOVLW  07
0A39:  MOVWF  6C
0A3A:  MOVLW  7B
0A3B:  MOVWF  6B
0A3C:  BCF    0A.3
0A3D:  CALL   1C6
0A3E:  BSF    0A.3
0A3F:  MOVF   7A,W
0A40:  MOVWF  51
0A41:  MOVF   79,W
0A42:  MOVWF  50
0A43:  MOVF   78,W
0A44:  MOVWF  4F
0A45:  MOVF   77,W
0A46:  MOVWF  4E
....................  
.................... relay (ammeter1); 
0A47:  MOVF   4D,W
0A48:  MOVWF  66
0A49:  MOVF   4C,W
0A4A:  MOVWF  65
0A4B:  MOVF   4B,W
0A4C:  MOVWF  64
0A4D:  MOVF   4A,W
0A4E:  MOVWF  63
0A4F:  BCF    0A.3
0A50:  GOTO   3D1
0A51:  BSF    0A.3
0A52:  MOVF   78,W
0A53:  MOVWF  63
0A54:  MOVWF  64
0A55:  BCF    0A.3
0A56:  GOTO   3F2
0A57:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0A58:  CLRF   63
0A59:  BCF    0A.3
0A5A:  CALL   098
0A5B:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE:%f V",voltmeter1); 
0A5C:  MOVLW  1A
0A5D:  BSF    03.6
0A5E:  MOVWF  0D
0A5F:  MOVLW  00
0A60:  MOVWF  0F
0A61:  BCF    03.0
0A62:  MOVLW  08
0A63:  BCF    03.6
0A64:  MOVWF  63
0A65:  BCF    0A.3
0A66:  CALL   409
0A67:  BSF    0A.3
0A68:  MOVLW  89
0A69:  MOVWF  04
0A6A:  MOVF   45,W
0A6B:  MOVWF  66
0A6C:  MOVF   44,W
0A6D:  MOVWF  65
0A6E:  MOVF   43,W
0A6F:  MOVWF  64
0A70:  MOVF   42,W
0A71:  MOVWF  63
0A72:  MOVLW  02
0A73:  MOVWF  67
0A74:  BCF    0A.3
0A75:  CALL   4B1
0A76:  BSF    0A.3
0A77:  MOVLW  20
0A78:  MOVWF  70
0A79:  BCF    0A.3
0A7A:  CALL   09E
0A7B:  BSF    0A.3
0A7C:  MOVLW  56
0A7D:  MOVWF  70
0A7E:  BCF    0A.3
0A7F:  CALL   09E
0A80:  BSF    0A.3
.................... delay_ms(1000); 
0A81:  MOVLW  04
0A82:  MOVWF  63
0A83:  MOVLW  FA
0A84:  MOVWF  66
0A85:  BCF    0A.3
0A86:  CALL   057
0A87:  BSF    0A.3
0A88:  DECFSZ 63,F
0A89:  GOTO   283
.................... lcd_rscrol(20); 
0A8A:  MOVLW  14
0A8B:  MOVWF  63
0A8C:  BCF    0A.3
0A8D:  CALL   111
0A8E:  BSF    0A.3
.................... delay_ms(1000); 
0A8F:  MOVLW  04
0A90:  MOVWF  63
0A91:  MOVLW  FA
0A92:  MOVWF  66
0A93:  BCF    0A.3
0A94:  CALL   057
0A95:  BSF    0A.3
0A96:  DECFSZ 63,F
0A97:  GOTO   291
....................  
.................... lcd_cmd(disp_clear); 
0A98:  MOVLW  01
0A99:  MOVWF  65
0A9A:  BCF    0A.3
0A9B:  CALL   06B
0A9C:  BSF    0A.3
....................  delay_ms(50); 
0A9D:  MOVLW  32
0A9E:  MOVWF  66
0A9F:  BCF    0A.3
0AA0:  CALL   057
0AA1:  BSF    0A.3
....................   
.................... lcd_line1(0); 
0AA2:  CLRF   63
0AA3:  BCF    0A.3
0AA4:  CALL   098
0AA5:  BSF    0A.3
....................  
....................  printf(lcd_data,"CURRENT:%f A",ammeter1); 
0AA6:  MOVLW  21
0AA7:  BSF    03.6
0AA8:  MOVWF  0D
0AA9:  MOVLW  00
0AAA:  MOVWF  0F
0AAB:  BCF    03.0
0AAC:  MOVLW  08
0AAD:  BCF    03.6
0AAE:  MOVWF  63
0AAF:  BCF    0A.3
0AB0:  CALL   409
0AB1:  BSF    0A.3
0AB2:  MOVLW  89
0AB3:  MOVWF  04
0AB4:  MOVF   4D,W
0AB5:  MOVWF  66
0AB6:  MOVF   4C,W
0AB7:  MOVWF  65
0AB8:  MOVF   4B,W
0AB9:  MOVWF  64
0ABA:  MOVF   4A,W
0ABB:  MOVWF  63
0ABC:  MOVLW  02
0ABD:  MOVWF  67
0ABE:  BCF    0A.3
0ABF:  CALL   4B1
0AC0:  BSF    0A.3
0AC1:  MOVLW  20
0AC2:  MOVWF  70
0AC3:  BCF    0A.3
0AC4:  CALL   09E
0AC5:  BSF    0A.3
0AC6:  MOVLW  41
0AC7:  MOVWF  70
0AC8:  BCF    0A.3
0AC9:  CALL   09E
0ACA:  BSF    0A.3
.................... delay_ms(1000); 
0ACB:  MOVLW  04
0ACC:  MOVWF  63
0ACD:  MOVLW  FA
0ACE:  MOVWF  66
0ACF:  BCF    0A.3
0AD0:  CALL   057
0AD1:  BSF    0A.3
0AD2:  DECFSZ 63,F
0AD3:  GOTO   2CD
.................... lcd_rscrol(20); 
0AD4:  MOVLW  14
0AD5:  MOVWF  63
0AD6:  BCF    0A.3
0AD7:  CALL   111
0AD8:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0AD9:  MOVLW  01
0ADA:  MOVWF  65
0ADB:  BCF    0A.3
0ADC:  CALL   06B
0ADD:  BSF    0A.3
....................  delay_ms(50); 
0ADE:  MOVLW  32
0ADF:  MOVWF  66
0AE0:  BCF    0A.3
0AE1:  CALL   057
0AE2:  BSF    0A.3
....................   
....................  Pin=voltmeter1*ammeter1; 
0AE3:  MOVF   45,W
0AE4:  MOVWF  73
0AE5:  MOVF   44,W
0AE6:  MOVWF  72
0AE7:  MOVF   43,W
0AE8:  MOVWF  71
0AE9:  MOVF   42,W
0AEA:  MOVWF  70
0AEB:  MOVF   4D,W
0AEC:  MOVWF  7E
0AED:  MOVF   4C,W
0AEE:  MOVWF  7D
0AEF:  MOVF   4B,W
0AF0:  MOVWF  7C
0AF1:  MOVF   4A,W
0AF2:  MOVWF  7B
0AF3:  BCF    0A.3
0AF4:  CALL   140
0AF5:  BSF    0A.3
0AF6:  MOVF   7A,W
0AF7:  MOVWF  5D
0AF8:  MOVF   79,W
0AF9:  MOVWF  5C
0AFA:  MOVF   78,W
0AFB:  MOVWF  5B
0AFC:  MOVF   77,W
0AFD:  MOVWF  5A
....................  lcd_line1(0); 
0AFE:  CLRF   63
0AFF:  BCF    0A.3
0B00:  CALL   098
0B01:  BSF    0A.3
....................  lcd_data("INPUT POWER:"); 
0B02:  MOVLW  28
0B03:  BSF    03.6
0B04:  MOVWF  0D
0B05:  MOVLW  00
0B06:  MOVWF  0F
0B07:  BCF    0A.3
0B08:  BCF    03.6
0B09:  CALL   0B5
0B0A:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0B0B:  MOVLW  03
0B0C:  MOVWF  63
0B0D:  BCF    0A.3
0B0E:  CALL   10B
0B0F:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pin); 
0B10:  MOVLW  89
0B11:  MOVWF  04
0B12:  MOVF   5D,W
0B13:  MOVWF  66
0B14:  MOVF   5C,W
0B15:  MOVWF  65
0B16:  MOVF   5B,W
0B17:  MOVWF  64
0B18:  MOVF   5A,W
0B19:  MOVWF  63
0B1A:  MOVLW  02
0B1B:  MOVWF  67
0B1C:  BCF    0A.3
0B1D:  CALL   4B1
0B1E:  BSF    0A.3
0B1F:  MOVLW  20
0B20:  MOVWF  70
0B21:  BCF    0A.3
0B22:  CALL   09E
0B23:  BSF    0A.3
0B24:  MOVLW  57
0B25:  MOVWF  70
0B26:  BCF    0A.3
0B27:  CALL   09E
0B28:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0B29:  MOVLW  04
0B2A:  MOVWF  63
0B2B:  MOVLW  FA
0B2C:  MOVWF  66
0B2D:  BCF    0A.3
0B2E:  CALL   057
0B2F:  BSF    0A.3
0B30:  DECFSZ 63,F
0B31:  GOTO   32B
.................... lcd_rscrol(20); 
0B32:  MOVLW  14
0B33:  MOVWF  63
0B34:  BCF    0A.3
0B35:  CALL   111
0B36:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B37:  MOVLW  01
0B38:  MOVWF  65
0B39:  BCF    0A.3
0B3A:  CALL   06B
0B3B:  BSF    0A.3
....................  delay_ms(50); 
0B3C:  MOVLW  32
0B3D:  MOVWF  66
0B3E:  BCF    0A.3
0B3F:  CALL   057
0B40:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0B41:  CLRF   63
0B42:  BCF    0A.3
0B43:  CALL   098
0B44:  BSF    0A.3
....................  
.................... printf(lcd_data,"VOLTAGE: %f V",voltmeter2); 
0B45:  MOVLW  2F
0B46:  BSF    03.6
0B47:  MOVWF  0D
0B48:  MOVLW  00
0B49:  MOVWF  0F
0B4A:  BCF    03.0
0B4B:  MOVLW  09
0B4C:  BCF    03.6
0B4D:  MOVWF  63
0B4E:  BCF    0A.3
0B4F:  CALL   409
0B50:  BSF    0A.3
0B51:  MOVLW  89
0B52:  MOVWF  04
0B53:  MOVF   49,W
0B54:  MOVWF  66
0B55:  MOVF   48,W
0B56:  MOVWF  65
0B57:  MOVF   47,W
0B58:  MOVWF  64
0B59:  MOVF   46,W
0B5A:  MOVWF  63
0B5B:  MOVLW  02
0B5C:  MOVWF  67
0B5D:  BCF    0A.3
0B5E:  CALL   4B1
0B5F:  BSF    0A.3
0B60:  MOVLW  20
0B61:  MOVWF  70
0B62:  BCF    0A.3
0B63:  CALL   09E
0B64:  BSF    0A.3
0B65:  MOVLW  56
0B66:  MOVWF  70
0B67:  BCF    0A.3
0B68:  CALL   09E
0B69:  BSF    0A.3
.................... delay_ms(1000); 
0B6A:  MOVLW  04
0B6B:  MOVWF  63
0B6C:  MOVLW  FA
0B6D:  MOVWF  66
0B6E:  BCF    0A.3
0B6F:  CALL   057
0B70:  BSF    0A.3
0B71:  DECFSZ 63,F
0B72:  GOTO   36C
.................... lcd_rscrol(20); 
0B73:  MOVLW  14
0B74:  MOVWF  63
0B75:  BCF    0A.3
0B76:  CALL   111
0B77:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0B78:  MOVLW  01
0B79:  MOVWF  65
0B7A:  BCF    0A.3
0B7B:  CALL   06B
0B7C:  BSF    0A.3
....................  delay_ms(50); 
0B7D:  MOVLW  32
0B7E:  MOVWF  66
0B7F:  BCF    0A.3
0B80:  CALL   057
0B81:  BSF    0A.3
....................  
.................... lcd_line1(0); 
0B82:  CLRF   63
0B83:  BCF    0A.3
0B84:  CALL   098
0B85:  BSF    0A.3
....................  
.................... printf(lcd_data,"CURRENT: %f A",ammeter2); 
0B86:  MOVLW  36
0B87:  BSF    03.6
0B88:  MOVWF  0D
0B89:  MOVLW  00
0B8A:  MOVWF  0F
0B8B:  BCF    03.0
0B8C:  MOVLW  09
0B8D:  BCF    03.6
0B8E:  MOVWF  63
0B8F:  BCF    0A.3
0B90:  CALL   409
0B91:  BSF    0A.3
0B92:  MOVLW  89
0B93:  MOVWF  04
0B94:  MOVF   51,W
0B95:  MOVWF  66
0B96:  MOVF   50,W
0B97:  MOVWF  65
0B98:  MOVF   4F,W
0B99:  MOVWF  64
0B9A:  MOVF   4E,W
0B9B:  MOVWF  63
0B9C:  MOVLW  02
0B9D:  MOVWF  67
0B9E:  BCF    0A.3
0B9F:  CALL   4B1
0BA0:  BSF    0A.3
0BA1:  MOVLW  20
0BA2:  MOVWF  70
0BA3:  BCF    0A.3
0BA4:  CALL   09E
0BA5:  BSF    0A.3
0BA6:  MOVLW  41
0BA7:  MOVWF  70
0BA8:  BCF    0A.3
0BA9:  CALL   09E
0BAA:  BSF    0A.3
.................... delay_ms(1000); 
0BAB:  MOVLW  04
0BAC:  MOVWF  63
0BAD:  MOVLW  FA
0BAE:  MOVWF  66
0BAF:  BCF    0A.3
0BB0:  CALL   057
0BB1:  BSF    0A.3
0BB2:  DECFSZ 63,F
0BB3:  GOTO   3AD
.................... lcd_rscrol(20); 
0BB4:  MOVLW  14
0BB5:  MOVWF  63
0BB6:  BCF    0A.3
0BB7:  CALL   111
0BB8:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0BB9:  MOVLW  01
0BBA:  MOVWF  65
0BBB:  BCF    0A.3
0BBC:  CALL   06B
0BBD:  BSF    0A.3
....................  delay_ms(50); 
0BBE:  MOVLW  32
0BBF:  MOVWF  66
0BC0:  BCF    0A.3
0BC1:  CALL   057
0BC2:  BSF    0A.3
....................   
....................   Pout=voltmeter2*ammeter2; 
0BC3:  MOVF   49,W
0BC4:  MOVWF  73
0BC5:  MOVF   48,W
0BC6:  MOVWF  72
0BC7:  MOVF   47,W
0BC8:  MOVWF  71
0BC9:  MOVF   46,W
0BCA:  MOVWF  70
0BCB:  MOVF   51,W
0BCC:  MOVWF  7E
0BCD:  MOVF   50,W
0BCE:  MOVWF  7D
0BCF:  MOVF   4F,W
0BD0:  MOVWF  7C
0BD1:  MOVF   4E,W
0BD2:  MOVWF  7B
0BD3:  BCF    0A.3
0BD4:  CALL   140
0BD5:  BSF    0A.3
0BD6:  MOVF   7A,W
0BD7:  MOVWF  61
0BD8:  MOVF   79,W
0BD9:  MOVWF  60
0BDA:  MOVF   78,W
0BDB:  MOVWF  5F
0BDC:  MOVF   77,W
0BDD:  MOVWF  5E
....................  lcd_line1(0); 
0BDE:  CLRF   63
0BDF:  BCF    0A.3
0BE0:  CALL   098
0BE1:  BSF    0A.3
....................  lcd_data("OUTPUT POWER:"); 
0BE2:  MOVLW  3D
0BE3:  BSF    03.6
0BE4:  MOVWF  0D
0BE5:  MOVLW  00
0BE6:  MOVWF  0F
0BE7:  BCF    0A.3
0BE8:  BCF    03.6
0BE9:  CALL   0B5
0BEA:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0BEB:  MOVLW  03
0BEC:  MOVWF  63
0BED:  BCF    0A.3
0BEE:  CALL   10B
0BEF:  BSF    0A.3
....................  printf(lcd_data,"%f W",Pout); 
0BF0:  MOVLW  89
0BF1:  MOVWF  04
0BF2:  MOVF   61,W
0BF3:  MOVWF  66
0BF4:  MOVF   60,W
0BF5:  MOVWF  65
0BF6:  MOVF   5F,W
0BF7:  MOVWF  64
0BF8:  MOVF   5E,W
0BF9:  MOVWF  63
0BFA:  MOVLW  02
0BFB:  MOVWF  67
0BFC:  BCF    0A.3
0BFD:  CALL   4B1
0BFE:  BSF    0A.3
0BFF:  MOVLW  20
0C00:  MOVWF  70
0C01:  BCF    0A.3
0C02:  CALL   09E
0C03:  BSF    0A.3
0C04:  MOVLW  57
0C05:  MOVWF  70
0C06:  BCF    0A.3
0C07:  CALL   09E
0C08:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0C09:  MOVLW  04
0C0A:  MOVWF  63
0C0B:  MOVLW  FA
0C0C:  MOVWF  66
0C0D:  BCF    0A.3
0C0E:  CALL   057
0C0F:  BSF    0A.3
0C10:  DECFSZ 63,F
0C11:  GOTO   40B
.................... lcd_rscrol(20); 
0C12:  MOVLW  14
0C13:  MOVWF  63
0C14:  BCF    0A.3
0C15:  CALL   111
0C16:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0C17:  MOVLW  01
0C18:  MOVWF  65
0C19:  BCF    0A.3
0C1A:  CALL   06B
0C1B:  BSF    0A.3
....................  delay_ms(50); 
0C1C:  MOVLW  32
0C1D:  MOVWF  66
0C1E:  BCF    0A.3
0C1F:  CALL   057
0C20:  BSF    0A.3
....................   
....................  set_adc_channel(4); 
0C21:  MOVLW  20
0C22:  MOVWF  78
0C23:  MOVF   1F,W
0C24:  ANDLW  C7
0C25:  IORWF  78,W
0C26:  MOVWF  1F
.................... delay_us(100); 
0C27:  MOVLW  A6
0C28:  MOVWF  77
0C29:  DECFSZ 77,F
0C2A:  GOTO   429
0C2B:  NOP
....................  
.................... adc_value = read_adc(); 
0C2C:  BSF    1F.2
0C2D:  BTFSC  1F.2
0C2E:  GOTO   42D
0C2F:  MOVF   1E,W
0C30:  MOVWF  7A
0C31:  BSF    03.5
0C32:  MOVF   1E,W
0C33:  BCF    03.5
0C34:  MOVWF  63
0C35:  MOVF   1E,W
0C36:  MOVWF  64
0C37:  BCF    0A.3
0C38:  CALL   123
0C39:  BSF    0A.3
0C3A:  MOVF   7A,W
0C3B:  MOVWF  29
0C3C:  MOVF   79,W
0C3D:  MOVWF  28
0C3E:  MOVF   78,W
0C3F:  MOVWF  27
0C40:  MOVF   77,W
0C41:  MOVWF  26
....................  
.................... lcd_line1(0); 
0C42:  CLRF   63
0C43:  BCF    0A.3
0C44:  CALL   098
0C45:  BSF    0A.3
....................  
.................... vout= (5.0*adc_value/1023.0); 
0C46:  CLRF   73
0C47:  CLRF   72
0C48:  MOVLW  20
0C49:  MOVWF  71
0C4A:  MOVLW  81
0C4B:  MOVWF  70
0C4C:  MOVF   29,W
0C4D:  MOVWF  7E
0C4E:  MOVF   28,W
0C4F:  MOVWF  7D
0C50:  MOVF   27,W
0C51:  MOVWF  7C
0C52:  MOVF   26,W
0C53:  MOVWF  7B
0C54:  BCF    0A.3
0C55:  CALL   140
0C56:  BSF    0A.3
0C57:  MOVF   7A,W
0C58:  MOVWF  66
0C59:  MOVF   79,W
0C5A:  MOVWF  65
0C5B:  MOVF   78,W
0C5C:  MOVWF  64
0C5D:  MOVF   77,W
0C5E:  MOVWF  63
0C5F:  MOVF   66,W
0C60:  MOVWF  6A
0C61:  MOVF   65,W
0C62:  MOVWF  69
0C63:  MOVF   64,W
0C64:  MOVWF  68
0C65:  MOVF   63,W
0C66:  MOVWF  67
0C67:  CLRF   6E
0C68:  MOVLW  C0
0C69:  MOVWF  6D
0C6A:  MOVLW  7F
0C6B:  MOVWF  6C
0C6C:  MOVLW  88
0C6D:  MOVWF  6B
0C6E:  BCF    0A.3
0C6F:  CALL   1C6
0C70:  BSF    0A.3
0C71:  MOVF   7A,W
0C72:  MOVWF  35
0C73:  MOVF   79,W
0C74:  MOVWF  34
0C75:  MOVF   78,W
0C76:  MOVWF  33
0C77:  MOVF   77,W
0C78:  MOVWF  32
.................... LUX=(1023-adc_value)*15; 
0C79:  BSF    03.1
0C7A:  CLRF   6A
0C7B:  MOVLW  C0
0C7C:  MOVWF  69
0C7D:  MOVLW  7F
0C7E:  MOVWF  68
0C7F:  MOVLW  88
0C80:  MOVWF  67
0C81:  MOVF   29,W
0C82:  MOVWF  6E
0C83:  MOVF   28,W
0C84:  MOVWF  6D
0C85:  MOVF   27,W
0C86:  MOVWF  6C
0C87:  MOVF   26,W
0C88:  MOVWF  6B
0C89:  BCF    0A.3
0C8A:  CALL   290
0C8B:  BSF    0A.3
0C8C:  MOVF   7A,W
0C8D:  MOVWF  66
0C8E:  MOVF   79,W
0C8F:  MOVWF  65
0C90:  MOVF   78,W
0C91:  MOVWF  64
0C92:  MOVF   77,W
0C93:  MOVWF  63
0C94:  MOVF   66,W
0C95:  MOVWF  73
0C96:  MOVF   65,W
0C97:  MOVWF  72
0C98:  MOVF   64,W
0C99:  MOVWF  71
0C9A:  MOVF   63,W
0C9B:  MOVWF  70
0C9C:  CLRF   7E
0C9D:  CLRF   7D
0C9E:  MOVLW  70
0C9F:  MOVWF  7C
0CA0:  MOVLW  82
0CA1:  MOVWF  7B
0CA2:  BCF    0A.3
0CA3:  CALL   140
0CA4:  BSF    0A.3
0CA5:  MOVF   7A,W
0CA6:  MOVWF  59
0CA7:  MOVF   79,W
0CA8:  MOVWF  58
0CA9:  MOVF   78,W
0CAA:  MOVWF  57
0CAB:  MOVF   77,W
0CAC:  MOVWF  56
....................  
.................... lcd_line1(0); 
0CAD:  CLRF   63
0CAE:  BCF    0A.3
0CAF:  CALL   098
0CB0:  BSF    0A.3
....................  lcd_data("LIGHT INTENSITY:"); 
0CB1:  MOVLW  44
0CB2:  BSF    03.6
0CB3:  MOVWF  0D
0CB4:  MOVLW  00
0CB5:  MOVWF  0F
0CB6:  BCF    0A.3
0CB7:  BCF    03.6
0CB8:  CALL   0B5
0CB9:  BSF    0A.3
....................   
....................  lcd_line2(3); 
0CBA:  MOVLW  03
0CBB:  MOVWF  63
0CBC:  BCF    0A.3
0CBD:  CALL   10B
0CBE:  BSF    0A.3
....................  printf(lcd_data,"%f LUX",LUX); 
0CBF:  MOVLW  89
0CC0:  MOVWF  04
0CC1:  MOVF   59,W
0CC2:  MOVWF  66
0CC3:  MOVF   58,W
0CC4:  MOVWF  65
0CC5:  MOVF   57,W
0CC6:  MOVWF  64
0CC7:  MOVF   56,W
0CC8:  MOVWF  63
0CC9:  MOVLW  02
0CCA:  MOVWF  67
0CCB:  BCF    0A.3
0CCC:  CALL   4B1
0CCD:  BSF    0A.3
0CCE:  MOVLW  4E
0CCF:  BSF    03.6
0CD0:  MOVWF  0D
0CD1:  MOVLW  00
0CD2:  MOVWF  0F
0CD3:  BCF    03.0
0CD4:  MOVLW  04
0CD5:  BCF    03.6
0CD6:  MOVWF  63
0CD7:  BCF    0A.3
0CD8:  CALL   409
0CD9:  BSF    0A.3
....................   
.................... delay_ms(1000); 
0CDA:  MOVLW  04
0CDB:  MOVWF  63
0CDC:  MOVLW  FA
0CDD:  MOVWF  66
0CDE:  BCF    0A.3
0CDF:  CALL   057
0CE0:  BSF    0A.3
0CE1:  DECFSZ 63,F
0CE2:  GOTO   4DC
.................... lcd_rscrol(20); 
0CE3:  MOVLW  14
0CE4:  MOVWF  63
0CE5:  BCF    0A.3
0CE6:  CALL   111
0CE7:  BSF    0A.3
....................  
.................... lcd_cmd(disp_clear); 
0CE8:  MOVLW  01
0CE9:  MOVWF  65
0CEA:  BCF    0A.3
0CEB:  CALL   06B
0CEC:  BSF    0A.3
....................  delay_ms(50); 
0CED:  MOVLW  32
0CEE:  MOVWF  66
0CEF:  BCF    0A.3
0CF0:  CALL   057
0CF1:  BSF    0A.3
....................   
....................  set_adc_channel(5); 
0CF2:  MOVLW  28
0CF3:  MOVWF  78
0CF4:  MOVF   1F,W
0CF5:  ANDLW  C7
0CF6:  IORWF  78,W
0CF7:  MOVWF  1F
.................... delay_us(100); 
0CF8:  MOVLW  A6
0CF9:  MOVWF  77
0CFA:  DECFSZ 77,F
0CFB:  GOTO   4FA
0CFC:  NOP
....................  
.................... adc_value1 = read_adc(); 
0CFD:  BSF    1F.2
0CFE:  BTFSC  1F.2
0CFF:  GOTO   4FE
0D00:  MOVF   1E,W
0D01:  MOVWF  7A
0D02:  BSF    03.5
0D03:  MOVF   1E,W
0D04:  BCF    03.5
0D05:  MOVWF  63
0D06:  MOVF   1E,W
0D07:  MOVWF  64
0D08:  BCF    0A.3
0D09:  CALL   123
0D0A:  BSF    0A.3
0D0B:  MOVF   7A,W
0D0C:  MOVWF  2D
0D0D:  MOVF   79,W
0D0E:  MOVWF  2C
0D0F:  MOVF   78,W
0D10:  MOVWF  2B
0D11:  MOVF   77,W
0D12:  MOVWF  2A
....................  
....................  set_adc_channel(6); 
0D13:  MOVLW  30
0D14:  MOVWF  78
0D15:  MOVF   1F,W
0D16:  ANDLW  C7
0D17:  IORWF  78,W
0D18:  MOVWF  1F
.................... delay_us(100); 
0D19:  MOVLW  A6
0D1A:  MOVWF  77
0D1B:  DECFSZ 77,F
0D1C:  GOTO   51B
0D1D:  NOP
....................  
.................... adc_value2 = read_adc(); 
0D1E:  BSF    1F.2
0D1F:  BTFSC  1F.2
0D20:  GOTO   51F
0D21:  MOVF   1E,W
0D22:  MOVWF  7A
0D23:  BSF    03.5
0D24:  MOVF   1E,W
0D25:  BCF    03.5
0D26:  MOVWF  63
0D27:  MOVF   1E,W
0D28:  MOVWF  64
0D29:  BCF    0A.3
0D2A:  CALL   123
0D2B:  BSF    0A.3
0D2C:  MOVF   7A,W
0D2D:  MOVWF  31
0D2E:  MOVF   79,W
0D2F:  MOVWF  30
0D30:  MOVF   78,W
0D31:  MOVWF  2F
0D32:  MOVF   77,W
0D33:  MOVWF  2E
....................  
.................... lcd_line1(0); 
0D34:  CLRF   63
0D35:  BCF    0A.3
0D36:  CALL   098
0D37:  BSF    0A.3
....................  
.................... v1=(5.0*adc_value1)/1023.0; 
0D38:  CLRF   73
0D39:  CLRF   72
0D3A:  MOVLW  20
0D3B:  MOVWF  71
0D3C:  MOVLW  81
0D3D:  MOVWF  70
0D3E:  MOVF   2D,W
0D3F:  MOVWF  7E
0D40:  MOVF   2C,W
0D41:  MOVWF  7D
0D42:  MOVF   2B,W
0D43:  MOVWF  7C
0D44:  MOVF   2A,W
0D45:  MOVWF  7B
0D46:  BCF    0A.3
0D47:  CALL   140
0D48:  BSF    0A.3
0D49:  MOVF   7A,W
0D4A:  MOVWF  66
0D4B:  MOVF   79,W
0D4C:  MOVWF  65
0D4D:  MOVF   78,W
0D4E:  MOVWF  64
0D4F:  MOVF   77,W
0D50:  MOVWF  63
0D51:  MOVF   66,W
0D52:  MOVWF  6A
0D53:  MOVF   65,W
0D54:  MOVWF  69
0D55:  MOVF   64,W
0D56:  MOVWF  68
0D57:  MOVF   63,W
0D58:  MOVWF  67
0D59:  CLRF   6E
0D5A:  MOVLW  C0
0D5B:  MOVWF  6D
0D5C:  MOVLW  7F
0D5D:  MOVWF  6C
0D5E:  MOVLW  88
0D5F:  MOVWF  6B
0D60:  BCF    0A.3
0D61:  CALL   1C6
0D62:  BSF    0A.3
0D63:  MOVF   7A,W
0D64:  MOVWF  39
0D65:  MOVF   79,W
0D66:  MOVWF  38
0D67:  MOVF   78,W
0D68:  MOVWF  37
0D69:  MOVF   77,W
0D6A:  MOVWF  36
.................... v2=(5.0*adc_value2)/1023.0; 
0D6B:  CLRF   73
0D6C:  CLRF   72
0D6D:  MOVLW  20
0D6E:  MOVWF  71
0D6F:  MOVLW  81
0D70:  MOVWF  70
0D71:  MOVF   31,W
0D72:  MOVWF  7E
0D73:  MOVF   30,W
0D74:  MOVWF  7D
0D75:  MOVF   2F,W
0D76:  MOVWF  7C
0D77:  MOVF   2E,W
0D78:  MOVWF  7B
0D79:  BCF    0A.3
0D7A:  CALL   140
0D7B:  BSF    0A.3
0D7C:  MOVF   7A,W
0D7D:  MOVWF  66
0D7E:  MOVF   79,W
0D7F:  MOVWF  65
0D80:  MOVF   78,W
0D81:  MOVWF  64
0D82:  MOVF   77,W
0D83:  MOVWF  63
0D84:  MOVF   66,W
0D85:  MOVWF  6A
0D86:  MOVF   65,W
0D87:  MOVWF  69
0D88:  MOVF   64,W
0D89:  MOVWF  68
0D8A:  MOVF   63,W
0D8B:  MOVWF  67
0D8C:  CLRF   6E
0D8D:  MOVLW  C0
0D8E:  MOVWF  6D
0D8F:  MOVLW  7F
0D90:  MOVWF  6C
0D91:  MOVLW  88
0D92:  MOVWF  6B
0D93:  BCF    0A.3
0D94:  CALL   1C6
0D95:  BSF    0A.3
0D96:  MOVF   7A,W
0D97:  MOVWF  3D
0D98:  MOVF   79,W
0D99:  MOVWF  3C
0D9A:  MOVF   78,W
0D9B:  MOVWF  3B
0D9C:  MOVF   77,W
0D9D:  MOVWF  3A
.................... temperature=(v1-v2)*100.0; 
0D9E:  BSF    03.1
0D9F:  MOVF   39,W
0DA0:  MOVWF  6A
0DA1:  MOVF   38,W
0DA2:  MOVWF  69
0DA3:  MOVF   37,W
0DA4:  MOVWF  68
0DA5:  MOVF   36,W
0DA6:  MOVWF  67
0DA7:  MOVF   3D,W
0DA8:  MOVWF  6E
0DA9:  MOVF   3C,W
0DAA:  MOVWF  6D
0DAB:  MOVF   3B,W
0DAC:  MOVWF  6C
0DAD:  MOVF   3A,W
0DAE:  MOVWF  6B
0DAF:  BCF    0A.3
0DB0:  CALL   290
0DB1:  BSF    0A.3
0DB2:  MOVF   7A,W
0DB3:  MOVWF  66
0DB4:  MOVF   79,W
0DB5:  MOVWF  65
0DB6:  MOVF   78,W
0DB7:  MOVWF  64
0DB8:  MOVF   77,W
0DB9:  MOVWF  63
0DBA:  MOVF   66,W
0DBB:  MOVWF  73
0DBC:  MOVF   65,W
0DBD:  MOVWF  72
0DBE:  MOVF   64,W
0DBF:  MOVWF  71
0DC0:  MOVF   63,W
0DC1:  MOVWF  70
0DC2:  CLRF   7E
0DC3:  CLRF   7D
0DC4:  MOVLW  48
0DC5:  MOVWF  7C
0DC6:  MOVLW  85
0DC7:  MOVWF  7B
0DC8:  BCF    0A.3
0DC9:  CALL   140
0DCA:  BSF    0A.3
0DCB:  MOVF   7A,W
0DCC:  MOVWF  55
0DCD:  MOVF   79,W
0DCE:  MOVWF  54
0DCF:  MOVF   78,W
0DD0:  MOVWF  53
0DD1:  MOVF   77,W
0DD2:  MOVWF  52
....................  
.................... printf(lcd_data,"TEMP: %f C",temperature); 
0DD3:  MOVLW  51
0DD4:  BSF    03.6
0DD5:  MOVWF  0D
0DD6:  MOVLW  00
0DD7:  MOVWF  0F
0DD8:  BCF    03.0
0DD9:  MOVLW  06
0DDA:  BCF    03.6
0DDB:  MOVWF  63
0DDC:  BCF    0A.3
0DDD:  CALL   409
0DDE:  BSF    0A.3
0DDF:  MOVLW  89
0DE0:  MOVWF  04
0DE1:  MOVF   55,W
0DE2:  MOVWF  66
0DE3:  MOVF   54,W
0DE4:  MOVWF  65
0DE5:  MOVF   53,W
0DE6:  MOVWF  64
0DE7:  MOVF   52,W
0DE8:  MOVWF  63
0DE9:  MOVLW  02
0DEA:  MOVWF  67
0DEB:  BCF    0A.3
0DEC:  CALL   4B1
0DED:  BSF    0A.3
0DEE:  MOVLW  20
0DEF:  MOVWF  70
0DF0:  BCF    0A.3
0DF1:  CALL   09E
0DF2:  BSF    0A.3
0DF3:  MOVLW  43
0DF4:  MOVWF  70
0DF5:  BCF    0A.3
0DF6:  CALL   09E
0DF7:  BSF    0A.3
.................... delay_ms(1000); 
0DF8:  MOVLW  04
0DF9:  MOVWF  63
0DFA:  MOVLW  FA
0DFB:  MOVWF  66
0DFC:  BCF    0A.3
0DFD:  CALL   057
0DFE:  BSF    0A.3
0DFF:  DECFSZ 63,F
0E00:  GOTO   5FA
.................... lcd_rscrol(20); 
0E01:  MOVLW  14
0E02:  MOVWF  63
0E03:  BCF    0A.3
0E04:  CALL   111
0E05:  BSF    0A.3
0E06:  GOTO   087
....................  
.................... } 
.................... } 
0E07:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
